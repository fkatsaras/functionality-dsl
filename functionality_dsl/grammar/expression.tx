import utils

// Root
Expr: OrExpr ;

// or/and with explicit tails
OrExpr:  left=AndExpr   (ops+=OrTail)* ;
OrTail:  op='or'        right=AndExpr ;

AndExpr: left=CmpExpr   (ops+=AndTail)* ;
AndTail: op='and'       right=CmpExpr ;

// comparisons
CmpOp: '==' | '!=' | '>=' | '<=' | '>' | '<' ;
CmpExpr: left=AddExpr (ops+=CmpTail)* ;
CmpTail: op=CmpOp    right=AddExpr ;

// additive / multiplicative
AddExpr: left=MulExpr (ops+=AddTail)* ;
AddTail: op=AddOp     right=MulExpr ;
AddOp:   '+' | '-' ;

MulExpr: left=UnaryExpr (ops+=MulTail)* ;
MulTail: op=MulOp       right=UnaryExpr ;
MulOp:   '*' | '/' | '%' ;

// unary binds to Atom
UnaryExpr: unops+=UnaryOp* post=PostfixExpr ;
UnaryOp:   op=UnaryOpTok ;
UnaryOpTok: 'not' | '-' ;

// -------- postfix expressions --------
PostfixExpr: base=AtomBase (tails+=PostfixTail)* ;

PostfixTail:
      member=MemberAccess
    | index=IndexAccess
;

MemberAccess: '.' name=ID ;
IndexAccess:  '[' index=Expr ']' ;

// -------- atoms --------
AtomBase:
      listcomp=ListCompExpr
    | dictcomp=DictCompExpr
    | literal=Literal
    | call=Call
    | var=Var
    | ifx=IfThenElse
    | '(' inner=Expr ')'
;

Var: name=ID ;
// ternary
IfThenElse:
  'if' cond=Expr 'then' thenExpr=Expr 'else' elseExpr=Expr
;

// calls
Call:
  func=ID '(' (args+=Expr (',' args+=Expr)*)? ')'
;

// legacy ref (still works): alias.attr
Ref: alias=ID '.' attr=ID ;

// literals
Literal:
      STRING
    | FLOAT
    | INT
    | Bool
    | 'null'
    | ListLiteral
    | DictLiteral
;

// plain list
ListLiteral:
    '[' (items+=Expr (',' items+=Expr)*)? ']'
;

// list comprehension
ListCompExpr:
    '[' head=Expr 'for' var=ID 'in' iterable=Expr ('if' cond=Expr)? ']'
;

DictLiteral:
  '{' (pairs+=KeyValue (',' pairs+=KeyValue)*)? '}'
;

KeyValue:
  (key_str=STRING | key_id=ID) ':' value=Expr
;
// Dict comprehension
DictCompExpr:
  '{' key=Expr ':' value=Expr 'for' var=ID 'in' iterable=Expr ('if' cond=Expr)? '}'
;

