import utils

// Root
Expr: IfThenElse ;

// ternary
IfThenElse:
    orExpr=OrExpr
    ( 'if' cond=OrExpr 'else' elseExpr=OrExpr )?
;

// or/and with explicit tails
OrExpr:  left=AndExpr   (ops+=OrTail)* ;
OrTail:  op='or'        right=AndExpr ;

AndExpr: left=CmpExpr   (ops+=AndTail)* ;
AndTail: op='and'       right=CmpExpr ;

// comparisons
CmpOp: '==' | '!=' | '>=' | '<=' | '>' | '<' ;
CmpExpr: left=AddExpr (ops+=CmpTail)* ;
CmpTail: op=CmpOp    right=AddExpr ;

// additive / multiplicative
AddExpr: left=MulExpr (ops+=AddTail)* ;
AddTail: op=AddOp     right=MulExpr ;
AddOp:   '+' | '-' ;

MulExpr: left=UnaryExpr (ops+=MulTail)* ;
MulTail: op=MulOp       right=UnaryExpr ;
MulOp:   '*' | '/' | '%' ;

// unary binds to lambda or postfix (so '-' won't capture the '-' of '->')
UnaryExpr:
    unops+=UnaryOp* (lambda_=LambdaExpr | post=PostfixExpr)
;

UnaryOp:   op=UnaryOpTok ;
UnaryOpTok: 'not' | '-' ;

// -------- postfix expressions --------
PostfixExpr: base=AtomBase (tails+=PostfixTail)* ;

PostfixTail:
      member=MemberAccess
    | index=IndexAccess
;

MemberAccess: '.' name=ID ;
IndexAccess:  '[' index=Expr ']' ;

// -------- atoms --------
AtomBase:
      listcomp=ListCompExpr
    | dictcomp=DictCompExpr
    | literal=Literal
    | call=Call
    | var=Var
    | '(' inner=Expr ')'
;

Var: name=ID ;

LambdaExpr:
    (param=ID | params=TupleParams) '->' body=Expr
;

TupleParams:
    '(' vars+=ID (',' vars+=ID)* ')'
;


// calls
Call:
  func=ID '(' (args+=Expr (',' args+=Expr)*)? ')'
;

// legacy ref (still works): alias.attr
Ref: alias=ID '.' attr=ID ;

// literals
Literal:
      STRING
    | FLOAT
    | INT
    | Bool
    | 'null'
    | ListLiteral
    | DictLiteral
;

// plain list
ListLiteral:
    '[' (items+=Expr (',' items+=Expr)*)? ']'
;

// list comprehension
ListCompExpr:
    '[' head=Expr 'for' var=CompTarget 'in' iterable=Expr ( 'if' cond=Expr )? ']'
;

// explicit target kinds
CompTarget:
      single=Var         // plain loop variable
    | tuple=TupleTarget  // tuple-unpack
;

// tuple target e.g. for (a,b) in ...
TupleTarget:
    '(' vars+=Var[','] ')'
;

DictLiteral:
  '{' (pairs+=KeyValue (',' pairs+=KeyValue)*)? '}'
;

KeyValue:
  (key_str=STRING | key_id=ID) ':' value=Expr
;
// Dict comprehension
DictCompExpr:
  '{' key=Expr ':' value=Expr 'for' var=ID 'in' iterable=Expr ('if' cond=Expr)? '}'
;

