import utils

// Root
Expr: IfThenElse ;

// ternary
IfThenElse:
    orExpr=OrExpr
    ( 'if' cond=OrExpr 'else' elseExpr=OrExpr )?
;

// or/and with explicit tails
OrExpr:  left=AndExpr   (ops+=OrTail)* ;
OrTail:  op='or'        right=AndExpr ;

AndExpr: left=CmpExpr   (ops+=AndTail)* ;
AndTail: op='and'       right=CmpExpr ;

// comparisons
CmpOp: '==' | '!=' | '>=' | '<=' | '>' | '<' ;
CmpExpr: left=AddExpr (ops+=CmpTail)* ;
CmpTail: op=CmpOp    right=AddExpr ;

// additive / multiplicative
AddExpr: left=MulExpr (ops+=AddTail)* ;
AddTail: op=AddOp     right=MulExpr ;
AddOp:   '+' | '-' ;

MulExpr: left=UnaryExpr (ops+=MulTail)* ;
MulTail: op=MulOp       right=UnaryExpr ;
MulOp:   '*' | '/' | '%' ;

// unary binds to lambda or postfix (so '-' won't capture the '-' of '=>')
UnaryExpr:
    unops+=UnaryOp* (lambda_=LambdaExpr | post=PostfixExpr)
;

UnaryOp:   op=UnaryOpTok ;
UnaryOpTok: 'not' | '-' ;

// -------- postfix expressions --------
PostfixExpr: base=AtomBase (tails+=PostfixTail)* ;

PostfixTail:
      member=MemberAccess
    | index=IndexAccess
;

MemberAccess: '.' name=ID ;
IndexAccess:  '[' (slice=SliceExpr | index=Expr) ']' ;

// Python-style slicing: arr[start:end:step]
SliceExpr:
    (start=Expr)? ':' (end=Expr)? (':' (step=Expr)?)?
;

// -------- atoms --------
AtomBase:
      literal=Literal
    | call=Call
    | var=Var
    | '(' inner=Expr ')'
;

Var: name=ID ;

LambdaExpr:
    (param=ID | params=TupleParams) '=>' body=Expr
;

TupleParams:
    '(' vars+=ID (',' vars+=ID)* ')'
;


// calls
Call:
  func=ID '(' (args+=Expr (',' args+=Expr)*)? ')'
;

// legacy ref (still works): alias.attr
Ref: alias=ID '.' attr=ID ;

// literals
Literal:
      STRING
    | FLOAT
    | INT
    | Bool
    | 'null'
    | ListLiteral
    | DictLiteral
;

// plain list
ListLiteral:
    '[' (items+=Expr (',' items+=Expr)*)? ']'
;

DictLiteral:
  '{' (pairs+=KeyValue (',' pairs+=KeyValue)*)? '}'
;

KeyValue:
  (key_str=STRING | key_id=ID) ':' value=Expr
;

