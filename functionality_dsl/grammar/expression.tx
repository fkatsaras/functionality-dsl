import utils

// Root
Expr: OrExpr ;

// or/and with explicit tails
OrExpr:  left=AndExpr   (ops+=OrTail)* ;
OrTail:  op='or'        right=AndExpr ;

AndExpr: left=CmpExpr   (ops+=AndTail)* ;
AndTail: op='and'       right=CmpExpr ;

// comparisons
CmpOp: '==' | '!=' | '>' | '>=' | '<' | '<=' ;
CmpExpr: left=AddExpr (ops+=CmpTail)* ;
CmpTail: op=CmpOp    right=AddExpr ;

// additive / multiplicative
AddExpr: left=MulExpr (ops+=AddTail)* ;
AddTail: op=AddOp     right=MulExpr ;
AddOp:   '+' | '-' ;

MulExpr: left=UnaryExpr (ops+=MulTail)* ;
MulTail: op=MulOp       right=UnaryExpr ;
MulOp:   '*' | '/' | '%' ;

// unary binds to Atom
UnaryExpr: unops+=UnaryOp* atom=Atom ;
UnaryOp:   op=UnaryOpTok ;
UnaryOpTok: 'not' | '-' ;

// atoms
Atom:
      literal=Literal
    | ref=Ref
    | call=Call
    | ifx=IfThenElse
    | '(' inner=Expr ')'
;

// ternary
IfThenElse:
  'if' cond=Expr 'then' thenExpr=Expr 'else' elseExpr=Expr
;

// calls
Call:
  func=ID '(' (args+=Expr (',' args+=Expr)*)? ')'
;

// references: bind 'data' to a field
Ref:
    (data='data' '.' attr=ID)
  | (alias=ID '.' attr=ID)
;

// literals
Literal:
      STRING
    | FLOAT
    | INT
    | Bool
    | 'null'
    | ListLiteral
;

ListLiteral:
    '[' (items+=Expr (',' items+=Expr)*)? ']'
;
