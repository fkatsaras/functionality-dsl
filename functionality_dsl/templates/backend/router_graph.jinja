# ========================================================================
# AUTO-GENERATED GRAPH ENDPOINT
# ========================================================================

import json
import pathlib

from fastapi import APIRouter
from fastapi.responses import JSONResponse, HTMLResponse


router = APIRouter(prefix="/graph", tags=["Graph"])

# Load graph data
GRAPH_PATH = pathlib.Path(__file__).parent / "graph_data.json"
DATA = json.loads(GRAPH_PATH.read_text()) if GRAPH_PATH.exists() else {"nodes": [], "edges": []}

# JSON view
@router.get("/data", response_class=JSONResponse)
async def get_graph_data():
    """Return dependency graph (nodes + edges) as JSON"""
    return DATA

# Simple D3 HTML Viewer
@router.get("", response_class=HTMLResponse)
async def get_graph_html():
    """Return an interactive HTML visualization of the dependency graph"""
    html ="""
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Dependency Graph</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<style>
  :root {
    --canvas: #0e1116;
    --surface: #0f172a;
    --edge: #2b3445;
    --edge-soft: #1f2837;
    --text: #e5e7eb;
    --text-muted: #a7b0c0;
  }

  html, body {
    margin: 0;
    height: 100%;
    width: 100%;
    background: var(--canvas);
    color: var(--text);
    font-family: "Approach Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    overflow: hidden;
  }

  /* Remove card constraint â†’ full-screen canvas */
  #graph {
    width: 100vw;
    height: 100vh;
    background: var(--surface);
    display: block;
    cursor: grab;
  }

  line {
    stroke: var(--edge-soft);
    stroke-opacity: 0.4;
    stroke-width: 1.4;
  }

  .node circle {
    stroke: var(--edge);
    stroke-width: 1.6px;
    cursor: grab;
    transition: all 0.25s ease;
  }

  .node:hover circle {
    r: 16;
    stroke-width: 2.2px;
  }

  text {
    font-size: 0.8rem;
    fill: var(--text-muted);
    pointer-events: none;
  }

  .header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: var(--card);
    border-bottom: 1px solid var(--edge);
    z-index: 10;
    padding: 0.75rem 1.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .header h2 {
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--text);
    margin: 0;
  }

  .legend {
    display: flex;
    gap: 1rem;
    font-size: 0.8rem;
    color: var(--text-muted);
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
  }

  #graph {
    position: absolute;
    top: 70px; /* space for header */
    width: 100vw;
    height: calc(100vh - 70px);
    background: var(--surface);
  }
</style>

<body>
  <div class="header">
    <h2>API Entity Dependency Graph</h2>

    <div class="legend">
      <span><span class="legend-dot" style="background:#5DADE2"></span>Entity</span>
      <span><span class="legend-dot" style="background:#58D68D"></span>APIEndpoint</span>
      <span><span class="legend-dot" style="background:#F4D03F"></span>SourceREST</span>
      <span><span class="legend-dot" style="background:#E67E22"></span>SourceWS</span>
    </div>
  </div>

  <svg id="graph"></svg>

<script>
  const svg = d3.select("#graph");
  const width = svg.node().clientWidth || window.innerWidth * 0.9;
  const height = svg.node().clientHeight || window.innerHeight * 0.75;

  fetch(window.location.origin + "/graph/data")
    .then(res => res.json())
    .then(data => {
      data.edges = data.edges.map(e => ({ source: e.from, target: e.to }));

      const colorMap = {
        Entity: "#5DADE2",
        APIEndpoint: "#58D68D",
        SourceREST: "#F4D03F",
        SourceWS: "#E67E22"
      };

      const simulation = d3.forceSimulation(data.nodes)
        .force("link", d3.forceLink(data.edges).id(d => d.id).distance(200))
        .force("charge", d3.forceManyBody().strength(-600))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(60));

      const link = svg.append("g")
        .selectAll("line")
        .data(data.edges)
        .join("line");

      const node = svg.append("g")
        .selectAll("circle")
        .data(data.nodes)
        .join("circle")
        .attr("r", 14)
        .attr("fill", d => colorMap[d.type] || "#ccc")
        .attr("stroke", "#0e1116")
        .attr("stroke-width", 1.5)
        .call(drag(simulation));

      const label = svg.append("g")
        .selectAll("text")
        .data(data.nodes)
        .join("text")
        .text(d => d.label)
        .attr("font-size", "0.85rem")
        .attr("fill", "var(--text-muted)");

      node.append("title").text(d => `${d.type}: ${d.label}`);

      simulation.on("tick", () => {
        const margin = 40; // safety padding inside card

        // Keep nodes within visible area
        data.nodes.forEach(d => {
          d.x = Math.max(margin, Math.min(width - margin, d.x));
          d.y = Math.max(margin, Math.min(height - margin, d.y));
        });

        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        label
          .attr("x", d => d.x + 18)
          .attr("y", d => d.y + 5);
      });

      // Freeze positions after layout
      simulation.on("end", () => {
        data.nodes.forEach(d => {
          d.fx = Math.max(30, Math.min(width - 30, d.x));
          d.fy = Math.max(30, Math.min(height - 30, d.y));
        });
        console.log("Graph layout frozen and clamped.");
      });

      simulation.alpha(1).restart();

      // --- Drag behavior (move but stay inside card) ---
      function drag(simulation) {
        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }
        function dragged(event, d) {
          const margin = 40;
          d.fx = Math.max(margin, Math.min(width - margin, event.x));
          d.fy = Math.max(margin, Math.min(height - margin, event.y));
        }
        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
        }
        return d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);
      }

      // Resize handler
      window.addEventListener("resize", () => {
        const w = svg.node().clientWidth || window.innerWidth * 0.9;
        const h = svg.node().clientHeight || window.innerHeight * 0.75;
        simulation.force("center", d3.forceCenter(w / 2, h / 2));
      });
    });
</script>


</body>


</html>
    """
    return HTMLResponse(content=html, status_code=200)