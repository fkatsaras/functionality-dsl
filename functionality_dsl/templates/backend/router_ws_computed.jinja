# app/api/routers/{{ entity.name | lower }}_stream.py
import asyncio
import contextlib
from contextlib import asynccontextmanager
from typing import Any, Dict, Optional, Set

from fastapi import APIRouter, WebSocket, WebSocketDisconnect

from app.core.computed import DSL_FUNCTION_REGISTRY as dsl_funcs
from app.domain.models import {{ entity.name }}
from app.services.{{ entity.name | lower }}_service import {{ entity.name }}Service
{% for inp in inputs %}
from app.services.{{ inp.target_name | lower }}_service import {{ inp.target_name }}Service
{% endfor %}
# subscribe to the first WS-backed input's listener
from app.api.routers.{{ ws_input_listener_module }} import subscribe, unsubscribe, _ensure_started

router = APIRouter(
    prefix="/api/entities/{{ entity.name | lower }}",
    tags=["{{ entity.name }} (stream)"],
)

_clients: Set[WebSocket] = set()
_clients_lock = asyncio.Lock()
_task: Optional[asyncio.Task] = None

async def _broadcast(msg: Any):
    dead: list[WebSocket] = []
    async with _clients_lock:
        for ws in list(_clients):
            try:
                await ws.send_json(msg)
            except Exception:
                dead.append(ws)
        for ws in dead:
            _clients.discard(ws)

async def _compute_latest_row() -> Dict[str, Any] | None:
    """
    Recompute a single row using servicesâ€™ latest snapshots.
    - For WS-backed inputs: their Service().list() returns [latest] via adapter.
    - For REST-backed inputs: Service().list() fetches list; we use the last item if present.
    """
    {{ entity.name[0].lower() + entity.name[1:] }}_svc = {{ entity.name }}Service(
    {% for inp in inputs %}
        {{ inp.alias }}={{ inp.target_name }}Service(),
    {% endfor %}
    )
    rows = await {{ entity.name[0].lower() + entity.name[1:] }}_svc.list()
    if not rows:
        return None
    return rows[-1].model_dump()

async def _loop():
    _ensure_started()
    q = subscribe()
    try:
        # compute once on start
        with contextlib.suppress(Exception):
            first = await _compute_latest_row()
            if first is not None:
                await _broadcast(first)

        # on every upstream WS tick, recompute and broadcast
        while True:
            _ = await q.get()
            with contextlib.suppress(Exception):
                row = await _compute_latest_row()
                if row is not None:
                    await _broadcast(row)
    finally:
        await unsubscribe(q)

@router.websocket("/stream")
async def stream(ws: WebSocket):
    global _task
    await ws.accept()
    async with _clients_lock:
        _clients.add(ws)
    try:
        if _task is None or _task.done():
            _task = asyncio.create_task(_loop())
        # push current value immediately if we can compute one
        with contextlib.suppress(Exception):
            cur = await _compute_latest_row()
            if cur is not None:
                await ws.send_json(cur)
        # keep open (we don't expect messages from client)
        while True:
            await ws.receive_text()
    except WebSocketDisconnect:
        pass
    finally:
        async with _clients_lock:
            _clients.discard(ws)
