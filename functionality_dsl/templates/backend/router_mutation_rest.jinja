# ========================================================================
# AUTO-GENERATED MUTATION ROUTER
# ========================================================================

import json
import logging
from typing import Any, Dict

from fastapi import APIRouter, HTTPException, Request

from app.core.http import get_http_client
from app.core.runtime.safe_eval import compile_safe, safe_globals
from app.core.utils import resolve_headers, interpolate_url, normalize_path_value

{% if target %}
logger = logging.getLogger("fdsl.router.{{ endpoint.name }}.{{ target.method.lower() }}")
{% else %}
logger = logging.getLogger("fdsl.router.{{ endpoint.name }}.internal")
{% endif %}

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ endpoint.summary or endpoint.name }}"]
)

# ============================================================================
#                          CONFIGURATION
# ============================================================================

_EXTERNAL_REST_SOURCES = [
{%- for source in rest_inputs %}
    {
        "entity": "{{ source.entity }}",
        "alias": "{{ source.alias }}",
        "url": "{{ source.url }}",
        "headers": {{ source.headers }},
        "method": "{{ source.method }}",
        "attrs": [
        {%- for attr in source.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ]
    },
{%- endfor %}
]

_INTERNAL_DEPENDENCIES = [
{%- for dep in computed_parents | default([], true) %}
    {"name": "{{ dep.name }}", "endpoint": "{{ dep.endpoint }}/"},
{%- endfor %}
]

_TRANSFORMATION_CHAIN = [
{%- for step in compiled_chain %}
    {
        "name": "{{ step.name }}",
        "attrs": [
        {%- for attr in step.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ]{% if step.validations %},
        "validations": [
        {%- for v in step.validations %}
            {"pyexpr": {{ v.pyexpr | tojson }}},
        {%- endfor %}
        ]{% endif %}
    },

{%- endfor %}
]

{% if target %}
_EXTERNAL_TARGET = {
    "name": "{{ target.name }}",
    "url": "{{ target.url }}",
    "method": "{{ target.method }}",
    "headers": {{ target.headers | tojson }},
}
{% endif %}


# ============================================================================
#                          MUTATION ENDPOINT
# ============================================================================

{% set pparams = endpoint.path_params or [] %}
@router.{% if target %}{{ target.method.lower() }}{% else %}post{% endif %}("", response_model=Dict[str, Any])
async def mutate_{{ endpoint.name | lower }}{% if target %}_{{ target.method.lower() }}{% endif %}(
    request: Request{% for p in pparams %}, {{ p }}: str{% endfor %}
):
    """
    Mutation endpoint for {{ entity.name }}.
    {% if target %}
    Transforms input data through computation chain and forwards to {{ target.name }}.
    {% else %}
    Transforms input data through computation chain (internal endpoint, no forwarding).
    {% endif %}
    """
    http_client = get_http_client()
    context: Dict[str, Any] = {}

    # Parse incoming request body
    try:
        request_body = await request.json()
        logger.info(f"[REQUEST] - Received payload with keys: {list(request_body.keys())}")
    except Exception as parse_error:
        logger.warning(f"[REQUEST] - Failed to parse JSON body: {parse_error}")
        request_body = {}

    try:
        # ----------------------------------------------------------------
        # STEP 1: Seed context with incoming payload + path params
        # ----------------------------------------------------------------
        seed_payload = request_body or {}
        {% if pparams|length %}
        for _param_name, _param_value in [
          {% for p in pparams %}("{{ p }}", {{ p }}){% if not loop.last %}, {% endif %}{% endfor %}
        ]:
            seed_payload[_param_name] = normalize_path_value(_param_value)
        {% endif %}
        if seed_payload:
            context["{{ endpoint.name }}"] = seed_payload
            logger.debug(f"[CONTEXT] - Seeded with endpoint payload + path params: {{ endpoint.name }}")

        # ----------------------------------------------------------------
        # STEP 2: Fetch external REST sources
        # ----------------------------------------------------------------
        for source_config in _EXTERNAL_REST_SOURCES:
            entity_name = source_config["entity"]
            source_alias = source_config["alias"]
            url = source_config["url"]
            url = interpolate_url(url, context)
            method = source_config["method"]
            
            logger.info(f"[FETCH] - Fetching {entity_name} from {url} ({method})")
            
            try:
                # Prepare headers
                headers = resolve_headers(source_config.get("headers", []))

                for key, value in source_config.get("headers", []):
                    if key == "__queryparam__":
                        separator = "&" if "?" in url else "?"
                        url = f"{url}{separator}{value}"
                
                # Make request
                response = await http_client.request(method, url, headers=headers)
                
                if response.status_code >= 400:
                    logger.error(f"[FETCH] - Failed to fetch {entity_name}: HTTP {response.status_code}")
                    raise HTTPException(
                        status_code=502,
                        detail=f"External source {entity_name} returned {response.status_code}"
                    )
                
                raw_payload = response.json()
                logger.debug(f"[FETCH] - {entity_name} payload type: {type(raw_payload)}")
                
                # Shape the data by evaluating attribute expressions
                shaped_data: Dict[str, Any] = {}
                evaluation_ctx = {source_alias: raw_payload}
                
                for attr_config in source_config.get("attrs", []):
                    attr_name = attr_config["name"]
                    attr_expr = attr_config["expr"]
                    
                    compiled_expr = compile_safe(attr_expr)
                    shaped_data[attr_name] = eval(compiled_expr, safe_globals, evaluation_ctx)
                
                # Default to raw payload if no attributes specified
                if not shaped_data:
                    shaped_data = {"raw": raw_payload}
                
                # Store both shaped data (under entity name) and raw payload (under alias)
                context[entity_name] = shaped_data
                context[source_alias] = raw_payload
                
                logger.info(f"[CONTEXT] - Stored {entity_name} and raw {source_alias}")
                
            except HTTPException:
                raise
            except Exception as fetch_error:
                logger.error(f"[FETCH] - Unexpected error fetching {entity_name}: {fetch_error}", exc_info=True)
                raise HTTPException(
                    status_code=502,
                    detail=f"Failed to fetch external source: {entity_name}"
                )

        # ----------------------------------------------------------------
        # STEP 3: Fetch internal computed dependencies
        # ----------------------------------------------------------------
        for dependency in _INTERNAL_DEPENDENCIES:
            entity_name = dependency["name"]
            endpoint_path = dependency["endpoint"]

            logger.info(f"[DEPENDENCY] - Fetching computed parent {entity_name} from {endpoint_path}")

            try:
                response = await http_client.get(f"http://{{ server.host }}:{{ server.port }}{endpoint_path}")

                if response.status_code >= 400:
                    raise HTTPException(
                        status_code=502,
                        detail=f"Internal dependency {entity_name} returned {response.status_code}"
                    )

                payload = response.json()

                # Unwrap { "EntityName": <data> } envelope if present
                if isinstance(payload, dict) and entity_name in payload and len(payload) == 1:
                    context[entity_name] = payload[entity_name]
                else:
                    context[entity_name] = payload

                logger.info(f"[CONTEXT] - Stored computed parent {entity_name} (type={type(context[entity_name]).__name__})")

            except HTTPException:
                raise
            except Exception as dep_error:
                logger.error(f"[DEPENDENCY] - Unexpected error fetching {entity_name}: {dep_error}", exc_info=True)
                raise HTTPException(status_code=502, detail=f"Failed to fetch internal dependency: {entity_name}")

        # ----------------------------------------------------------------
        # STEP 4: Execute transformation chain
        # ----------------------------------------------------------------
        logger.debug("[CONTEXT] - Current context before transformation chain:")
        try:
            preview = json.dumps(context, indent=2)[:800]
            logger.debug(preview + ("..." if len(preview) == 800 else ""))
        except Exception as e:
            logger.debug(f"[CONTEXT] - Could not serialize context: {e}")

        logger.info(f"[TRANSFORM] - Executing chain with {len(_TRANSFORMATION_CHAIN)} step(s)")
        
        for step_index, transform_step in enumerate(_TRANSFORMATION_CHAIN, 1):
            entity_name = transform_step["name"]
            logger.debug(f"[TRANSFORM] - Step {step_index}/{len(_TRANSFORMATION_CHAIN)}: {entity_name}")
            
            shaped_data = {}
            evaluation_ctx = {**safe_globals, "ctx": context}

                   
            for attr_config in transform_step.get("attrs", []):
                attr_name = attr_config["name"]
                attr_expr = attr_config["expr"]
                
                try:
                    compiled_expr = compile_safe(attr_expr)
                    shaped_data[attr_name] = eval(compiled_expr, evaluation_ctx, {})
                    logger.debug(f"[TRANSFORM] - {entity_name}.{attr_name} computed")
                except HTTPException:
                    raise 
                except Exception as compute_error:
                    logger.error(f"[TRANSFORM] - Error computing {entity_name}.{attr_name}: {compute_error}", exc_info=True)
                    raise HTTPException(
                        status_code=500,
                        detail=f"Failed to compute {entity_name}.{attr_name}"
                    )
            
            context[entity_name] = shaped_data
            logger.debug(f"[CONTEXT] - Stored transformation result: {entity_name}")

            # --- Run validations for this entity (after compute) ---
            if transform_step.get("validations"):
                evaluation_ctx = {"ctx": context, **context}
                try:
                    for v in transform_step["validations"]:
                        eval(compile_safe(v["pyexpr"]), safe_globals, evaluation_ctx)
                        logger.debug(f"[VALIDATION] - {entity_name} validation passed")
                except HTTPException as http_e:
                    logger.warning(f"[VALIDATION] - {entity_name} failed: {http_e.detail}")
                    raise  # <-- re-raise unchanged, preserves message + status
                except Exception as e:
                    logger.error(
                        f"[VALIDATION] - {entity_name} crashed during validation: {e}",
                        exc_info=True,
                    )
                    raise HTTPException(status_code=400, detail={"error": str(e)})

        # ----------------------------------------------------------------
        # STEP 5: Extract final payload (terminal entity)
        # ----------------------------------------------------------------
        terminal_entity_name = "{{ terminal.name }}"
        final_payload = context.get(terminal_entity_name, {})

        logger.info(f"[PAYLOAD] - Final payload from {terminal_entity_name}")
        try:
            preview = json.dumps(final_payload, indent=2)[:800]
            logger.debug(preview + ("..." if len(preview) == 800 else ""))
        except Exception as e:
            logger.debug(f"[PAYLOAD] - Could not serialize final payload: {e}")
        
        logger.info(f"[PAYLOAD] - Final payload from {terminal_entity_name}: {list(final_payload.keys())}")

        {% if target %}
        # ----------------------------------------------------------------
        # STEP 6: Forward to external target
        # ----------------------------------------------------------------
        target_url = _EXTERNAL_TARGET["url"]
        target_url = interpolate_url(target_url, context)
        target_method = _EXTERNAL_TARGET["method"]
        target_name = _EXTERNAL_TARGET["name"]
        
        logger.info(f"[FORWARD] - Sending to {target_name} ({target_method} {target_url})")
        
        try:
            # Prepare headers
            target_headers = resolve_headers(_EXTERNAL_TARGET.get("headers", []))
            
            # Handle API key query param injection
            for key, value in _EXTERNAL_TARGET.get("headers", []):
                if key == "__queryparam__":
                    separator = "&" if "?" in target_url else "?"
                    target_url = f"{target_url}{separator}{value}"
            
            # Prepare request kwargs
            request_kwargs = {"headers": target_headers}
            
            # Don't send body for DELETE with empty payload
            if not (target_method == "DELETE" and not final_payload):
                request_kwargs["json"] = final_payload
            
            target_response = await http_client.request(target_method, target_url, **request_kwargs)
            
            if target_response.status_code >= 400:
                logger.error(f"[FORWARD] - Target returned error: HTTP {target_response.status_code}")
                try:
                    error_detail = target_response.json()
                except Exception:
                    error_detail = {"message": target_response.text}
                raise HTTPException(status_code=target_response.status_code, detail=error_detail)
            
            # Parse response
            try:
                target_data = target_response.json()
            except Exception:
                target_data = {"ok": True}
            
            logger.info(f"[SUCCESS] - Forwarded to {target_name} successfully")
            
            return {
                "forwarded_to": target_url,
                "method": target_method,
                "payload": final_payload,
                "response": target_data
            }
            
        except HTTPException:
            raise
        except Exception as forward_error:
            logger.error(f"[FORWARD] - Unexpected error forwarding to {target_name}: {forward_error}", exc_info=True)
            raise HTTPException(
                status_code=502,
                detail=f"Failed to forward to external target: {target_name}"
            )
        {% else %}
        # ----------------------------------------------------------------
        # STEP 6: Return final payload (no external target)
        # ----------------------------------------------------------------
        logger.info(f"[SUCCESS] - Mutation {{ entity.name }} completed (internal)")
        return final_payload
        {% endif %}

    except HTTPException:
        raise
    except Exception as unexpected_error:
        logger.exception(f"[ERROR] - Unexpected error in mutation {{ entity.name }}")
        raise HTTPException(status_code=500, detail="Internal server error")
