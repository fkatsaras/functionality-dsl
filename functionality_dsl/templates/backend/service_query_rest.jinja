# ========================================================================
# AUTO-GENERATED QUERY SERVICE
# ========================================================================

import json
import logging
from typing import Any, Dict

from fastapi import HTTPException

from app.core.http import get_http_client
from app.core.runtime.safe_eval import compile_safe, compile_safe_exec, safe_globals
from app.core.utils import resolve_headers, interpolate_url, seed_context_with_path_params


logger = logging.getLogger("fdsl.service.{{ endpoint.name }}")


# ============================================================================
#                          CONFIGURATION
# ============================================================================

_EXTERNAL_REST_SOURCES = [
{%- for source in rest_inputs %}
    {
        "entity": "{{ source.entity }}",
        "alias": "{{ source.alias }}",
        "url": "{{ source.url }}",
        "headers": {{ source.headers }},
        "method": "{{ source.method }}",
        "attrs": [
        {%- for attr in source.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ],
        "path_param_exprs": {{ source.path_param_exprs | tojson }},
        "query_param_exprs": {{ source.query_param_exprs | tojson }},
    },
{%- endfor %}
]

_INTERNAL_DEPENDENCIES = [
{%- for dep in computed_parents | default([], true) %}
    {"name": "{{ dep.name }}", "endpoint": "{{ dep.endpoint }}/"},
{%- endfor %}
]

# Response configurations with computation chains and conditions
_RESPONSE_CHAINS = [
{%- for response in response_chains %}
    {
        "status_code": {{ response.status_code }},
        "entity_name": "{{ response.entity.name }}",
        "response_type": "{{ response.response_type }}",
        "condition": {{ response.compiled_condition | tojson if response.compiled_condition else "None" }},
        "chain": [
        {%- for step in response.compiled_chain %}
            {
                "name": "{{ step.name }}",
                "attrs": [
                {%- for attr in step.attrs %}
                    {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
                {%- endfor %}
                ],
            },
        {%- endfor %}
        ],
    },
{%- endfor %}
]


# ============================================================================
#                          SERVICE FUNCTIONS
# ============================================================================

async def fetch_external_sources(context: Dict[str, Any]) -> None:
    """Fetch data from external REST sources and populate context."""
    http_client = get_http_client()

    for source_config in _EXTERNAL_REST_SOURCES:
        entity_name = source_config["entity"]
        source_alias = source_config["alias"]
        base_url = source_config["url"]
        method = source_config["method"]

        # Evaluate path parameter expressions
        path_params = {}
        for param_name, param_expr in source_config.get("path_param_exprs", {}).items():
            try:
                compiled_expr = compile_safe(param_expr)
                eval_globals = {**safe_globals, **context}
                param_value = eval(compiled_expr, eval_globals, {})
                path_params[param_name] = str(param_value)
                logger.debug(f"[PARAM] - {source_alias}.{param_name} = {param_value}")
            except Exception as e:
                logger.error(f"[PARAM] - Error evaluating path param {param_name}: {e}")
                raise HTTPException(status_code=500, detail=f"Failed to evaluate path parameter {param_name}")

        # Evaluate query parameter expressions
        query_params = {}
        for param_name, param_expr in source_config.get("query_param_exprs", {}).items():
            try:
                compiled_expr = compile_safe(param_expr)
                eval_globals = {**safe_globals, **context}
                param_value = eval(compiled_expr, eval_globals, {})
                if param_value is not None:  # Skip None values
                    query_params[param_name] = param_value
                logger.debug(f"[QUERY] - {source_alias}.{param_name} = {param_value}")
            except Exception as e:
                logger.error(f"[QUERY] - Error evaluating query param {param_name}: {e}")
                raise HTTPException(status_code=500, detail=f"Failed to evaluate query parameter {param_name}")

        # Build URL with path parameters
        url = base_url
        for param_name, param_value in path_params.items():
            url = url.replace("{" + param_name + "}", param_value)

        # Add query parameters
        if query_params:
            from urllib.parse import urlencode
            query_string = urlencode(query_params)
            separator = "&" if "?" in url else "?"
            url = f"{url}{separator}{query_string}"

        logger.info(f"[FETCH] - Fetching {entity_name} from {url} ({method})")

        try:
            headers = resolve_headers(source_config.get("headers", []))

            # Inject API key query params if necessary
            for key, value in source_config.get("headers", []):
                if key == "__queryparam__":
                    separator = "&" if "?" in url else "?"
                    url = f"{url}{separator}{value}"

            response = await http_client.request(method, url, headers=headers)

            if response.status_code >= 400:
                logger.error(f"[FETCH] - Failed to fetch {entity_name}: HTTP {response.status_code}")
                raise HTTPException(
                    status_code=502,
                    detail=f"External source {entity_name} returned {response.status_code}"
                )

            raw_payload = response.json()
            logger.debug(f"[FETCH] - {entity_name} payload type: {type(raw_payload)}")

            # Store raw payload by alias (merge with path params if they exist)
            has_path_params = source_alias in context and isinstance(context[source_alias], dict) and context[source_alias]

            if has_path_params:
                if isinstance(raw_payload, dict):
                    context[source_alias].update(raw_payload)
                else:
                    context[source_alias]["_response"] = raw_payload
            else:
                context[source_alias] = raw_payload

            # Shape the data by evaluating attribute expressions
            shaped_data = _shape_entity_data(source_config, context, entity_name)

            # Store shaped entity in context
            context[entity_name] = shaped_data
            logger.info(f"[CONTEXT] - Stored {entity_name} with keys: {list(shaped_data.keys())}")

        except HTTPException:
            raise
        except Exception as fetch_error:
            logger.error(f"[FETCH] - Unexpected error fetching {entity_name}: {fetch_error}", exc_info=True)
            raise HTTPException(
                status_code=502,
                detail=f"Failed to fetch external source: {entity_name}"
            )


async def fetch_internal_dependencies(context: Dict[str, Any]) -> None:
    """Fetch data from internal computed dependencies and populate context."""
    http_client = get_http_client()

    for dependency in _INTERNAL_DEPENDENCIES:
        entity_name = dependency["name"]
        endpoint_path = dependency["endpoint"]

        logger.info(f"[DEPENDENCY] - Fetching computed parent {entity_name} from {endpoint_path}")

        try:
            response = await http_client.get(f"http://{{ server.host }}:{{ server.port }}{endpoint_path}")

            if response.status_code >= 400:
                logger.error(f"[DEPENDENCY] - Failed to fetch {entity_name}: HTTP {response.status_code}")
                raise HTTPException(
                    status_code=502,
                    detail=f"Internal dependency {entity_name} returned {response.status_code}"
                )

            payload = response.json()

            # Unwrap single-key envelope { "<EntityName>": <data> } if present
            if isinstance(payload, dict) and entity_name in payload and len(payload) == 1:
                context[entity_name] = payload[entity_name]
            else:
                context[entity_name] = payload

            logger.info(f"[CONTEXT] - Stored computed parent {entity_name}")

        except HTTPException:
            raise
        except Exception as dep_error:
            logger.error(f"[DEPENDENCY] - Unexpected error fetching {entity_name}: {dep_error}", exc_info=True)
            raise HTTPException(
                status_code=502,
                detail=f"Failed to fetch internal dependency: {entity_name}"
            )


def compute_all_response_entities(context: Dict[str, Any]) -> None:
    """Execute computation chains for all possible response entities."""
    logger.info(f"[COMPUTE] - Computing {len(_RESPONSE_CHAINS)} possible response(s)")

    for response_config in _RESPONSE_CHAINS:
        chain = response_config["chain"]
        entity_name = response_config["entity_name"]

        logger.debug(f"[COMPUTE] - Processing response entity: {entity_name} (status: {response_config['status_code']})")

        for step_index, compute_step in enumerate(chain, 1):
            step_entity_name = compute_step["name"]
            logger.debug(f"[COMPUTE] - Step {step_index}/{len(chain)}: {step_entity_name}")

            shaped_data = _shape_entity_data(compute_step, context, step_entity_name)
            context[step_entity_name] = shaped_data
            logger.debug(f"[CONTEXT] - Stored computation result: {step_entity_name}")


def _shape_entity_data(config: Dict[str, Any], context: Dict[str, Any], entity_name: str) -> Dict[str, Any]:
    """Shape entity data by evaluating attribute expressions."""
    shaped_data: Dict[str, Any] = {}

    for attr_config in config.get("attrs", []):
        attr_name = attr_config["name"]
        attr_expr = attr_config["expr"]

        try:
            compiled_expr = compile_safe(attr_expr)
            eval_globals = {**safe_globals, **context}
            shaped_data[attr_name] = eval(compiled_expr, eval_globals, {})
            logger.debug(f"[SHAPE] - {entity_name}.{attr_name} computed successfully")
        except HTTPException:
            raise
        except Exception as eval_error:
            logger.error(f"[SHAPE] - Error computing {entity_name}.{attr_name}: {eval_error}", exc_info=True)
            raise HTTPException(
                status_code=500,
                detail=f"Failed to compute {entity_name}.{attr_name}"
            )

    # Default to raw payload if no attributes specified
    if not shaped_data and config.get("alias"):
        shaped_data = {"raw": context.get(config["alias"], {})}

    return shaped_data


async def execute_query(path_params: Dict[str, str], query_params: Dict[str, Any] = None, headers: Dict[str, str] = None) -> tuple[Dict[str, Any], int]:
    """
    Main service function to execute the complete query flow.

    Returns tuple of (response_data, status_code).
    """
    context: Dict[str, Any] = {}

    # Create endpoint parameter object for expressions (e.g., GetUserOrders.userId)
    endpoint_params = {}
    if path_params:
        endpoint_params.update(path_params)
    if query_params:
        endpoint_params.update(query_params)
    if headers:
        endpoint_params.update(headers)

    # Add endpoint parameter object to context
    context["{{ endpoint.name }}"] = endpoint_params
    logger.debug(f"[CONTEXT] - Created endpoint parameter object {{ endpoint.name }} with keys: {list(endpoint_params.keys())}")

    # Execute the query pipeline
    await fetch_external_sources(context)
    await fetch_internal_dependencies(context)

    # Evaluate conditions and select appropriate response (lazy evaluation)
    # Strategy: Evaluate conditional responses first, then fall back to default
    logger.info(f"[RESPONSE_SELECTION] - Evaluating {len(_RESPONSE_CHAINS)} response condition(s)")

    # Separate conditional responses from default
    conditional_responses = []
    default_response = None

    for response_config in _RESPONSE_CHAINS:
        if response_config["condition"]:
            conditional_responses.append(response_config)
        else:
            default_response = response_config

    # First, try conditional responses
    for response_config in conditional_responses:
        entity_name = response_config["entity_name"]
        status_code = response_config["status_code"]
        condition = response_config["condition"]
        response_type = response_config["response_type"]
        chain = response_config["chain"]

        # Evaluate condition
        try:
            compiled_condition = compile_safe(condition)
            eval_globals = {**safe_globals, **context}
            condition_met = eval(compiled_condition, eval_globals, {})
            logger.debug(f"[CONDITION] - {entity_name} (status {status_code}): condition = {condition_met}")
        except Exception as e:
            logger.error(f"[CONDITION] - Error evaluating condition for {entity_name}: {e}", exc_info=True)
            condition_met = False

        if condition_met:
            # Condition matched - compute and return this response
            logger.info(f"[RESPONSE_SELECTION] - Selected conditional response: {entity_name} (status {status_code})")
            logger.debug(f"[COMPUTE] - Computing response entity: {entity_name} ({len(chain)} step(s))")

            for step_index, compute_step in enumerate(chain, 1):
                step_entity_name = compute_step["name"]
                logger.debug(f"[COMPUTE] - Step {step_index}/{len(chain)}: {step_entity_name}")

                shaped_data = _shape_entity_data(compute_step, context, step_entity_name)
                context[step_entity_name] = shaped_data
                logger.debug(f"[CONTEXT] - Stored computation result: {step_entity_name}")

            # Get the computed entity
            final_attributes = context.get(entity_name, {})
            logger.info(f"[SUCCESS] - Returning {entity_name} with status {status_code}")
            logger.debug(f"[RESULT] - Attributes: {list(final_attributes.keys())}")

            # Unwrap response based on type
            if response_type in ('string', 'number', 'integer', 'boolean', 'array'):
                if final_attributes:
                    attribute_values = list(final_attributes.values())
                    if attribute_values:
                        unwrapped = attribute_values[0]
                        logger.debug(f"[UNWRAP] - Unwrapped {response_type} response")
                        return unwrapped, status_code
                logger.warning(f"[UNWRAP] - No attributes found for {response_type} response, returning empty")
                return ([] if response_type == "array" else None), status_code
            else:
                return final_attributes, status_code

    # No conditional matched - use default response (guaranteed to exist by validator)
    if default_response:
        entity_name = default_response["entity_name"]
        status_code = default_response["status_code"]
        response_type = default_response["response_type"]
        chain = default_response["chain"]

        logger.info(f"[RESPONSE_SELECTION] - Using default response: {entity_name} (status {status_code})")
        logger.debug(f"[COMPUTE] - Computing response entity: {entity_name} ({len(chain)} step(s))")

        for step_index, compute_step in enumerate(chain, 1):
            step_entity_name = compute_step["name"]
            logger.debug(f"[COMPUTE] - Step {step_index}/{len(chain)}: {step_entity_name}")

            shaped_data = _shape_entity_data(compute_step, context, step_entity_name)
            context[step_entity_name] = shaped_data
            logger.debug(f"[CONTEXT] - Stored computation result: {step_entity_name}")

        # Get the computed entity
        final_attributes = context.get(entity_name, {})
        logger.info(f"[SUCCESS] - Returning {entity_name} with status {status_code}")
        logger.debug(f"[RESULT] - Attributes: {list(final_attributes.keys())}")

        # Unwrap response based on type
        if response_type in ('string', 'number', 'integer', 'boolean', 'array'):
            if final_attributes:
                attribute_values = list(final_attributes.values())
                if attribute_values:
                    unwrapped = attribute_values[0]
                    logger.debug(f"[UNWRAP] - Unwrapped {response_type} response")
                    return unwrapped, status_code
            logger.warning(f"[UNWRAP] - No attributes found for {response_type} response, returning empty")
            return ([] if response_type == "array" else None), status_code
        else:
            return final_attributes, status_code

    # This should never happen due to validation
    logger.error(f"[RESPONSE_SELECTION] - CRITICAL: No default response found!")
    raise HTTPException(status_code=500, detail="Internal error: no default response")
