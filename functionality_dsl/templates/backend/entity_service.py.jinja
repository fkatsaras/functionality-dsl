# ========================================================================
# AUTO-GENERATED ENTITY SERVICE: {{ entity_name }}
# Generated from entity-centric exposure configuration
# ========================================================================

import logging
from typing import Optional, List

from app.domain.models import {{ entity_name }}
{% if source_name and not has_multiple_parent_sources %}
from app.sources.{{ source_name | lower }}_source import {{ source_name }}Source
{% endif %}
{% if has_multiple_parent_sources %}
{%- for ps in parent_sources %}
from app.sources.{{ ps.source_name | lower }}_source import {{ ps.source_class }}
{%- endfor %}
{% endif %}
{% if has_parent_services %}
{%- for ps in parent_services %}
from app.services.{{ ps.name | lower }}_service import {{ ps.service_class }}
{%- endfor %}
{% endif %}
{% if has_computed_attrs %}
from app.core.service_helpers import transform_entity_data
from app.core.runtime.safe_eval import compile_safe, safe_globals
{% endif %}


logger = logging.getLogger("fdsl.service.{{ entity_name }}")


class {{ entity_name }}Service:
    """Service layer for {{ entity_name }} CRUD operations"""

    def __init__(self):
        {% if has_parent_services %}
        # Initialize parent entity services for composition
        {%- for ps in parent_services %}
        self.{{ ps.name | lower }}_service = {{ ps.service_class }}()
        {%- endfor %}
        {% endif %}
        {% if has_multiple_parent_sources %}
        # Initialize multiple parent sources
        {%- for ps in parent_sources %}
        self.{{ ps.source_name | lower }}_source = {{ ps.source_class }}()
        {%- endfor %}
        {% elif source_name %}
        self.source = {{ source_name }}Source()
        {% endif %}
        {% if not has_parent_services and not has_multiple_parent_sources and not source_name %}
        pass
        {% endif %}

{% if has_computed_attrs %}
    def _transform_entity(self, {% if has_parent_services or has_multiple_parent_sources or has_multiple_ws_sources %}parent_data: dict{% else %}raw_data: dict{% endif %}) -> dict:
        """Transform {% if has_parent_services or has_multiple_parent_sources or has_multiple_ws_sources %}parent entity data{% else %}raw source data{% endif %} to {{ entity_name }} using computed attributes."""
        context = {}

        # Add parent entity data to context
        {% if has_parent_services %}
        # Parent data comes from entity services (Pydantic models)
        {% for parent in parents %}
        if "{{ parent }}" in parent_data:
            context["{{ parent }}"] = parent_data["{{ parent }}"].model_dump()
        {% endfor %}
        {% elif has_multiple_parent_sources or has_multiple_ws_sources %}
        # Parent data comes from multiple sources (raw dicts)
        {% for parent in parents %}
        if "{{ parent }}" in parent_data:
            context["{{ parent }}"] = parent_data["{{ parent }}"]
        {% endfor %}
        {% else %}
        # Parent data comes from single raw source
        {% for parent in parents %}
        context["{{ parent }}"] = raw_data
        {% endfor %}
        {% endif %}

        # Transform entity data
        transformed = transform_entity_data(
            entity_name="{{ entity_name }}",
            attributes=[
                {% for attr in computed_attrs %}
                {"name": "{{ attr.name }}", "expr": """{{ attr.expr }}"""},
                {% endfor %}
            ],
            context=context,
            safe_globals=safe_globals,
            compile_safe_fn=compile_safe,
            logger=logger
        )

        return transformed

{% endif %}
{% for op in operations %}
    {%- if op.operation == "list" %}
    async def list_{{ entity_name | lower }}(self) -> List[{{ entity_name }}]:
        """List all {{ entity_name }} instances"""
        logger.debug("Listing {{ entity_name }} instances")

        {% if has_multiple_parent_sources %}
        # Fetch from first parent source (list operation)
        # Note: For multi-parent entities, list comes from first source
        # Then we fetch other parent data for each item using the appropriate ID field
        {%- set first_source = parent_sources[0] %}
        items_raw = await self.{{ first_source.source_name | lower }}_source.list()

        # For each item, fetch data from all parent sources
        result = []
        for item in items_raw:
            parent_data = {}
            {%- for ps in parent_sources %}
            # Fetch {{ ps.entity_name }} using {{ ps.id_field }} from the item
            parent_data["{{ ps.entity_name }}"] = await self.{{ ps.source_name | lower }}_source.read(item.get("{{ ps.id_field }}"))
            {%- endfor %}

            {% if has_computed_attrs %}
            transformed = self._transform_entity(parent_data)
            result.append({{ entity_name }}(**transformed))
            {% else %}
            # Merge all parent data
            merged = {}
            for data in parent_data.values():
                if data:
                    merged.update(data)
            result.append({{ entity_name }}(**merged))
            {% endif %}

        return result
        {% else %}
        # Fetch from source
        raw_data = await self.source.list()

        {% if has_computed_attrs %}
        # Transform each item
        transformed_items = [self._transform_entity(item) for item in raw_data]
        return [{{ entity_name }}(**item) for item in transformed_items]
        {% else %}
        return [{{ entity_name }}(**item) for item in raw_data]
        {% endif %}
        {% endif %}

    {%- elif op.operation == "read" %}
    {%- if op.is_item_op %}
    async def get_{{ entity_name | lower }}(self, {{ id_field }}: str) -> Optional[{{ entity_name }}]:
        """Get a single {{ entity_name }} by ID"""
        logger.debug(f"Getting {{ entity_name }}: {{'{'}}{{ id_field }}{{'}'}}")

        {% if has_parent_services %}
        # Fetch parent entity data via services (composition pattern)
        parent_data = {}
        {%- for ps in parent_services %}
        {%- if loop.first %}
        # First parent: fetch using the endpoint's ID parameter
        parent_data["{{ ps.name }}"] = await self.{{ ps.name | lower }}_service.{{ ps.method }}({{ id_field }})
        {%- else %}
        # Subsequent parent: fetch using ID field from first parent
        {%- set first_parent = parent_services[0] %}
        parent_data["{{ ps.name }}"] = await self.{{ ps.name | lower }}_service.{{ ps.method }}(parent_data["{{ first_parent.name }}"].{{ ps.id_field }})
        {%- endif %}
        {%- endfor %}
        {% elif has_multiple_parent_sources %}
        # Fetch from multiple parent sources
        # First, fetch the primary parent (first in list)
        parent_data = {}
        {%- set first_source = parent_sources[0] %}
        first_parent = await self.{{ first_source.source_name | lower }}_source.read({{ id_field }})
        if not first_parent:
            return None
        parent_data["{{ first_source.entity_name }}"] = first_parent

        # Then fetch other parents using the appropriate ID fields
        {%- for ps in parent_sources[1:] %}
        parent_data["{{ ps.entity_name }}"] = await self.{{ ps.source_name | lower }}_source.read(first_parent.get("{{ ps.id_field }}"))
        {%- endfor %}
        if not all(parent_data.values()):
            return None
        {% else %}
        # Fetch from source
        raw_data = await self.source.read({{ id_field }})

        if not raw_data:
            return None
        {% endif %}

        {% if has_computed_attrs %}
        # Transform entity
        {% if has_parent_services or has_multiple_parent_sources %}
        transformed = self._transform_entity(parent_data)
        {% else %}
        transformed = self._transform_entity(raw_data)
        {% endif %}
        return {{ entity_name }}(**transformed)
        {% else %}
        return {{ entity_name }}(**raw_data)
        {% endif %}
    {%- else %}
    async def get_{{ entity_name | lower }}(self) -> {{ entity_name }}:
        """Get the singleton {{ entity_name }} instance"""
        logger.debug("Getting {{ entity_name }} (singleton)")

        {% if has_parent_services %}
        # Fetch parent entity data via services (composition pattern)
        parent_data = {}
        {%- for ps in parent_services %}
        parent_data["{{ ps.name }}"] = await self.{{ ps.name | lower }}_service.{{ ps.method }}()
        {%- endfor %}
        {% elif has_multiple_parent_sources %}
        # Fetch from multiple parent sources
        parent_data = {}
        {%- for ps in parent_sources %}
        parent_data["{{ ps.entity_name }}"] = await self.{{ ps.source_name | lower }}_source.read()
        {%- endfor %}
        {% else %}
        # Fetch from source
        raw_data = await self.source.read()
        {% endif %}

        {% if has_computed_attrs %}
        # Transform entity
        {% if has_parent_services or has_multiple_parent_sources %}
        transformed = self._transform_entity(parent_data)
        {% else %}
        transformed = self._transform_entity(raw_data)
        {% endif %}
        return {{ entity_name }}(**transformed)
        {% else %}
        return {{ entity_name }}(**raw_data)
        {% endif %}
    {%- endif %}

    {%- elif op.operation == "create" %}
    async def create_{{ entity_name | lower }}(self, data) -> {{ entity_name }}:
        """Create a new {{ entity_name }}"""
        logger.debug(f"Creating {{ entity_name }}: {data}")

        # Call source create operation
        created = await self.source.create(data.dict())

        {% if has_computed_attrs %}
        # Transform created entity
        transformed = self._transform_entity(created)
        return {{ entity_name }}(**transformed)
        {% else %}
        return {{ entity_name }}(**created)
        {% endif %}

    {%- elif op.operation == "update" %}
    async def update_{{ entity_name | lower }}(self, {{ id_field }}: str, data) -> Optional[{{ entity_name }}]:
        """Update an existing {{ entity_name }}"""
        logger.debug(f"Updating {{ entity_name }}: {{'{'}}{{ id_field }}{{'}'}}")

        # Call source update operation
        updated = await self.source.update({{ id_field }}, data.dict())

        if not updated:
            return None

        {% if has_computed_attrs %}
        # Transform updated entity
        transformed = self._transform_entity(updated)
        return {{ entity_name }}(**transformed)
        {% else %}
        return {{ entity_name }}(**updated)
        {% endif %}

    {%- elif op.operation == "delete" %}
    async def delete_{{ entity_name | lower }}(self, {{ id_field }}: str) -> None:
        """Delete a {{ entity_name }}"""
        logger.debug(f"Deleting {{ entity_name }}: {{'{'}}{{ id_field }}{{'}'}}")

        # Call source delete operation
        await self.source.delete({{ id_field }})

    {%- endif %}

{% endfor %}
