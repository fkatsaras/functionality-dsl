# ========================================================================
# AUTO-GENERATED REST SERVICE (Flow: {{ flow.type.upper() }})
# ========================================================================

import json
import logging
from typing import Any, Dict, Optional

from fastapi import HTTPException

from app.core.http import get_http_client
from app.core.runtime.safe_eval import compile_safe, compile_safe_exec, safe_globals
from app.core.utils import resolve_headers, interpolate_url, seed_context_with_path_params
from app.core.content_handler import ContentTypeHandler
from app.core.service_helpers import (
    log_incoming_request,
    log_outgoing_response,
    log_outgoing_error,
    log_fetch_request,
    log_fetch_success,
    log_fetch_error,
    log_write_request,
    log_write_success,
    log_write_error,
    transform_entity_data,
    validate_request_body as validate_body_helper,
)


logger = logging.getLogger("fdsl.service.{{ endpoint.name }}")


# ============================================================================
#                          CONFIGURATION
# ============================================================================

{% if flow.has_reads %}
# External REST sources for reading
_EXTERNAL_REST_SOURCES = [
{%- for source in rest_inputs %}
    {
        "entity": "{{ source.entity }}",
        "alias": "{{ source.alias }}",
        "url": "{{ source.url }}",
        "headers": {{ source.headers }},
        "method": "{{ source.method }}",
        "attrs": [
        {%- for attr in source.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ],
        "path_param_exprs": {{ source.path_param_exprs | tojson }},
        "query_param_exprs": {{ source.query_param_exprs | tojson }},
    },
{%- endfor %}
]

_INTERNAL_DEPENDENCIES = [
{%- for dep in computed_parents | default([], true) %}
    {"name": "{{ dep.name }}", "endpoint": "{{ dep.endpoint }}/"},
{%- endfor %}
]
{% endif %}

{% if flow.has_writes %}
# External targets for writing
_WRITE_TARGETS = [
{%- for target in write_targets %}
    {
        "name": "{{ target.name }}",
        "url": "{{ target.url }}",
        "method": "{{ target.method }}",
        "headers": {{ target.headers }},
        "path_param_exprs": {{ target.path_param_exprs | tojson }},
        "query_param_exprs": {{ target.query_param_exprs | tojson }},
    },
{%- endfor %}
]
{% endif %}

{% if compiled_chain %}
# Computation chain for entity transformation
_COMPUTATION_CHAIN = [
{%- for step in compiled_chain %}
    {
        "name": "{{ step.name }}",
        "attrs": [
        {%- for attr in step.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ],
    },
{%- endfor %}
]
{% endif %}

{% if response_chain %}
# Response transformation chain (for mutations that return data)
_RESPONSE_CHAIN = [
{%- for step in response_chain %}
    {
        "name": "{{ step.name }}",
        "attrs": [
        {%- for attr in step.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ],
    },
{%- endfor %}
]
{% endif %}


# ============================================================================
#                          SERVICE FUNCTIONS
# ============================================================================

{% if request_entity %}
def validate_request_body(request_body: Dict[str, Any]) -> Dict[str, Any]:
    """Validate request body against Pydantic schema."""
    from app.domain.models import {{ request_entity.name }}
    return validate_body_helper(request_body, {{ request_entity.name }}, logger)
{% endif %}

{% if flow.has_reads %}
async def fetch_external_sources(context: Dict[str, Any]) -> None:
    """Fetch data from external REST sources and populate context."""
    http_client = get_http_client()

    for source_config in _EXTERNAL_REST_SOURCES:
        entity_name = source_config["entity"]
        source_alias = source_config["alias"]
        base_url = source_config["url"]
        method = source_config["method"]

        # Evaluate path parameter expressions
        path_params = {}
        for param_name, param_expr in source_config.get("path_param_exprs", {}).items():
            try:
                compiled_expr = compile_safe(param_expr)
                eval_globals = {**safe_globals, **context}
                param_value = eval(compiled_expr, eval_globals, {})
                path_params[param_name] = str(param_value)
                logger.debug(f"[PARAM] - {source_alias}.{param_name} = {param_value}")
            except Exception as e:
                logger.error(f"[PARAM] - Error evaluating path param {param_name}: {e}")
                raise HTTPException(status_code=500, detail=f"Failed to evaluate path parameter {param_name}")

        # Evaluate query parameter expressions
        query_params = {}
        for param_name, param_expr in source_config.get("query_param_exprs", {}).items():
            try:
                compiled_expr = compile_safe(param_expr)
                eval_globals = {**safe_globals, **context}
                param_value = eval(compiled_expr, eval_globals, {})
                if param_value is not None:  # Skip None values
                    query_params[param_name] = param_value
                logger.debug(f"[QUERY] - {source_alias}.{param_name} = {param_value}")
            except Exception as e:
                logger.error(f"[QUERY] - Error evaluating query param {param_name}: {e}")
                raise HTTPException(status_code=500, detail=f"Failed to evaluate query parameter {param_name}")

        # Build URL with path parameters
        url = base_url
        for param_name, param_value in path_params.items():
            url = url.replace("{" + param_name + "}", param_value)

        # Add query parameters
        if query_params:
            from urllib.parse import urlencode
            query_string = urlencode(query_params)
            separator = "&" if "?" in url else "?"
            url = f"{url}{separator}{query_string}"

        log_fetch_request(logger, method, url, entity_name)

        try:
            headers = resolve_headers(source_config.get("headers", []))

            # Inject API key query params if necessary
            for key, value in source_config.get("headers", []):
                if key == "__queryparam__":
                    separator = "&" if "?" in url else "?"
                    url = f"{url}{separator}{value}"

            response = await http_client.request(method, url, headers=headers)

            if response.status_code >= 400:
                log_fetch_error(logger, entity_name, response.status_code)
                raise HTTPException(
                    status_code=502,
                    detail=f"External source {entity_name} returned {response.status_code}"
                )

            # Parse response based on Content-Type
            content_type = response.headers.get("content-type", "application/json")
            raw_payload = await ContentTypeHandler.parse_external_response(
                response.content, content_type
            )
            logger.debug(f"[FETCH] - {entity_name} payload type: {type(raw_payload)}, content-type: {content_type}")
            log_fetch_success(logger, entity_name, raw_payload if isinstance(raw_payload, dict) else f"<{type(raw_payload).__name__}>")

            # Store raw payload by alias
            has_path_params = source_alias in context and isinstance(context[source_alias], dict) and context[source_alias]

            if has_path_params:
                if isinstance(raw_payload, dict):
                    context[source_alias].update(raw_payload)
                else:
                    context[source_alias]["_response"] = raw_payload
            else:
                context[source_alias] = raw_payload

            # Transform the data by evaluating attribute expressions
            transformed_data = transform_entity_data(
                entity_name=entity_name,
                attributes=source_config.get("attrs", []),
                context=context,
                safe_globals=safe_globals,
                compile_safe_fn=compile_safe,
                logger=logger
            )

            # Store transformed entity in context
            context[entity_name] = transformed_data
            logger.debug(f"[CONTEXT] - Stored {entity_name} with keys: {list(transformed_data.keys()) if isinstance(transformed_data, dict) else type(transformed_data)}")

        except HTTPException:
            raise
        except Exception as fetch_error:
            logger.error(f"[FETCH] - Unexpected error fetching {entity_name}: {fetch_error}", exc_info=True)
            raise HTTPException(
                status_code=502,
                detail=f"Failed to fetch external source: {entity_name}"
            )


async def fetch_internal_dependencies(context: Dict[str, Any]) -> None:
    """Fetch data from internal computed dependencies and populate context."""
    http_client = get_http_client()

    for dependency in _INTERNAL_DEPENDENCIES:
        entity_name = dependency["name"]
        endpoint_path = dependency["endpoint"]

        logger.info(f"[DEPENDENCY] → GET {endpoint_path}")

        try:
            response = await http_client.get(f"http://{{ server.host }}:{{ server.port }}{endpoint_path}")

            if response.status_code >= 400:
                logger.error(f"[DEPENDENCY] ✗ HTTP {response.status_code} from {entity_name}")
                raise HTTPException(
                    status_code=502,
                    detail=f"Internal dependency {entity_name} returned {response.status_code}"
                )

            payload = response.json()

            # Unwrap single-key envelope if present
            if isinstance(payload, dict) and entity_name in payload and len(payload) == 1:
                context[entity_name] = payload[entity_name]
            else:
                context[entity_name] = payload

            logger.info(f"[DEPENDENCY] ✓ Received {entity_name}")
            logger.debug(f"[CONTEXT] - Stored computed parent {entity_name}")

        except HTTPException:
            raise
        except Exception as dep_error:
            logger.error(f"[DEPENDENCY] - Unexpected error fetching {entity_name}: {dep_error}", exc_info=True)
            raise HTTPException(
                status_code=502,
                detail=f"Failed to fetch internal dependency: {entity_name}"
            )
{% endif %}

{% if compiled_chain %}
def compute_entity_chain(context: Dict[str, Any]) -> None:
    """Execute computation chain to transform data."""
    logger.info(f"[COMPUTE] Computing {len(_COMPUTATION_CHAIN)} transformation(s)")

    for step_index, compute_step in enumerate(_COMPUTATION_CHAIN, 1):
        entity_name = compute_step["name"]
        logger.debug(f"[COMPUTE] - Step {step_index}/{len(_COMPUTATION_CHAIN)}: {entity_name}")

        transformed_data = transform_entity_data(
            entity_name=entity_name,
            attributes=compute_step.get("attrs", []),
            context=context,
            safe_globals=safe_globals,
            compile_safe_fn=compile_safe,
            logger=logger
        )
        context[entity_name] = transformed_data
        logger.debug(f"[CONTEXT] - Stored computation result: {entity_name}")
{% endif %}

{% if response_chain %}
def compute_response_chain(context: Dict[str, Any]) -> None:
    """Execute response transformation chain (for mutations)."""
    logger.info(f"[COMPUTE] Computing response transformation ({len(_RESPONSE_CHAIN)} step(s))")

    for step_index, compute_step in enumerate(_RESPONSE_CHAIN, 1):
        entity_name = compute_step["name"]
        logger.debug(f"[COMPUTE-RESPONSE] - Step {step_index}/{len(_RESPONSE_CHAIN)}: {entity_name}")

        transformed_data = transform_entity_data(
            entity_name=entity_name,
            attributes=compute_step.get("attrs", []),
            context=context,
            safe_globals=safe_globals,
            compile_safe_fn=compile_safe,
            logger=logger
        )
        context[entity_name] = transformed_data
        logger.debug(f"[CONTEXT] - Stored response transformation result: {entity_name}")
{% endif %}


{% if flow.has_writes %}
async def write_to_targets(context: Dict[str, Any], request_body: Dict[str, Any]) -> Dict[str, Any]:
    """
    Write data to external targets.
    Returns the response from the last target (for endpoints that return data after mutation).
    """
    http_client = get_http_client()
    last_response = None

    for target_config in _WRITE_TARGETS:
        target_name = target_config["name"]
        base_url = target_config["url"]
        method = target_config["method"]
        headers = resolve_headers(target_config.get("headers", []))

        # Evaluate path parameter expressions
        path_params = {}
        for param_name, param_expr in target_config.get("path_param_exprs", {}).items():
            try:
                compiled_expr = compile_safe(param_expr)
                eval_globals = {**safe_globals, **context}
                param_value = eval(compiled_expr, eval_globals, {})
                path_params[param_name] = str(param_value)
                logger.debug(f"[PARAM] - {target_name}.{param_name} = {param_value}")
            except Exception as e:
                logger.error(f"[PARAM] - Error evaluating path param {param_name}: {e}")
                raise HTTPException(status_code=500, detail=f"Failed to evaluate path parameter {param_name}")

        # Evaluate query parameter expressions
        query_params = {}
        for param_name, param_expr in target_config.get("query_param_exprs", {}).items():
            try:
                compiled_expr = compile_safe(param_expr)
                eval_globals = {**safe_globals, **context}
                param_value = eval(compiled_expr, eval_globals, {})
                if param_value is not None:  # Skip None values
                    query_params[param_name] = param_value
                logger.debug(f"[QUERY] - {target_name}.{param_name} = {param_value}")
            except Exception as e:
                logger.error(f"[QUERY] - Error evaluating query param {param_name}: {e}")
                raise HTTPException(status_code=500, detail=f"Failed to evaluate query parameter {param_name}")

        # Build URL with path parameters
        url = base_url
        for param_name, param_value in path_params.items():
            url = url.replace("{" + param_name + "}", param_value)

        # Add query parameters
        if query_params:
            from urllib.parse import urlencode
            query_string = urlencode(query_params)
            separator = "&" if "?" in url else "?"
            url = f"{url}{separator}{query_string}"

        {% if request_entity %}
        # Get the transformed entity from context (terminal entity)
        payload = context.get("{{ request_entity.name }}", request_body)
        {% else %}
        # No request entity - send raw request body
        payload = request_body
        {% endif %}

        log_write_request(logger, method, url, payload)

        try:
            # Prepare request with appropriate content type
            request_content_type = headers.get("Content-Type", "application/json")
            request_body, request_headers = ContentTypeHandler.prepare_external_request(
                payload, request_content_type
            )
            headers.update(request_headers)

            response = await http_client.request(method, url, headers=headers, content=request_body)

            if response.status_code >= 400:
                log_write_error(logger, target_name, response.status_code, response.text[:500])
                raise HTTPException(
                    status_code=502,
                    detail=f"External target {target_name} returned {response.status_code}"
                )

            # Parse response based on Content-Type
            response_content_type = response.headers.get("content-type", "application/json")
            try:
                last_response = await ContentTypeHandler.parse_external_response(
                    response.content, response_content_type
                )
                log_write_success(logger, target_name, last_response if isinstance(last_response, dict) else f"<{type(last_response).__name__}>")
            except:
                last_response = {"status": "success"}
                logger.info(f"[WRITE] ✓ Success (no parseable response)")

        except HTTPException:
            raise
        except Exception as write_error:
            logger.error(f"[WRITE] - Unexpected error writing to {target_name}: {write_error}", exc_info=True)
            raise HTTPException(
                status_code=502,
                detail=f"Failed to write to external target: {target_name}"
            )

    return last_response or {}
{% endif %}


async def execute_flow(
    path_params: Dict[str, str] = None,
    query_params: Dict[str, Any] = None,
    headers: Dict[str, str] = None,
    request_body: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Main service function to execute the complete data flow.

    Flow type: {{ flow.type }}
    {% if flow.has_reads %}
    - Reads from {{ rest_inputs | length }} external source(s)
    {% endif %}
    {% if flow.has_writes %}
    - Writes to {{ write_targets | length }} external target(s)
    {% endif %}
    {% if compiled_chain %}
    - Computes {{ compiled_chain | length }} entity transformation(s)
    {% endif %}
    """
    # Log incoming request
    log_incoming_request(logger, path_params, query_params, request_body)

    context: Dict[str, Any] = {}

    # Create endpoint parameter object for expressions (e.g., GetProduct.productId)
    endpoint_params = {}
    if path_params:
        endpoint_params.update(path_params)
    if query_params:
        endpoint_params.update(query_params)
    if headers:
        endpoint_params.update(headers)

    # Add endpoint parameter object to context
    context["{{ endpoint.name }}"] = endpoint_params
    logger.debug(f"[CONTEXT] - Created endpoint parameter object {{ endpoint.name }} with keys: {list(endpoint_params.keys())}")

    {% if request_entity %}
    # Validate and seed context with request body entity
    if request_body is None or (isinstance(request_body, dict) and not request_body):
        logger.error("[VALIDATION] - Request body is required but not provided or empty")
        raise HTTPException(
            status_code=400,
            detail="Request body is required for this endpoint"
        )
    validated_body = validate_request_body(request_body)
    context["{{ request_entity.name }}"] = validated_body
    logger.debug(f"[CONTEXT] - Seeded validated request entity {{ request_entity.name }}")
    {% endif %}

    # ========================================================================
    # EXECUTE FLOW PIPELINE
    # ========================================================================

    {% if flow.type == 'read' %}
    # READ flow: Fetch → Compute → Return
    {% if flow.has_reads %}
    await fetch_external_sources(context)
    await fetch_internal_dependencies(context)
    {% endif %}
    {% if compiled_chain %}
    compute_entity_chain(context)
    {% endif %}

    # READ FLOW ERRORS (after fetch)
    {% if errors %}
    eval_globals = {**safe_globals, **context}
    {% for error in errors %}
    try:
        compiled_condition = compile_safe({{ error.condition | tojson }})
        if eval(compiled_condition, eval_globals, {}):
            error_detail = "{{ error.message }}"
            logger.error("[ERROR] ✗ Error condition triggered: {{ error.condition }}")
            logger.error("[ERROR]   Status: {{ error.status_code }}, Message: {{ error.message }}")
            log_outgoing_error(logger, error_detail)
            raise HTTPException(status_code={{ error.status_code }}, detail=error_detail)
    except HTTPException:
        raise
    except Exception as eval_error:
        logger.error(f"[ERROR] - Failed to evaluate error condition: {eval_error}")
    {% endfor %}
    {% endif %}

    {% elif flow.type == 'write' %}
    # WRITE flow: Compute → Validate → Write → Transform Response → Return
    {% if compiled_chain %}
    compute_entity_chain(context)
    {% endif %}
    {# PRE-WRITE ERROR CHECKS #}
    {% if errors %}
    eval_globals = {**safe_globals, **context}
    {% for error in errors %}
    try:
        compiled_condition = compile_safe({{ error.condition | tojson }})
        if eval(compiled_condition, eval_globals, {}):
            error_detail = "{{ error.message }}"
            logger.error("[ERROR] ✗ Error condition triggered: {{ error.condition }}")
            logger.error("[ERROR]   Status: {{ error.status_code }}, Message: {{ error.message }}")
            log_outgoing_error(logger, error_detail)
            raise HTTPException(status_code={{ error.status_code }}, detail=error_detail)
    except HTTPException:
        raise
    except Exception as eval_error:
        logger.error(f"[ERROR] - Failed to evaluate error condition: {eval_error}")
    {% endfor %}
    {% endif %}

    {% if flow.has_writes %}
    write_response = await write_to_targets(context, request_body or {})

    {% if response_source_entity %}
    context["{{ response_source_entity.name }}"] = write_response
    {% endif %}
    {% endif %}

    {% if response_chain %}
    compute_response_chain(context)
    {% endif %}

    {% elif flow.type == 'read_write' %}
    # READ_WRITE flow: Fetch → Compute → Validate → Write → Transform Response → Return
    {% if flow.has_reads %}
    await fetch_external_sources(context)
    await fetch_internal_dependencies(context)
    {% endif %}

    {% if compiled_chain %}
    compute_entity_chain(context)
    {% endif %}
    {# -------------------------------------------- #}
    {# PRE-WRITE ERROR CHECKS                       #}
    {# -------------------------------------------- #}
    {% if errors %}
    eval_globals = {**safe_globals, **context}
    {% for error in errors %}
    try:
        compiled_condition = compile_safe({{ error.condition | tojson }})
        if eval(compiled_condition, eval_globals, {}):
            error_detail = "{{ error.message }}"
            logger.error("[ERROR] ✗ Error condition triggered: {{ error.condition }}")
            logger.error("[ERROR]   Status: {{ error.status_code }}, Message: {{ error.message }}")
            log_outgoing_error(logger, error_detail)
            raise HTTPException(status_code={{ error.status_code }}, detail=error_detail)
    except HTTPException:
        raise
    except Exception as eval_error:
        logger.error(f"[ERROR] - Failed to evaluate error condition: {eval_error}")
    {% endfor %}
    {% endif %}

    {% if flow.has_writes %}
    write_response = await write_to_targets(context, request_body or {})

    {% if response_source_entity %}
    context["{{ response_source_entity.name }}"] = write_response
    {% endif %}
    {% endif %}

    {% if response_chain %}
    compute_response_chain(context)
    {% endif %}
    {% endif %}

    # ========================================================================
    # EXTRACT AND RETURN RESULT
    # ========================================================================
    {% if response_entity %}
    final_entity_name = "{{ response_entity.name }}"
    {% elif request_entity %}
    final_entity_name = "{{ request_entity.name }}"
    {% else %}
    final_entity_name = "{{ entity.name }}"
    {% endif %}

    final_attributes = context.get(final_entity_name, {})

    logger.debug(f"[RESULT] - Entity: {final_entity_name}, Attributes: {list(final_attributes.keys()) if isinstance(final_attributes, dict) else type(final_attributes)}")

    # Unwrap response based on type
    {% if response_type in ('string', 'number', 'integer', 'boolean', 'array') %}
    # Response type is {{ response_type }} - unwrap the single attribute
    if final_attributes and isinstance(final_attributes, dict):
        attribute_values = list(final_attributes.values())
        if attribute_values:
            unwrapped = attribute_values[0]
            logger.debug(f"[UNWRAP] - Unwrapped {{ response_type }} response")
            log_outgoing_response(logger, unwrapped)
            return unwrapped
    logger.warning(f"[UNWRAP] - No attributes found for {{ response_type }} response, returning empty")
    logger.info("[RESPONSE] → Empty response")
    return [] if "{{ response_type }}" == "array" else None
    {% else %}
    # Response type is object - return full entity attributes
    log_outgoing_response(logger, final_attributes)
    return final_attributes
    {% endif %}
