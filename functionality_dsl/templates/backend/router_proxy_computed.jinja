# Auto-generated entity router for computed entity {{ entity.name }}
import httpx

from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any

from .models import {{ entity.name }}
from functionality_dsl.lib.computed import DSL_FUNCTION_REGISTRY as dsl_funcs

router = APIRouter(prefix="/api/entities/{{ entity.name | lower }}", tags=["{{ entity.name }}"])

# Helpers: fetch a remote list (tries: target.source.url else internal /api/entities/<target>)
async def fetch_list(url: str):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        if response.status_code >= 400:
            raise HTTPException(status_code=response.status_code, detail=response.text)
        return response.json()

# For safety, evaluate with no builtins and only the two names we expect.
SAFE_GLOBALS = {"__builtins__": {} , "dsl_funcs": dsl_funcs}

def eval_py_expr(expr_str: str, ctx: dict):
    """
    expr_str: compiler output like "ctx['z']['moisture_percent']"
              or "dsl_funcs['avg']([ctx['z']['moisture_percent']])"
    ctx:      {'z': {...}} for entity context
    """
    code = compile(expr_str, "<dsl_expr>", "eval")
    return eval(code, SAFE_GLOBALS, {"ctx": ctx})

@router.get("/", response_model=List[{{ entity.name }}])
async def list_{{ entity.name | lower }}():
    # 1) fetch inputs
    {% for inp in inputs %}
    # input '{{ inp.alias }}' -> target entity '{{ inp.target_name }}'
    {% if inp.target_source_url %}
    {{ inp.alias }}_data = await fetch_list("{{ inp.target_source_url }}")
    {% else %}
    # fallback: call internal endpoint (uses server host/port)
    {{ inp.alias }}_data = await fetch_list("http://{{ server_host }}:{{ server_port }}/api/entities/{{ inp.target_name | lower }}")
    {% endif %}
    {% endfor %}

    # collect lists
    lists = {
    {% for inp in inputs %}
        "{{ inp.alias }}": {{ inp.alias }}_data,
    {% endfor %}
    }

    rows = []
    min_len = min((len(lists[k]) for k in lists if isinstance(lists[k], list)), default=0)
    for i in range(min_len):
        ctx = {k: (lists[k][i] if isinstance(lists[k][i], dict) else {}) for k in lists}
        row: Dict[str, Any] = {}
        {% for attr in computed_attrs %}
        try:
            row["{{ attr.name }}"] = _eval_pyexpr({{ attr.pyexpr | tojson }}, ctx)
        except Exception:
            row["{{ attr.name }}"] = None
        {% endfor %}
        rows.append(row)

    return rows
