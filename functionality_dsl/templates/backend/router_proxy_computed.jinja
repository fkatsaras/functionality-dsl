# Auto-generated entity router for computed entity {{ entity.name }}
from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any
import httpx
from .models import {{ entity.name }}

router = APIRouter(prefix="/api/entities/{{ entity.name | lower }}", tags=["{{ entity.name }}"])

# Helpers: fetch a remote list (tries: target.source.url else internal /api/entities/<target>)
async def fetch_list(url: str):
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        if response.status_code >= 400:
            raise HTTPException(status_code=response.status_code, detail=response.text)
        return response.json()

# For safety we evaluate computed expressions with an empty builtin set.
SAFE_GLOBALS = {"__builtins__": None}

@router.get("/", response_model=List[{{ entity.name }}])
async def list_{{ entity.name | lower }}():
    # 1) fetch inputs
    {% for inp in inputs %}
    # input '{{ inp.alias }}' -> target entity '{{ inp.target_name }}'
    {% if inp.target_source_url %}
    {{ inp.alias }}_data = await fetch_list("{{ inp.target_source_url }}")
    {% else %}
    # fallback: call internal endpoint (uses server host/port)
    {{ inp.alias }}_data = await fetch_list("http://{{ server_host }}:{{ server_port }}/api/entities/{{ inp.target_name | lower }}")
    {% endif %}
    {% endfor %}

    # collect lists
    lists = {
    {% for inp in inputs %}
        "{{ inp.alias }}": {{ inp.alias }}_data,
    {% endfor %}
    }

    # alignment strategy: prefer timestamp intersection if all inputs have 'timestamp'
    all_have_ts = all(any('timestamp' in (list(item.keys()) if isinstance(item, dict) else []) for item in lists[k]) for k in lists if lists[k])
    rows = []

    if all_have_ts:
        maps = {k: {item.get('timestamp'): item for item in lists[k] if isinstance(item, dict) and item.get('timestamp') is not None} for k in lists}
        common_ts = set.intersection(*[set(m.keys()) for m in maps.values()]) if maps else set()
        for ts in sorted(common_ts):
            ctx = {k: maps[k][ts] for k in maps}
            row: Dict[str, Any] = {}
            {% for attr in computed_attrs %}
            try:
                row["{{ attr.name }}"] = eval({{ attr.pyexpr | tojson }}, SAFE_GLOBALS, ctx)
            except Exception:
                row["{{ attr.name }}"] = None
            {% endfor %}
            rows.append(row)
    else:
        min_len = min((len(lists[k]) for k in lists if isinstance(lists[k], list)), default=0)
        for i in range(min_len):
            ctx = {k: (lists[k][i] if isinstance(lists[k][i], dict) else {}) for k in lists}
            row: Dict[str, Any] = {}
            {% for attr in computed_attrs %}
            try:
                row["{{ attr.name }}"] = eval({{ attr.pyexpr | tojson }}, SAFE_GLOBALS, ctx)
            except Exception:
                row["{{ attr.name }}"] = None
            {% endfor %}
            rows.append(row)

    return rows
