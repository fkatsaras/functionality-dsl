# ========================================================================
# AUTO-GENERATED WEBSOCKET SERVICE
# ========================================================================

import json
import uuid
import asyncio
import logging
import websockets

from typing import Any, Dict, List, Optional

from fastapi import HTTPException

from app.core.base_service import BaseService
from app.core.runtime.safe_eval import compile_safe, compile_safe_exec, safe_globals
from app.core.content_handler import ContentTypeHandler
from app.core.ws_wrapper import WSMessageWrapper


# ============================================================================
#                          SERVICE CLASS
# ============================================================================

class {{ endpoint.name }}Service(BaseService):
    """
    Generated WebSocket service for {{ endpoint.name }}.

    Manages bidirectional WebSocket communication with external sources and clients.
    {% if connection_mode == 'scoped' %}
    Connection mode: SCOPED - External connections are managed per-client in the router.
    {% else %}
    Connection mode: SHARED - External connections are shared across all clients (managed by service).
    {% endif %}
    """

    def __init__(self):
        """Initialize WebSocket service with configuration and connection state."""
        # Initialize base service (logger, http_client)
        super().__init__("ws.{{ endpoint.name }}")

        {% if connection_mode == 'scoped' %}
        # Scoped connection mode: External connections managed per-client in router
        self._connection_mode = "scoped"
        {% else %}
        # Shared connection mode: External connections managed by service
        self._connection_mode = "shared"
        {% endif %}

        # Configuration
        self._external_targets = [
        {%- for tgt in external_targets %}
            {
                "url": "{{ tgt.url }}",
                "headers": {{ tgt.headers }},
                "subprotocols": {{ (tgt.subprotocols or []) | tojson }},
                "protocol": "{{ tgt.protocol or 'json' }}",
                "message_type": "{{ tgt.message_type or 'object' }}"
            },
        {%- endfor %}
        ]

        self._ws_inputs = [
        {%- for w in ws_inputs %}
            {
                "entity": "{{ w.entity }}",
                "endpoint": "{{ w.endpoint }}",
                "url": "{{ w.url }}",
                "headers": {{ w.headers }},
                "subprotocols": {{ (w.subprotocols or []) | tojson }},
                "protocol": "{{ w.protocol or 'json' }}",
                "content_type": "{{ w.content_type or 'application/json' }}",
                "message_type": "{{ w.message_type or 'object' }}",
                "attrs": {{ w.attrs | tojson }}
            },
        {%- endfor %}
        ]

        self._compiled_chain_inbound = [
        {%- for ent in compiled_chain_inbound %}
          {
            "name": "{{ ent.name }}",
            "attrs": [
            {%- for a in ent.attrs %}
              {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
            {%- endfor %}
            ],
          },
        {%- endfor %}
        ]

        self._compiled_chain_outbound = [
        {%- for ent in compiled_chain_outbound %}
          {
            "name": "{{ ent.name }}",
            "attrs": [
            {%- for a in ent.attrs %}
              {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
            {%- endfor %}
            ],
          },
        {%- endfor %}
        ]

        {% if sync_config_inbound %}
        # Sync buffer configuration
        self._sync_required_sources = {{ sync_config_inbound.required_parents | tojson }}
        self._parent_buffer: Dict[str, Any] = {}
        self._buffer_lock = asyncio.Lock()
        {% endif %}

        # Persistent external connections state
        self._target_connections: List[Optional[Any]] = [None] * len(self._external_targets)
        self._target_reader_started: List[bool] = [False] * len(self._external_targets)
        self._target_lock = asyncio.Lock()

        # Input consumer state
        self._started_inputs = False
        self._inputs_lock = asyncio.Lock()

    # ========================================================================
    # COMPUTATION FUNCTIONS
    # ========================================================================

    def compute_entity_chain(self, payload: Any, sender_id: str, chain: List[Dict], source_name: str, entity_name: str = None, header_params: Dict[str, Any] = None, endpoint_name: str = None) -> tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Compute entity attributes through chain with flat context.
        Returns: (final_result, full_context)

        Args:
            payload: The incoming data
            sender_id: Request ID for logging
            chain: The computation chain
            source_name: Name of the source (endpoint/feed)
            entity_name: Optional entity name for the payload (if different from source_name)
            header_params: Header parameters from WebSocket handshake
            endpoint_name: Name of the endpoint (for header param context)
        """
        self.logger.debug(f"[COMPUTE] - Processing payload from {source_name}")

        # Build initial context with both source_name and entity_name (if provided)
        context = {
            source_name: payload,
            "__sender": sender_id
        }

        # Add endpoint with header parameters to context (for expressions like TestWSHeaders.Authorization)
        # This is separate from the payload to avoid conflicts
        if header_params and endpoint_name:
            context[endpoint_name] = header_params
            self.logger.debug(f"[COMPUTE] - Added endpoint {endpoint_name} with header params: {list(header_params.keys())}")

        # For inbound chains, also add the entity name to context
        # This allows expressions to reference OutgoingWrapper.value instead of ChatDup.value
        if entity_name and entity_name != source_name:
            context[entity_name] = payload
            self.logger.debug(f"[COMPUTE] - Added {entity_name} to context (alias for {source_name})")

        self.logger.info(f"[COMPUTE] - Executing chain with {len(chain)} step(s)")
        for step_index, ent in enumerate(chain, 1):
            step_entity_name = ent["name"]
            self.logger.debug(f"[COMPUTE] - Step {step_index}/{len(chain)}: {step_entity_name}")

            shaped = self.compute_entity_attributes(ent, context, step_entity_name)
            context[step_entity_name] = shaped
            self.logger.debug(f"[COMPUTE] - {step_entity_name} shaped with keys: {list(shaped.keys())}")

        final_entity = chain[-1]["name"] if chain else source_name
        result = context[final_entity] if chain else {source_name: payload}
        self.logger.info(f"[COMPUTE] - Computation complete, final entity: {final_entity}")
        return result, context


    {% if sync_config_inbound %}
    async def compute_with_sync(self, payload: Any, sender_id: str, chain: List[Dict], source_name: str) -> Optional[Dict[str, Any]]:
        """
        Buffer and sync multiple sources, then compute with flat context.
        """
        self.logger.debug(f"[COMPUTE] - Processing payload from {source_name} (sync mode)")

        async with self._buffer_lock:
            self._parent_buffer[source_name] = payload
            self.logger.debug(f"[COMPUTE] - Buffered {source_name}, current sources: {list(self._parent_buffer.keys())}")

            # Check if all required sources are present
            missing = [src for src in self._sync_required_sources if src not in self._parent_buffer]
            if missing:
                self.logger.debug(f"[COMPUTE] - Waiting for sources: {missing}")
                return None

            self.logger.info(f"[COMPUTE] - All required sources present: {self._sync_required_sources}")

            # Build flat context with all source data
            context = {
                "__sender": sender_id,
                **self._parent_buffer
            }

            # Run the compiled chain
            self.logger.info(f"[COMPUTE] - Executing chain with {len(chain)} step(s)")
            for step_index, ent in enumerate(chain, 1):
                entity_name = ent["name"]
                self.logger.debug(f"[COMPUTE] - Step {step_index}/{len(chain)}: {entity_name}")

                shaped = self.compute_entity_attributes(ent, context, entity_name)
                context[entity_name] = shaped
                self.logger.debug(f"[COMPUTE] - {entity_name} shaped with keys: {list(shaped.keys())}")

            final_entity = chain[-1]["name"] if chain else ""
            result = context[final_entity] if chain and final_entity else {}
            self.logger.info(f"[COMPUTE] - Computation complete, final entity: {final_entity}")
            return result
    {% endif %}

    # compute_entity_attributes is inherited from BaseService


    # ========================================================================
    # CONNECTION MANAGEMENT
    # ========================================================================

    async def ensure_target_connection(self, idx: int, inbound_entity_name: str):
        """Ensure connection to external target is established.

        Note: In scoped connection mode, this method is a no-op as connections
        are managed per-client in the router.
        """
        {% if connection_mode == 'scoped' %}
        # Scoped mode: Connections managed per-client in router, not here
        return
        {% else %}
        # Shared mode: Manage shared connection
        if idx >= len(self._external_targets):
            return

        tgt = self._external_targets[idx]
        async with self._target_lock:
            if self._target_connections[idx] is not None:
                try:
                    await self._target_connections[idx].ping()
                    return
                except Exception:
                    self._target_connections[idx] = None
            try:
                self.logger.info(f"[TARGET] - Establishing connection to {tgt['url']}")
                try:
                    self._target_connections[idx] = await websockets.connect(
                        tgt["url"],
                        extra_headers=tgt["headers"] or [],
                        subprotocols=tgt["subprotocols"] or None
                    )
                except TypeError:
                    self._target_connections[idx] = await websockets.connect(
                        tgt["url"],
                        additional_headers=tgt["headers"] or [],
                        subprotocols=tgt["subprotocols"] or None
                    )
                self.logger.info(f"[TARGET] - Successfully connected to {tgt['url']}")

                # Start reader if not already started
                if not self._target_reader_started[idx]:
                    from app.core import wsbus
                    asyncio.create_task(self.start_target_reader(idx, inbound_entity_name, wsbus))
                    self._target_reader_started[idx] = True
            except Exception as ex:
                self.logger.error(f"[TARGET] - Failed to connect to {tgt['url']}: {ex}", exc_info=True)
        {% endif %}


    async def start_target_reader(self, idx: int, inbound_entity_name: str, wsbus):
        """Read messages from external connection and publish RAW data to bus.

        ARCHITECTURAL NOTE: We publish raw/untransformed messages here because the
        outbound chain computation happens per-client in the router's outbound_loop,
        where header_params are available for use in entity transformations.

        Note: In scoped connection mode, this method is not used as readers are
        created per-client in the router.
        """
        {% if connection_mode == 'scoped' %}
        # Scoped mode: Readers managed per-client in router, not here
        return
        {% else %}
        # Shared mode: Manage shared reader
        tgt = self._external_targets[idx]
        self.logger.info(f"[TARGET_READER] - Starting reader for target {idx}: {tgt['url']}")

        inp = next((w for w in self._ws_inputs if w["url"] == tgt["url"]), None)
        if not inp:
            self.logger.warning(f"[TARGET_READER] - No WS input found for target URL: {tgt['url']}")
            return

        # Get outbound entity name and bus (data from external WS flows to client)
        _, outbound_entity_name = self.get_inbound_outbound_entities()
        bus_out = wsbus.get_bus(outbound_entity_name)

        while True:
            conn = self._target_connections[idx]
            if conn is None:
                self.logger.debug(f"[TARGET_READER] - Waiting for connection to {tgt['url']}")
                await asyncio.sleep(1)
                continue
            try:
                self.logger.info(f"[TARGET_READER] - Reading from target {tgt['url']}")
                async for raw in conn:
                    self.logger.debug(f"[WS_MESSAGE] - Received from {tgt['url']}")
                    try:
                        payload = json.loads(raw)
                    except Exception:
                        payload = raw

                    {% if needs_per_client_transform %}
                    # Publish RAW message to bus - transformation happens per-client in router
                    # This allows each client's outbound_loop to apply transformations with their header_params
                    raw_message = {
                        "source": inp["endpoint"],
                        "entity": inp.get("entity"),
                        "payload": payload
                    }
                    await bus_out.publish(raw_message)
                    self.logger.debug(f"[WS_MESSAGE] - Published raw message to outbound bus")
                    {% else %}
                    # Compute transformation once and broadcast to all clients
                    # (No endpoint params used, so same result for all clients)
                    {% if compiled_chain_outbound %}
                    row, _ = self.compute_entity_chain(payload, uuid.uuid4().hex, self._compiled_chain_outbound, inp["endpoint"], inp.get("entity"))
                    if row is not None:
                        await bus_out.publish(row)
                        self.logger.debug(f"[WS_MESSAGE] - Published transformed message to outbound bus")
                    {% else %}
                    # No transformation - direct publish
                    await bus_out.publish(payload)
                    self.logger.debug(f"[WS_MESSAGE] - Published message to outbound bus")
                    {% endif %}
                    {% endif %}
            except Exception as ex:
                self.logger.error(f"[TARGET_READER] - Reader failed for {tgt['url']}: {ex}", exc_info=True)
                self._target_connections[idx] = None
                await asyncio.sleep(2)
        {% endif %}


    async def forward_to_targets(self, row: Dict[str, Any], inbound_entity_name: str):
        """Forward message to all external targets.

        Note: In scoped connection mode, forwarding is handled per-client in the router.
        """
        {% if connection_mode == 'scoped' %}
        # Scoped mode: Forwarding handled per-client in router, not here
        return
        {% else %}
        # Shared mode: Forward to shared connections
        self.logger.info(f"[FORWARD] - Forwarding to {len(self._external_targets)} target(s)")

        for idx, tgt in enumerate(self._external_targets):
            await self.ensure_target_connection(idx, inbound_entity_name)
            conn = self._target_connections[idx]
            if conn:
                try:
                    # Unwrap primitive types before sending to external targets
                    message_type = tgt.get("message_type", "object")
                    message_to_send = WSMessageWrapper.unwrap_if_needed(row, message_type)

                    if tgt["protocol"] == "json":
                        await conn.send(json.dumps(message_to_send))
                    elif tgt["protocol"] == "text":
                        await conn.send(str(message_to_send))
                    else:
                        await conn.send(json.dumps(message_to_send))
                    self.logger.debug(f"[FORWARD] - Successfully sent to {tgt['url']}")
                except Exception as ex:
                    self.logger.error(f"[FORWARD] - Failed to send to {tgt['url']}: {ex}", exc_info=True)
                    self._target_connections[idx] = None
        {% endif %}


    # ========================================================================
    # INPUT CONSUMER
    # ========================================================================

    async def ws_input_consumer(self, inp: dict, bus_in):
        """
        Standalone reader for WS input URL not in _EXTERNAL_TARGETS.

        ARCHITECTURAL NOTE: For outbound flows (external source → client), we publish
        raw messages to allow per-client transformation with header_params.
        For inbound flows (client → external), we compute immediately since there's
        no per-client context needed.
        """
        url = inp["url"]
        entity = inp["entity"]
        headers = inp.get("headers") or []
        subprotocols = inp.get("subprotocols") or None
        protocol = inp.get("protocol") or "json"
        content_type = inp.get("content_type") or "application/json"
        source_name = inp.get("endpoint")

        self.logger.info(f"[WS_INPUT] - Starting consumer for {entity} ({url}) content-type: {content_type}")

        # Determine if this is an outbound flow (needs per-client transformation)
        {% if entity_out and not entity_in %}
        is_outbound_flow = True
        {% else %}
        is_outbound_flow = False
        {% endif %}

        while True:
            try:
                self.logger.info(f"[WS_INPUT] - Connecting to upstream feed: {entity}")
                try:
                    cm = websockets.connect(url, extra_headers=headers, subprotocols=subprotocols)
                except TypeError:
                    cm = websockets.connect(url, additional_headers=headers, subprotocols=subprotocols)

                async with cm as ws_conn:
                    self.logger.info(f"[WS_INPUT] - Connected to upstream feed: {entity}")
                    async for raw in ws_conn:
                        try:
                            # Use ContentTypeHandler to parse WebSocket messages based on content type
                            # For binary content types, preserve the raw bytes
                            is_binary = ContentTypeHandler.is_binary(content_type)

                            if is_binary:
                                # Binary data: keep as bytes, will be base64-encoded when published
                                payload = raw if isinstance(raw, (bytes, bytearray)) else bytes(raw, "utf-8")
                                self.logger.debug(f"[WS_INPUT] - Received binary frame ({len(payload)} bytes)")
                            else:
                                # Text-based content: parse according to content type
                                raw_bytes = raw if isinstance(raw, (bytes, bytearray)) else bytes(raw, "utf-8")
                                payload = await ContentTypeHandler.parse_external_response(raw_bytes, content_type)
                                self.logger.debug(f"[WS_INPUT] - Parsed {content_type} message")
                        except Exception as parse_error:
                            self.logger.warning(f"[WS_INPUT] - Parse error: {parse_error}, using raw payload")
                            payload = raw

                        # Wrap primitive types for internal processing
                        message_type = inp.get("message_type", "object")
                        if WSMessageWrapper.should_wrap(message_type):
                            # Get the wrapper entity's attribute name
                            attr_name = inp["attrs"][0]["name"] if inp.get("attrs") else "value"
                            payload = WSMessageWrapper.wrap(payload, attr_name)
                            self.logger.debug(f"[WS_INPUT] - Wrapped {message_type} message: {payload}")

                        if is_outbound_flow:
                            {% if needs_per_client_transform %}
                            # OUTBOUND: Publish raw message - transformation happens per-client in router
                            raw_message = {
                                "source": source_name,
                                "entity": entity,
                                "payload": payload
                            }
                            if bus_in:
                                await bus_in.publish(raw_message)
                                self.logger.debug(f"[WS_INPUT] - Published raw message to bus")
                            {% else %}
                            # OUTBOUND: Compute transformation once and broadcast to all clients
                            # (No endpoint params used, so same result for all clients)
                            {% if entity_out and not entity_in %}
                            # Compute outbound chain
                            chain_to_use = self._compiled_chain_outbound
                            row, _ = self.compute_entity_chain(payload, uuid.uuid4().hex, chain_to_use, source_name, entity)
                            if row is not None and bus_in:
                                await bus_in.publish(row)
                                self.logger.debug(f"[WS_INPUT] - Published transformed message to bus")
                            {% else %}
                            # No chain, direct publish
                            if bus_in:
                                await bus_in.publish(payload)
                                self.logger.debug(f"[WS_INPUT] - Published message to bus")
                            {% endif %}
                            {% endif %}
                        else:
                            # INBOUND: Compute transformation immediately (no header params needed)
                            {% if sync_config_inbound %}
                            row = await self.compute_with_sync(payload, uuid.uuid4().hex, self._compiled_chain_inbound, source_name)
                            {% else %}
                            row, _ = self.compute_entity_chain(payload, uuid.uuid4().hex, self._compiled_chain_inbound, source_name, entity)
                            {% endif %}

                            if row is not None:
                                if bus_in:
                                    await bus_in.publish(row)
            except Exception as ex:
                self.logger.warning(f"[WS_INPUT] - Connection lost for {entity}, reconnecting: {ex}")
                await asyncio.sleep(1.0)


    async def ensure_ws_inputs_started(self, bus_in):
        """Start readers for WS inputs not used by external targets."""
        if not self._ws_inputs or bus_in is None:
            return

        async with self._inputs_lock:
            if self._started_inputs:
                return
            target_urls = {t.get("url") for t in self._external_targets}
            inputs_to_start = [inp for inp in self._ws_inputs if inp.get("url") not in target_urls]

            self.logger.info(f"[WS_INPUT] - Starting {len(inputs_to_start)} input consumer(s)")
            for inp in inputs_to_start:
                asyncio.create_task(self.ws_input_consumer(inp, bus_in))
            self._started_inputs = True


    # ========================================================================
    # EVENT CHECKING
    # ========================================================================

    {% if events %}
    def check_event_conditions(self, context: Dict[str, Any]) -> Optional[tuple]:
        """Check all event conditions and return (close_code, message, should_close) if any match."""
        eval_globals = {**safe_globals, **context}
        {% for event in events %}
        try:
            compiled_condition = compile_safe({{ event.condition | tojson }})
            if eval(compiled_condition, eval_globals, {}):
                {% if event.close %}
                self.logger.error("[EVENT] X Event condition triggered: {{ event.condition }}")
                self.logger.error("[EVENT]   Close Code: {{ event.close_code }}, Message: {{ event.message }}, Action: Closing connection")
                {% else %}
                self.logger.warning("[EVENT] ⚠ Event condition triggered: {{ event.condition }}")
                self.logger.warning("[EVENT]   Close Code: {{ event.close_code }}, Message: {{ event.message }}, Action: Logging only")
                {% endif %}
                return ({{ event.close_code }}, "{{ event.message }}", {{ "True" if event.close else "False" }})
        except Exception as eval_error:
            self.logger.error(f"[EVENT] - Failed to evaluate event condition: {eval_error}")
        {% endfor %}
        return None
    {% endif %}


    # ========================================================================
    # PUBLIC API
    # ========================================================================

    def get_inbound_outbound_entities(self):
        """Return the entity names for inbound/outbound chains."""
        inbound_entity = "{{ entity_in.name if entity_in else (compiled_chain_inbound[0].name if compiled_chain_inbound else '') }}"
        outbound_entity = "{{ entity_out.name if entity_out else (compiled_chain_outbound[-1].name if compiled_chain_outbound else '') }}"
        return inbound_entity, outbound_entity


    def get_compiled_chains(self):
        """Return the compiled chains for inbound/outbound processing."""
        return self._compiled_chain_inbound, self._compiled_chain_outbound

    def has_external_targets(self) -> bool:
        """Check if there are external targets configured."""
        return len(self._external_targets) > 0

    def get_external_target_count(self) -> int:
        """Get the number of external targets."""
        return len(self._external_targets)


# ============================================================================
#                    SERVICE INSTANCE
# ============================================================================

# Create singleton service instance for this endpoint
service = {{ endpoint.name }}Service()
