# app/infra/repositories/{{ entity.name | lower }}_adapter.py
from typing import Any, Dict, List, Optional
from app.core.http import get_http_client
from app.core.utils import resolve_headers
from app.core.errors import http_upstream_error

_UPSTREAM_URL = "{{ entity.source.url }}"
_HEADERS = resolve_headers([
{% for h in entity.source.headers | default([], true) %}    ("{{ h.key }}", "{{ h.value }}"),
{% endfor %}])

# Default projection = schema attributes for this entity
_DEFAULT_FIELDS: list[str] = [
{%- for a in entity.attributes if a.kind == "schema" %}
    "{{ a.name }}",
{%- endfor %}
]

def _project(x: Dict[str, Any], keep: Optional[list[str]]) -> Dict[str, Any]:
    if not keep:
        return x
    return {k: x.get(k) for k in keep}

class {{ entity.name }}Adapter:
    async def list(
        self,
        limit: int,
        offset: int,
        sort: Optional[str],
        fields: Optional[list[str]],
        filters: Optional[Dict[str, Any]],
    ) -> List[Dict[str, Any]]:
        client = get_http_client()
        r = await client.get(_UPSTREAM_URL, headers=_HEADERS)
        if r.status_code >= 400:
            http_upstream_error(r)

        data = r.json()
        if not isinstance(data, list):
            from fastapi import HTTPException
            raise HTTPException(status_code=502, detail="Upstream did not return a list")

        # naive eq filters
        if filters:
            def ok(d): return all(d.get(k) == v for k, v in filters.items())
            data = [d for d in data if ok(d)]

        # sorting
        if sort:
            reverse = sort.startswith("-")
            key = sort.lstrip("-")
            data = sorted(data, key=lambda x: x.get(key), reverse=reverse)

        # projection (default to schema)
        keep = fields or _DEFAULT_FIELDS
        data = [_project(d, keep) for d in data]

        return data[offset: offset + limit]
