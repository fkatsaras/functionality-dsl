"""
HTTP Bearer Authentication Module (DB-backed)
Auto-generated from FDSL Auth<http> configuration with scheme: bearer

Configuration:
  Type: HTTP Bearer (token lookup)
  Roles: {{ roles }}
  Header: Authorization
  Scheme: Bearer

All tokens are stored in the database and looked up on each request.
"""

import logging
import secrets
from typing import List, Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlmodel import Session, select

from app.db.database import get_db, Token
from app.core.auth_base import TokenPayload, create_require_roles, create_require_all_roles


logger = logging.getLogger("fdsl.auth.{{ auth_name }}")


# ============================================================================
# Configuration
# ============================================================================

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Security scheme
# ============================================================================

security = HTTPBearer(
    scheme_name="bearer",
    description="Bearer token in Authorization header"
)


# ============================================================================
# Token creation (for auth routes)
# ============================================================================

def create_access_token(user_id: str, roles: List[str], db: Session = None) -> str:
    """
    Create a new bearer token and store it in the database.

    Args:
        user_id: User identifier
        roles: List of user roles
        db: Database session (if None, creates a new one)

    Returns:
        The generated token string
    """
    from app.db.database import engine
    from sqlmodel import Session as SQLSession

    token_str = secrets.token_urlsafe(32)
    roles_str = ",".join(roles) if roles else ""

    if db is None:
        with SQLSession(engine) as session:
            token_record = Token(
                token=token_str,
                user_id=user_id,
                roles=roles_str,
                is_active=True,
            )
            session.add(token_record)
            session.commit()
    else:
        token_record = Token(
            token=token_str,
            user_id=user_id,
            roles=roles_str,
            is_active=True,
        )
        db.add(token_record)
        db.commit()

    logger.debug(f"Created bearer token for user: {user_id}")
    return token_str


# ============================================================================
# Token verification (DB lookup)
# ============================================================================

def decode_token(token: str) -> TokenPayload:
    """
    Verify bearer token using synchronous DB access.
    Used by WebSocket handlers where async dependencies aren't available.

    Args:
        token: Bearer token string

    Returns:
        TokenPayload with user_id and roles

    Raises:
        Exception: If token is invalid or not found
    """
    from app.db.database import get_db_sync

    db = get_db_sync()
    try:
        return verify_token(token, db)
    finally:
        db.close()


def verify_token(token: str, db: Session) -> TokenPayload:
    """
    Verify bearer token by looking it up in the database.

    Args:
        token: Bearer token string
        db: Database session

    Returns:
        TokenPayload with user_id and roles

    Raises:
        HTTPException: If token is invalid or not found
    """
    # Look up token in database
    statement = select(Token).where(Token.token == token, Token.is_active == True)
    token_record = db.exec(statement).first()

    if not token_record:
        logger.warning("Invalid or inactive token attempted")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Parse roles (stored as comma-separated string or JSON)
    roles = []
    if token_record.roles:
        if isinstance(token_record.roles, list):
            roles = token_record.roles
        elif isinstance(token_record.roles, str):
            roles = [r.strip() for r in token_record.roles.split(",") if r.strip()]

    logger.debug(f"Token verified for user: {token_record.user_id}, roles: {roles}")

    return TokenPayload(
        user_id=token_record.user_id,
        roles=roles,
        token=token
    )


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from bearer token.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    return verify_token(credentials.credentials, db)


async def get_optional_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(HTTPBearer(auto_error=False)),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no token).

    Usage:
        @app.get("/public-or-protected")
        async def route(user: Optional[TokenPayload] = Depends(get_optional_user)):
            if user:
                return {"message": f"Hello {user.user_id}"}
            return {"message": "Hello anonymous"}
    """
    if credentials is None:
        return None
    return verify_token(credentials.credentials, db)


# Create role checking functions using the base factory
require_roles = create_require_roles(get_current_user, get_optional_user)
require_all_roles = create_require_all_roles(get_current_user)
