# ========================================================================
# AUTO-GENERATED WEBSOCKET ROUTER
# ========================================================================

import json
import uuid
import asyncio
import logging

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException
from pydantic import ValidationError

from app.core.logging import set_request_id
from app.core import wsbus
from app.core.ws_wrapper import WSMessageWrapper
from app.services.{{ endpoint.name | lower }}_service import service as ws_service
{% if entity_in %}
from app.domain.models import {{ entity_in.name }}
{% endif %}


logger = logging.getLogger("fdsl.router.ws.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ (endpoint.summary or endpoint.name) ~ ' (duplex)' }}"]
)


@router.websocket("")
@router.websocket("/duplex")
async def duplex(ws: WebSocket):
    """
    WebSocket endpoint for {{ endpoint.name }}.
    Provides bidirectional communication with external sources and clients.
    """
    rid = uuid.uuid4().hex
    set_request_id(rid)

    # Extract header parameters from WebSocket handshake
    header_params = {}
    {% for h in endpoint.header_params_typed %}
    {{ h.name | replace('-', '_') }} = ws.headers.get("{{ h.name }}")
    {% if h.required %}
    if {{ h.name | replace('-', '_') }} is None:
        await ws.close(code=4400)
        logger.warning(f"[HANDSHAKE] - Missing required header '{{ h.name }}' for {rid}")
        return
    {% endif %}
    header_params["{{ h.name }}"] = {{ h.name | replace('-', '_') }}
    {% endfor %}

    logger.debug(f"[HANDSHAKE] - Extracted header params: {list(header_params.keys())}")

    await ws.accept()
    logger.info(f"[CLIENT] - Connected: {rid} (path: {ws.url})")

    # Get entity names from service
    inbound_entity, outbound_entity = ws_service.get_inbound_outbound_entities()
    logger.info(f"[CLIENT] - Inbound entity: {inbound_entity or 'none'}, Outbound entity: {outbound_entity or 'none'}")

    # Get message buses with content types and message types
    bus_in = wsbus.get_bus(inbound_entity, content_type="{{ content_type_in }}", message_type="{{ publish_type or 'object' }}") if inbound_entity else None
    bus_out = wsbus.get_bus(outbound_entity, content_type="{{ content_type_out }}", message_type="{{ subscribe_type }}") if outbound_entity else None

    # Start WS input consumers and pre-warm target connections
    # For publish-only endpoints, WS inputs feed into the outbound bus
    ws_input_bus = bus_in if inbound_entity else bus_out
    await ws_service.ensure_ws_inputs_started(ws_input_bus)

    {% if connection_mode == 'scoped' %}
    # Scoped connection mode: Per-client external connections (created before loops)
    logger.info(f'[CLIENT] - Using scoped connection mode (key: {{ connection_key.full if connection_key else "unknown" }})')
    per_client_connections = []  # Track this client's external connections

    # Create per-client external connections BEFORE starting loops
    import websockets

    for idx, tgt in enumerate(ws_service._external_targets):
        try:
            logger.info(f"[CLIENT] - Establishing scoped connection to {tgt['url']} for {rid}")
            try:
                client_conn = await websockets.connect(
                    tgt["url"],
                    extra_headers=tgt["headers"] or [],
                    subprotocols=tgt["subprotocols"] or None
                )
            except TypeError:
                client_conn = await websockets.connect(
                    tgt["url"],
                    additional_headers=tgt["headers"] or [],
                    subprotocols=tgt["subprotocols"] or None
                )
            per_client_connections.append(client_conn)
            logger.info(f"[CLIENT] - Successfully connected to {tgt['url']} for {rid}")
        except Exception as ex:
            logger.error(f"[CLIENT] - Failed to establish scoped connection to {tgt['url']}: {ex}")
            per_client_connections.append(None)

    {% if external_targets and external_targets[0].get('onConnect', False) %}
    # Auto-send subscription message on connect (onConnect=true)
    logger.info(f"[CLIENT] - Auto-sending subscription message (onConnect=true)")
    chain_inbound, chain_outbound = ws_service.get_compiled_chains()
    try:
        # Compute subscription message with header params
        subscription_msg, context = ws_service.compute_entity_chain(
            {}, rid, chain_inbound, "{{ endpoint.name }}", "{{ entity_in.name if entity_in else '' }}", header_params, "{{ endpoint.name }}"
        )

        # Send to this client's external connections
        for idx, client_conn in enumerate(per_client_connections):
            if client_conn:
                await client_conn.send(json.dumps(subscription_msg))
                logger.info(f"[CLIENT] - Sent subscription to scoped connection: {subscription_msg}")
    except Exception as ex:
        logger.error(f"[CLIENT] - Failed to send auto-subscription: {ex}")
    {% endif %}
    {% else %}
    # Shared connection mode: Pre-warm shared external target connections
    if ws_service.has_external_targets():
        logger.info(f"[CLIENT] - Pre-warming {ws_service.get_external_target_count()} external target(s)")
        for i in range(ws_service.get_external_target_count()):
            asyncio.create_task(ws_service.ensure_target_connection(i, inbound_entity))
    {% endif %}

    # Inbound loop: Client -> Compute inbound chain -> Forward
    async def inbound_loop():
        logger.info(f"[CLIENT] - Starting inbound loop for {rid}")
        {% if connection_mode == 'scoped' %}
        # In scoped mode, connections already created - just get chains
        chain_inbound, chain_outbound = ws_service.get_compiled_chains()
        {% else %}
        # In shared mode, get chains as usual
        chain_inbound, chain_outbound = ws_service.get_compiled_chains()
        # Shared mode: Use service-managed shared connections
        {% if external_targets and external_targets[0].get('onConnect', False) %}
        # Auto-send subscription message on connect (onConnect=true)
        logger.info(f"[CLIENT] - Auto-sending subscription message (onConnect=true)")
        try:
            # Compute subscription message with header params
            subscription_msg, context = ws_service.compute_entity_chain(
                {}, rid, chain_inbound, "{{ endpoint.name }}", "{{ entity_in.name if entity_in else '' }}", header_params, "{{ endpoint.name }}"
            )

            # Send to external targets
            for idx in range(len(ws_service._external_targets)):
                await ws_service.ensure_target_connection(idx, "{{ entity_in.name if entity_in else '' }}")
                tgt_conn = ws_service._target_connections[idx]
                if tgt_conn:
                    await tgt_conn.send(json.dumps(subscription_msg))
                    logger.info(f"[CLIENT] - Sent subscription: {subscription_msg}")
        except Exception as ex:
            logger.error(f"[CLIENT] - Failed to send auto-subscription: {ex}")
        {% endif %}
        {% endif %}

        while True:
            raw = await ws.receive_text()
            logger.debug(f"[CLIENT] - Received message from {rid}")

            try:
                payload = json.loads(raw)
            except Exception:
                payload = raw

            {% if entity_in %}
            # Wrap primitive types for internal processing
            if WSMessageWrapper.should_wrap("{{ publish_type or 'object' }}"):
                # Get the wrapper entity's attribute name
                attr_name = "{{ wrapper_attr_name }}"
                wrapped_payload = WSMessageWrapper.wrap(payload, attr_name)
                logger.debug(f"[WRAPPER] Wrapped {{ publish_type }} message: {payload} -> {wrapped_payload}")
            else:
                # Object type - use as-is
                wrapped_payload = payload

            # Validate incoming message against Pydantic model
            try:
                validated = {{ entity_in.name }}(**wrapped_payload)
                payload = validated.model_dump()
                logger.debug(f"[VALIDATION] ✓ Message validated against {{ entity_in.name }}")
            except ValidationError as validation_error:
                error_messages = []
                for error in validation_error.errors():
                    field = ".".join(str(loc) for loc in error["loc"])
                    message = error["msg"]
                    error_messages.append(f"{field}: {message}")

                error_summary = "; ".join(error_messages)
                logger.error(f"[VALIDATION] ✗ Message validation failed: {error_summary}")

                error_response = {
                    "type": "validation_error",
                    "error": {
                        "code": 1003,  # Unsupported Data
                        "message": "Message validation failed",
                        "details": error_summary
                    }
                }
                await ws.send_text(json.dumps(error_response))
                continue
            except Exception as validation_error:
                logger.error(f"[VALIDATION] - Unexpected validation error: {validation_error}")
                error_response = {
                    "type": "error",
                    "error": {
                        "code": 1011,  # Internal Server Error
                        "message": "Validation error",
                        "details": str(validation_error)
                    }
                }
                await ws.send_text(json.dumps(error_response))
                continue
            {% endif %}

            try:
                row, context = ws_service.compute_entity_chain(
                    payload, rid, chain_inbound, "{{ endpoint.name }}", "{{ entity_in.name if entity_in else '' }}", header_params, "{{ endpoint.name }}"
                )

                {% if events %}
                # Check event conditions after computation
                event_result = ws_service.check_event_conditions(context)
                if event_result:
                    close_code, close_message, should_close = event_result
                    if should_close:
                        logger.error(f"[EVENT] - Closing connection with code {close_code}: {close_message}")
                        await ws.close(code=close_code, reason=close_message)
                        return
                    else:
                        # Send error message but keep connection open
                        logger.warning(f"[EVENT] - Event triggered (no close) - code {close_code}: {close_message}")
                        error_response = {
                            "type": "event",
                            "event": {
                                "code": close_code,
                                "message": close_message
                            }
                        }
                        await ws.send_text(json.dumps(error_response))
                        continue
                {% endif %}

                # For duplex endpoints: inbound chain results should NOT be published to client
                # They are only forwarded to external targets
                if row is not None and ws_service.has_external_targets():
                    {% if connection_mode == 'scoped' %}
                    # Scoped mode: Forward to this client's external connections
                    for idx, client_conn in enumerate(per_client_connections):
                        if client_conn:
                            try:
                                await client_conn.send(json.dumps(row))
                                logger.debug(f"[CLIENT] - Forwarded message to scoped connection {idx}")
                            except Exception as forward_ex:
                                logger.error(f"[CLIENT] - Failed to forward to scoped connection {idx}: {forward_ex}")
                    {% else %}
                    # Shared mode: Forward to shared external connections
                    await ws_service.forward_to_targets(row, inbound_entity)
                    {% endif %}
            except HTTPException as http_error:
                logger.error(f"[VALIDATION] - Validation failed: {http_error.detail}")
                error_response = {
                    "type": "error",
                    "error": {
                        "code": http_error.status_code,
                        "message": "Validation failed",
                        "details": http_error.detail
                    }
                }
                await ws.send_json(error_response)
                continue
            except Exception as compute_error:
                logger.error(f"[COMPUTE] - Unexpected error: {compute_error}", exc_info=True)
                error_response = {
                    "type": "error",
                    "error": {
                        "code": "INTERNAL_ERROR",
                        "message": "Failed to process message",
                        "details": str(compute_error)
                    }
                }
                await ws.send_json(error_response)
                continue

    # Outbound loop: Subscribe to bus, compute chain with header params, and send to client
    async def outbound_loop():
        logger.info(f"[CLIENT] - Starting outbound loop for {rid}, subscribed to: {outbound_entity}")
        chain_inbound, chain_outbound = ws_service.get_compiled_chains()

        {% if connection_mode == 'scoped' %}
        # Scoped mode: Read from per-client external connection
        if per_client_connections:
            for idx, client_conn in enumerate(per_client_connections):
                if client_conn:
                    logger.info(f"[CLIENT] - Starting reader for scoped connection {idx}")
                    try:
                        async for raw in client_conn:
                            logger.debug(f"[CLIENT] - Received from scoped connection {idx}")
                            try:
                                payload = json.loads(raw)
                            except Exception:
                                payload = raw

                            # Compute outbound chain with header params
                            {% if compiled_chain_outbound %}
                            try:
                                # Get the WS input entity name
                                inp = ws_service._ws_inputs[idx] if idx < len(ws_service._ws_inputs) else None
                                entity_name = inp.get("entity") if inp else None
                                source_name = inp.get("endpoint") if inp else "{{ endpoint.name }}"

                                row, context = ws_service.compute_entity_chain(
                                    payload, rid, chain_outbound, source_name, entity_name, header_params, "{{ endpoint.name }}"
                                )
                                if row is not None:
                                    await ws.send_json(row)
                                    logger.debug(f"[CLIENT] - Sent transformed message to client {rid}")
                            except Exception as compute_error:
                                logger.error(f"[CLIENT] - Error computing outbound chain: {compute_error}", exc_info=True)
                            {% else %}
                            # No transformation - direct forward
                            await ws.send_json(payload)
                            logger.debug(f"[CLIENT] - Sent message to client {rid}")
                            {% endif %}
                    except Exception as read_error:
                        logger.error(f"[CLIENT] - Error reading from scoped connection {idx}: {read_error}", exc_info=True)
                        break
        {% else %}
        # Shared mode: Subscribe to bus
        if bus_out:
            {% if needs_per_client_transform %}
            # Per-client transformation needed (outbound chain uses endpoint parameters)
            # Use raw message format and compute per-client
            message_queue = asyncio.Queue()

            # Create a custom WebSocket wrapper that intercepts messages and queues them
            class QueuedWebSocket:
                def __init__(self, ws, queue):
                    self._ws = ws
                    self._queue = queue

                async def send_json(self, data):
                    """Intercept bus messages and queue them for processing."""
                    await self._queue.put(data)

                async def send_text(self, data):
                    """Intercept bus messages and queue them for processing."""
                    await self._queue.put(data)

                async def send_bytes(self, data):
                    """Intercept bus messages and queue them for processing."""
                    await self._queue.put(data)

            # Register queued wrapper with bus
            queued_ws = QueuedWebSocket(ws, message_queue)
            await bus_out.add_ws(queued_ws)

            try:
                logger.info(f"[OUTBOUND] - Registered with bus, waiting for messages (per-client transformation)")

                while True:
                    # Get raw message from queue
                    raw_msg = await message_queue.get()
                    logger.debug(f"[OUTBOUND] - Received raw message from bus")

                    # Extract source name and payload from raw message
                    source_name = raw_msg.get("source")
                    entity_name = raw_msg.get("entity")
                    payload = raw_msg.get("payload")

                    # Compute outbound chain with header_params available in context
                    try:
                        {% if compiled_chain_outbound %}
                        row, context = ws_service.compute_entity_chain(
                            payload, rid, chain_outbound, source_name, entity_name, header_params, "{{ endpoint.name }}"
                        )
                        {% else %}
                        row = payload
                        {% endif %}
                        logger.debug(f"[OUTBOUND] - Computed outbound chain for {rid}")

                        # Send transformed message to this specific client
                        if row is not None:
                            await ws.send_json(row)
                            logger.debug(f"[OUTBOUND] - Sent message to client {rid}")
                    except Exception as compute_error:
                        logger.error(f"[OUTBOUND] - Error computing chain for {rid}: {compute_error}", exc_info=True)
                        # Continue processing other messages even if one fails
                        continue

            finally:
                await bus_out.remove_ws(queued_ws)
                logger.info(f"[CLIENT] - Removed {rid} from bus subscription")
            {% else %}
            # Simple passthrough - no header params, no transformation
            # Use direct bus subscription (original flow)
            await bus_out.add_ws(ws)
            try:
                while True:
                    await asyncio.sleep(1)
            finally:
                await bus_out.remove_ws(ws)
                logger.info(f"[CLIENT] - Removed {rid} from bus subscription")
            {% endif %}
        {% endif %}

    # Run both loops concurrently
    try:
        tasks = []
        {% if compiled_chain_inbound or entity_in %}
        tasks.append(asyncio.create_task(inbound_loop()))
        {% endif %}
        {% if compiled_chain_outbound or entity_out %}
        tasks.append(asyncio.create_task(outbound_loop()))
        {% endif %}

        logger.info(f"[CLIENT] - Starting {len(tasks)} task(s) for {rid}")
        await asyncio.gather(*tasks)
    except WebSocketDisconnect:
        logger.info(f"[CLIENT] - Disconnected: {rid}")
    except Exception as e:
        logger.error(f"[CLIENT] - Error in connection {rid}: {e}", exc_info=True)
        raise
    {% if connection_mode == 'scoped' %}
    finally:
        # Cleanup: Close per-client external connections
        for idx, client_conn in enumerate(per_client_connections):
            if client_conn:
                try:
                    await client_conn.close()
                    logger.info(f"[CLIENT] - Closed scoped connection {idx} for {rid}")
                except Exception as close_ex:
                    logger.error(f"[CLIENT] - Error closing scoped connection {idx}: {close_ex}")
    {% endif %}
