# app/api/routers/{{ entity.name | lower }}_stream.py
import asyncio, json, contextlib, time, uuid, logging
from typing import Any, Dict, Optional, Set

from fastapi import APIRouter, WebSocket, WebSocketDisconnect
import websockets

from app.core.computed import DSL_FUNCTION_REGISTRY as dsl_funcs
from app.core.expressions import compile_safe
from app.core.logging import set_request_id

logger = logging.getLogger("fdsl.router.ws.{{ entity.name }}")

router = APIRouter(prefix="/api/entities/{{ entity.name | lower }}", tags=["{{ entity.name }} (stream)"])

_WS_INPUTS = [
{%- for it in ws_inputs %}
    {"alias":"{{ it.alias }}","url":"{{ it.url }}","headers":{{ it.headers | tojson }},
     "subprotocols":{{ it.subprotocols | tojson }},"protocol":"{{ it.protocol }}"},
{%- endfor %}
]

_latest: Dict[str, Any] = {}
_started = False
_clients: Set[WebSocket] = set()
_clients_lock = asyncio.Lock()
_bg_task: Optional[asyncio.Task] = None

def _coerce_delta(payload: dict) -> dict:
    # Optional normalizer â€” safe no-op for non-Hatnote sources
    out = dict(payload)
    if "delta" in out: return out
    if "change_size" in out: out["delta"] = out["change_size"]; return out
    length = out.get("length")
    if isinstance(length, dict) and all(k in length for k in ("old","new")):
        try: out["delta"] = float(length["new"]) - float(length["old"])
        except Exception: pass
    return out

async def _ws_consumer(alias: str, url: str, headers: list, subprotocols: list, protocol: str, tick: asyncio.Queue):
    while True:
        try:
            try:
                cm = websockets.connect(url, extra_headers=headers, subprotocols=subprotocols or None)
            except TypeError:
                cm = websockets.connect(url, additional_headers=headers, subprotocols=subprotocols or None)

            logger.info("upstream_connecting", extra={"alias":alias,"url":url})
            async with cm as ws_conn:
                logger.info("upstream_connected", extra={"alias":alias})
                async for raw in ws_conn:
                    try:
                        msg = json.loads(raw) if (protocol == "json" and isinstance(raw, (str, bytes, bytearray))) else raw
                        payload = msg.get("data") if isinstance(msg, dict) and "data" in msg else msg
                        if isinstance(payload, dict):
                            payload = _coerce_delta(payload)
                        _latest[alias] = payload
                        with contextlib.suppress(Exception):
                            tick.put_nowait(True)
                    except Exception as ex:
                        logger.debug("frame_parse_error", extra={"alias":alias,"err":repr(ex)})
        except Exception as ex:
            logger.warning("upstream_reconnect", extra={"alias":alias,"err":repr(ex)})
            await asyncio.sleep(1.0)

_COMPILED = {
{%- for attr in computed_attrs %}
    "{{ attr.name }}": compile_safe({{ attr.pyexpr | tojson }}),
{%- endfor %}
}

def _compute_row() -> Dict[str, Any] | None:
    if any(alias not in _latest for alias in [{% for a in ws_aliases %}"{{ a }}",{% endfor %}]):
        return None
    ctx = {alias: _latest[alias] for alias in _latest}
    row: Dict[str, Any] = {}
    try:
        for name, code in _COMPILED.items():
            row[name] = eval(code, {"__builtins__": {}, "dsl_funcs": dsl_funcs}, {"ctx": ctx})
        return row
    except Exception as ex:
        # single-line, structured
        sample = {k: (list(v.keys())[:6] if isinstance(v, dict) else type(v).__name__) for k, v in ctx.items()}
        logger.error("compute_error", extra={"err":repr(ex), "ctx_keys": sample})
        return None

async def _broadcast(msg: Any):
    dead = []
    async with _clients_lock:
        for ws in list(_clients):
            try:
                await ws.send_json(msg)
            except Exception:
                dead.append(ws)
        for ws in dead:
            _clients.discard(ws)
    logger.debug("broadcast", extra={"clients": len(_clients)})

async def _loop():
    global _started
    tick: asyncio.Queue = asyncio.Queue(maxsize=1)
    if not _started:
        for it in _WS_INPUTS:
            asyncio.create_task(_ws_consumer(it["alias"], it["url"], it["headers"], it["subprotocols"], it["protocol"], tick))
        _started = True

    while True:
        await tick.get()
        row = _compute_row()
        if row is not None:
            await _broadcast(row)

@router.websocket("/stream")
async def stream(ws: WebSocket):
    # WS gets its own correlation id
    rid = uuid.uuid4().hex
    set_request_id(rid)
    await ws.accept()
    logger.info("client_connected", extra={"rid":rid, "path":str(ws.url)})

    global _bg_task
    async with _clients_lock:
        _clients.add(ws)
    try:
        if _bg_task is None or _bg_task.done():
            _bg_task = asyncio.create_task(_loop())

        row = _compute_row()
        if row is not None:
            await ws.send_json(row)

        while True:
            await ws.receive_text()
    except WebSocketDisconnect:
        logger.info("client_disconnected", extra={"rid":rid})
    finally:
        async with _clients_lock:
            _clients.discard(ws)
