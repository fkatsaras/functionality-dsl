# ========================================================================
# AUTO-GENERATED WEBSOCKET ROUTER
# ========================================================================

import json
import uuid
import asyncio
import logging

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException

from app.core.logging import set_request_id
from app.core import wsbus
from app.services import {{ endpoint.name | lower }}_service as ws_service


logger = logging.getLogger("fdsl.router.ws.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ (endpoint.summary or endpoint.name) ~ ' (duplex)' }}"]
)


@router.websocket("")
@router.websocket("/duplex")
async def duplex(ws: WebSocket):
    """
    WebSocket endpoint for {{ endpoint.name }}.
    Provides bidirectional communication with external sources and clients.
    """
    rid = uuid.uuid4().hex
    set_request_id(rid)

    # ----------------------------------------------------------------
    # Authentication
    # ----------------------------------------------------------------
    {% if endpoint.auth %}
    {% if endpoint.auth.kind == 'bearer' %}
    auth_header = ws.headers.get("authorization")
    if not auth_header or not auth_header.lower().startswith("bearer "):
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing bearer token for {rid}")
        return
    {% elif endpoint.auth.kind == 'basic' %}
    auth_header = ws.headers.get("authorization")
    if not auth_header or not auth_header.lower().startswith("basic "):
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing basic credentials for {rid}")
        return
    {% elif endpoint.auth.kind == 'api_key' and endpoint.auth.location == 'header' %}
    api_key_value = ws.headers.get("{{ endpoint.auth.key }}")
    if not api_key_value:
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing API key header '{{ endpoint.auth.key }}'")
        return
    {% elif endpoint.auth.kind == 'api_key' and endpoint.auth.location == 'query' %}
    from urllib.parse import parse_qs, urlparse
    qs = parse_qs(urlparse(str(ws.url)).query)
    if "{{ endpoint.auth.key }}" not in qs:
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing API key query param '{{ endpoint.auth.key }}'")
        return
    {% endif %}
    {% endif %}

    await ws.accept()
    logger.info(f"[CLIENT] - Connected: {rid} (path: {ws.url})")

    # Get entity names from service
    inbound_entity, outbound_entity = ws_service.get_inbound_outbound_entities()
    logger.info(f"[CLIENT] - Inbound entity: {inbound_entity or 'none'}, Outbound entity: {outbound_entity or 'none'}")

    # Get message buses
    bus_in = wsbus.get_bus(inbound_entity) if inbound_entity else None
    bus_out = wsbus.get_bus(outbound_entity) if outbound_entity else None

    # Start WS input consumers and pre-warm target connections
    await ws_service.ensure_ws_inputs_started(bus_in)

    if ws_service._EXTERNAL_TARGETS:
        logger.info(f"[CLIENT] - Pre-warming {len(ws_service._EXTERNAL_TARGETS)} external target(s)")
        for i in range(len(ws_service._EXTERNAL_TARGETS)):
            asyncio.create_task(ws_service.ensure_target_connection(i, inbound_entity))

    # ----------------------------------------------------------------
    # Inbound loop: Client → Compute outbound chain → Forward
    # ----------------------------------------------------------------
    async def inbound_loop():
        logger.info(f"[CLIENT] - Starting inbound loop for {rid}")
        chain_inbound, chain_outbound = ws_service.get_compiled_chains()

        while True:
            raw = await ws.receive_text()
            logger.debug(f"[CLIENT] - Received message from {rid}")

            try:
                payload = json.loads(raw)
            except Exception:
                payload = raw

            try:
                row = ws_service.compute_entity_chain(
                    payload, rid, chain_outbound, "{{ endpoint.name }}"
                )

                if row is not None and bus_out:
                    await bus_out.publish(row)
                    logger.debug(f"[CLIENT] - Published to outbound bus")
                    if ws_service._EXTERNAL_TARGETS:
                        await ws_service.forward_to_targets(row, inbound_entity)
            except HTTPException as http_error:
                logger.error(f"[VALIDATION] - Validation failed: {http_error.detail}")
                error_response = {
                    "type": "error",
                    "error": {
                        "code": http_error.status_code,
                        "message": "Validation failed",
                        "details": http_error.detail
                    }
                }
                await ws.send_json(error_response)
                continue
            except Exception as compute_error:
                logger.error(f"[COMPUTE] - Unexpected error: {compute_error}", exc_info=True)
                error_response = {
                    "type": "error",
                    "error": {
                        "code": "INTERNAL_ERROR",
                        "message": "Failed to process message",
                        "details": str(compute_error)
                    }
                }
                await ws.send_json(error_response)
                continue

    # ----------------------------------------------------------------
    # Outbound loop: Subscribe to bus and send to client
    # ----------------------------------------------------------------
    async def outbound_loop():
        logger.info(f"[CLIENT] - Starting outbound loop for {rid}, subscribed to: {inbound_entity}")
        if bus_in:
            await bus_in.add_ws(ws)
            try:
                while True:
                    await asyncio.sleep(1)
            finally:
                await bus_in.remove_ws(ws)
                logger.info(f"[CLIENT] - Removed {rid} from bus subscription")

    # ----------------------------------------------------------------
    # Run both loops concurrently
    # ----------------------------------------------------------------
    try:
        tasks = []
        {% if compiled_chain_outbound or entity_out %}
        tasks.append(asyncio.create_task(inbound_loop()))
        {% endif %}
        {% if compiled_chain_inbound or entity_in %}
        tasks.append(asyncio.create_task(outbound_loop()))
        {% endif %}

        logger.info(f"[CLIENT] - Starting {len(tasks)} task(s) for {rid}")
        await asyncio.gather(*tasks)
    except WebSocketDisconnect:
        logger.info(f"[CLIENT] - Disconnected: {rid}")
    except Exception as e:
        logger.error(f"[CLIENT] - Error in connection {rid}: {e}", exc_info=True)
        raise
