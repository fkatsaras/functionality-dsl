# ========================================================================
# AUTO-GENERATED WEBSOCKET ROUTER
# ========================================================================

import json
import uuid
import asyncio
import logging

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException
from pydantic import ValidationError

from app.core.logging import set_request_id
from app.core import wsbus
from app.services import {{ endpoint.name | lower }}_service as ws_service
{% if entity_in %}
from app.domain.models import {{ entity_in.name }}
{% endif %}


logger = logging.getLogger("fdsl.router.ws.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ (endpoint.summary or endpoint.name) ~ ' (duplex)' }}"]
)


@router.websocket("")
@router.websocket("/duplex")
async def duplex(ws: WebSocket):
    """
    WebSocket endpoint for {{ endpoint.name }}.
    Provides bidirectional communication with external sources and clients.
    """
    rid = uuid.uuid4().hex
    set_request_id(rid)

    # Authentication
    {% if endpoint.auth %}
    {% if endpoint.auth.kind == 'bearer' %}
    auth_header = ws.headers.get("authorization")
    if not auth_header or not auth_header.lower().startswith("bearer "):
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing bearer token for {rid}")
        return
    {% elif endpoint.auth.kind == 'basic' %}
    auth_header = ws.headers.get("authorization")
    if not auth_header or not auth_header.lower().startswith("basic "):
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing basic credentials for {rid}")
        return
    {% elif endpoint.auth.kind == 'api_key' and endpoint.auth.location == 'header' %}
    api_key_value = ws.headers.get("{{ endpoint.auth.key }}")
    if not api_key_value:
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing API key header '{{ endpoint.auth.key }}'")
        return
    {% elif endpoint.auth.kind == 'api_key' and endpoint.auth.location == 'query' %}
    from urllib.parse import parse_qs, urlparse
    qs = parse_qs(urlparse(str(ws.url)).query)
    if "{{ endpoint.auth.key }}" not in qs:
        await ws.close(code=4401)
        logger.warning(f"[AUTH] - Missing API key query param '{{ endpoint.auth.key }}'")
        return
    {% endif %}
    {% endif %}

    await ws.accept()
    logger.info(f"[CLIENT] - Connected: {rid} (path: {ws.url})")

    # Get entity names from service
    inbound_entity, outbound_entity = ws_service.get_inbound_outbound_entities()
    logger.info(f"[CLIENT] - Inbound entity: {inbound_entity or 'none'}, Outbound entity: {outbound_entity or 'none'}")

    # Get message buses with content types and message types
    bus_in = wsbus.get_bus(inbound_entity, content_type="{{ content_type_in }}", message_type="{{ publish_type or 'object' }}") if inbound_entity else None
    bus_out = wsbus.get_bus(outbound_entity, content_type="{{ content_type_out }}", message_type="{{ subscribe_type }}") if outbound_entity else None

    # Start WS input consumers and pre-warm target connections
    # For publish-only endpoints, WS inputs feed into the outbound bus
    ws_input_bus = bus_in if inbound_entity else bus_out
    await ws_service.ensure_ws_inputs_started(ws_input_bus)

    if ws_service._EXTERNAL_TARGETS:
        logger.info(f"[CLIENT] - Pre-warming {len(ws_service._EXTERNAL_TARGETS)} external target(s)")
        for i in range(len(ws_service._EXTERNAL_TARGETS)):
            asyncio.create_task(ws_service.ensure_target_connection(i, inbound_entity))

    # Inbound loop: Client -> Compute inbound chain -> Forward
    async def inbound_loop():
        logger.info(f"[CLIENT] - Starting inbound loop for {rid}")
        chain_inbound, chain_outbound = ws_service.get_compiled_chains()

        while True:
            raw = await ws.receive_text()
            logger.debug(f"[CLIENT] - Received message from {rid}")

            try:
                payload = json.loads(raw)
            except Exception:
                payload = raw

            {% if entity_in %}
            # Validate incoming message against Pydantic model
            try:
                {% if publish_is_primitive %}
                # Primitive type ({{ publish_type }}) - wrap in entity's first attribute
                # For wrapper entities with single attribute, payload is the raw value
                validated = {{ entity_in.name }}(**{"{{ compiled_chain_inbound[0].attrs[0].name if compiled_chain_inbound and compiled_chain_inbound[0].attrs else 'value' }}": payload})
                {% else %}
                # Object type - payload should be a dict
                validated = {{ entity_in.name }}(**payload)
                {% endif %}
                payload = validated.model_dump()
                logger.debug(f"[VALIDATION] ✓ Message validated against {{ entity_in.name }}")
            except ValidationError as validation_error:
                error_messages = []
                for error in validation_error.errors():
                    field = ".".join(str(loc) for loc in error["loc"])
                    message = error["msg"]
                    error_messages.append(f"{field}: {message}")

                error_summary = "; ".join(error_messages)
                logger.error(f"[VALIDATION] ✗ Message validation failed: {error_summary}")

                error_response = {
                    "type": "validation_error",
                    "error": {
                        "code": 1003,  # Unsupported Data
                        "message": "Message validation failed",
                        "details": error_summary
                    }
                }
                await ws.send_text(json.dumps(error_response))
                continue
            except Exception as validation_error:
                logger.error(f"[VALIDATION] - Unexpected validation error: {validation_error}")
                error_response = {
                    "type": "error",
                    "error": {
                        "code": 1011,  # Internal Server Error
                        "message": "Validation error",
                        "details": str(validation_error)
                    }
                }
                await ws.send_text(json.dumps(error_response))
                continue
            {% endif %}

            try:
                row, context = ws_service.compute_entity_chain(
                    payload, rid, chain_inbound, "{{ endpoint.name }}"
                )

                {% if events %}
                # Check event conditions after computation
                event_result = ws_service.check_event_conditions(context)
                if event_result:
                    close_code, close_message, should_close = event_result
                    if should_close:
                        logger.error(f"[EVENT] - Closing connection with code {close_code}: {close_message}")
                        await ws.close(code=close_code, reason=close_message)
                        return
                    else:
                        # Send error message but keep connection open
                        logger.warning(f"[EVENT] - Event triggered (no close) - code {close_code}: {close_message}")
                        error_response = {
                            "type": "event",
                            "event": {
                                "code": close_code,
                                "message": close_message
                            }
                        }
                        await ws.send_text(json.dumps(error_response))
                        continue
                {% endif %}

                if row is not None and bus_out:
                    await bus_out.publish(row)
                    logger.debug(f"[CLIENT] - Published to outbound bus")
                    if ws_service._EXTERNAL_TARGETS:
                        await ws_service.forward_to_targets(row, inbound_entity)
            except HTTPException as http_error:
                logger.error(f"[VALIDATION] - Validation failed: {http_error.detail}")
                error_response = {
                    "type": "error",
                    "error": {
                        "code": http_error.status_code,
                        "message": "Validation failed",
                        "details": http_error.detail
                    }
                }
                await ws.send_json(error_response)
                continue
            except Exception as compute_error:
                logger.error(f"[COMPUTE] - Unexpected error: {compute_error}", exc_info=True)
                error_response = {
                    "type": "error",
                    "error": {
                        "code": "INTERNAL_ERROR",
                        "message": "Failed to process message",
                        "details": str(compute_error)
                    }
                }
                await ws.send_json(error_response)
                continue

    # Outbound loop: Subscribe to bus and send to client
    async def outbound_loop():
        logger.info(f"[CLIENT] - Starting outbound loop for {rid}, subscribed to: {outbound_entity}")
        if bus_out:
            await bus_out.add_ws(ws)
            try:
                while True:
                    await asyncio.sleep(1)
            finally:
                await bus_out.remove_ws(ws)
                logger.info(f"[CLIENT] - Removed {rid} from bus subscription")

    # Run both loops concurrently
    try:
        tasks = []
        {% if compiled_chain_inbound or entity_in %}
        tasks.append(asyncio.create_task(inbound_loop()))
        {% endif %}
        {% if compiled_chain_outbound or entity_out %}
        tasks.append(asyncio.create_task(outbound_loop()))
        {% endif %}

        logger.info(f"[CLIENT] - Starting {len(tasks)} task(s) for {rid}")
        await asyncio.gather(*tasks)
    except WebSocketDisconnect:
        logger.info(f"[CLIENT] - Disconnected: {rid}")
    except Exception as e:
        logger.error(f"[CLIENT] - Error in connection {rid}: {e}", exc_info=True)
        raise
