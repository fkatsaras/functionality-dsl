import asyncio
import json
import contextlib
import uuid
import logging
import websockets

from typing import Any, Dict, Optional, Set

from fastapi import APIRouter, WebSocket, WebSocketDisconnect

from app.core.computed import (
    DSL_FUNCTION_REGISTRY as dsl_funcs,
    compile_safe,
    safe_globals,
)
from app.core.logging import set_request_id

logger = logging.getLogger("fdsl.router.ws.{{ endpoint.name }}")

# Internal endpoint-driven router
router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ (endpoint.summary or endpoint.name) ~ ' (stream)' }}"]
)

_WS_INPUTS = [
{%- for it in ws_inputs %}
    {"name":"{{ it.name }}","url":"{{ it.url }}","headers":{{ it.headers | tojson }},
     "subprotocols":{{ it.subprotocols | tojson }},"protocol":"{{ it.protocol }}"},
{%- endfor %}
]

_latest: Dict[str, Any] = {}
_started = False
_clients: Set[WebSocket] = set()
_clients_lock = asyncio.Lock()
_bg_task: Optional[asyncio.Task] = None

def _coerce_delta(payload: dict) -> dict:
    out = dict(payload)
    if "delta" in out: return out
    if "change_size" in out: out["delta"] = out["change_size"]; return out
    length = out.get("length")
    if isinstance(length, dict) and all(k in length for k in ("old","new")):
        try: out["delta"] = float(length["new"]) - float(length["old"])
        except Exception: pass
    return out

async def _ws_consumer(name: str, url: str, headers: list, subprotocols: list, protocol: str, tick: asyncio.Queue):
    while True:
        try:
            try:
                cm = websockets.connect(url, extra_headers=headers, subprotocols=subprotocols or None)
            except TypeError:
                cm = websockets.connect(url, additional_headers=headers, subprotocols=subprotocols or None)

            logger.info("upstream_connecting", extra={"feed": name,"url":url})
            async with cm as ws_conn:
                logger.info("upstream_connected", extra={"feed":name})
                async for raw in ws_conn:
                    try:
                        msg = json.loads(raw) if (protocol == "json" and isinstance(raw, (str, bytes, bytearray))) else raw
                        payload = msg.get("data") if isinstance(msg, dict) and "data" in msg else msg
                        if isinstance(payload, dict):
                            payload = _coerce_delta(payload)
                        _latest[name] = payload
                        with contextlib.suppress(Exception):
                            tick.put_nowait(True)
                    except Exception as ex:
                        logger.debug("frame_parse_error", extra={"feed":name,"err":repr(ex)})
        except Exception as ex:
            logger.warning("upstream_reconnect", extra={"feed":name,"err":repr(ex)})
            await asyncio.sleep(1.0)

_COMPILED = {
{%- for attr in computed_attrs %}
    "{{ attr.name }}": compile_safe({{ attr.pyexpr | tojson }}),
{%- endfor %}
}

{% if entity._where_py %}
_WHERE = compile_safe({{ entity._where_py | tojson }})
{% else %}
_WHERE = None
{% endif %}

def _compute_row() -> Dict[str, Any] | None:
    if any(p not in _latest for p in [{% for a in ws_aliases %}"{{ a }}",{% endfor %}]):
        return None
    ctx = {p: _latest[p] for p in _latest}
    row: Dict[str, Any] = {}
    try:
        for name, code in _COMPILED.items():
            row[name] = eval(code, safe_globals, {"ctx": ctx})
        return row
    except Exception as ex:
        sample = {k: (list(v.keys())[:6] if isinstance(v, dict) else type(v).__name__) for k, v in ctx.items()}
        logger.error("compute_error", extra={"err":repr(ex), "ctx_keys": sample})
        return None

async def _broadcast(msg: Any):
    dead = []
    async with _clients_lock:
        for ws in list(_clients):
            try:
                await ws.send_json(msg)
            except Exception:
                dead.append(ws)
        for ws in dead:
            _clients.discard(ws)
    logger.debug("broadcast", extra={"clients": len(_clients)})

async def _loop():
    global _started
    tick: asyncio.Queue = asyncio.Queue(maxsize=1)
    if not _started:
        for it in _WS_INPUTS:
            asyncio.create_task(_ws_consumer(it["name"], it["url"], it["headers"], it["subprotocols"], it["protocol"], tick))
        _started = True

    while True:
        await tick.get()
        row = _compute_row()
        if row is not None:
            ctx = {alias: _latest[alias] for alias in _latest}
            await _broadcast(row)

@router.websocket("/stream")
async def stream(ws: WebSocket):
    rid = uuid.uuid4().hex
    set_request_id(rid)
    await ws.accept()
    logger.info("client_connected", extra={"rid":rid, "path":str(ws.url)})

    global _bg_task
    async with _clients_lock:
        _clients.add(ws)
    try:
        if _bg_task is None or _bg_task.done():
            _bg_task = asyncio.create_task(_loop())

        row = _compute_row()
        if row is not None:
            await ws.send_json(row)

        while True:
            await ws.receive_text()
    except WebSocketDisconnect:
        logger.info("client_disconnected", extra={"rid":rid})
    finally:
        async with _clients_lock:
            _clients.discard(ws)
