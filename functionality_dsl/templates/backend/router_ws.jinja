{# router_ws.jinja #}
import asyncio
import json
import contextlib
import uuid
import logging
import websockets

from typing import Any, Dict, Optional, Set

from fastapi import APIRouter, WebSocket, WebSocketDisconnect

from app.core.computed import compile_safe, safe_globals
from app.core.logging import set_request_id

logger = logging.getLogger("fdsl.router.ws.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ (endpoint.summary or endpoint.name) ~ ' (stream)' }}"]
)

# === External WS inputs  ===
_WS_INPUTS = [
{%- for it in ws_inputs %}
    {
        "entity": "{{ it.entity }}",
        "alias":  "{{ it.alias }}",
        "url": "{{ it.url }}",
        "headers": {{ (it.headers or []) | tojson }},
        "subprotocols": {{ (it.subprotocols or []) | tojson }},
        "protocol": "{{ it.protocol or 'json' }}"
    },
{%- endfor %}
]

# === Per-input attribute compiles: evaluate against ALIAS, bind under ENTITY ===
_INPUT_ATTRS = {
{%- for it in ws_inputs %}
  "{{ it.entity }}": {
  {%- for a in (it.attrs or []) %}
    "{{ a.name }}": compile_safe({{ a.pyexpr | tojson }}),
  {%- endfor %}
  },
{%- endfor %}
}

# === Compiled entity chain (computed from ctx) ===
_COMPILED_CHAIN = [
{%- for ent in compiled_chain %}
  {
    "name": "{{ ent.name }}",
    "attrs": [
    {%- for a in ent.attrs %}
      {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
    {%- endfor %}
    ]
  },
{%- endfor %}
]

_latest: Dict[str, Any] = {}   # entity -> shaped dict (like REST)
_started = False
_clients: Set[WebSocket] = set()
_clients_lock = asyncio.Lock()
_bg_task: Optional[asyncio.Task] = None


async def _ws_consumer(entity: str, alias: str, url: str, headers: list, subprotocols: list, protocol: str, tick: asyncio.Queue):
    while True:
        try:
            try:
                cm = websockets.connect(url, extra_headers=headers, subprotocols=subprotocols or None)
            except TypeError:
                cm = websockets.connect(url, additional_headers=headers, subprotocols=subprotocols or None)

            logger.info("upstream_connecting", extra={"feed": entity, "url": url})
            async with cm as ws_conn:
                logger.info("upstream_connected", extra={"feed": entity})
                async for raw in ws_conn:
                    try:
                        # 1) parse frames (no heuristics)
                        if protocol == "json":
                            payload = json.loads(raw) if isinstance(raw, (str, bytes, bytearray)) else raw
                        elif protocol == "text":
                            payload = raw.decode("utf-8") if isinstance(raw, (bytes, bytearray)) else str(raw)
                        elif protocol == "raw":
                            payload = raw if isinstance(raw, (bytes, bytearray)) else bytes(str(raw), "utf-8")
                        else:
                            payload = json.loads(raw) if isinstance(raw, (str, bytes, bytearray)) else raw

                        # 2) shape into parent/entity dict (evaluate attrs against ALIAS)
                        shaped: Dict[str, Any] = {}
                        attrs = _INPUT_ATTRS.get(entity, {})
                        if attrs:
                            eval_ctx = {alias: payload, "ctx": {alias: payload}}
                            for aname, code in attrs.items():
                                try:
                                    shaped[aname] = eval(code, safe_globals, eval_ctx)
                                except Exception as ex:
                                    logger.debug("attr_eval_error", extra={"entity": entity, "attr": aname, "err": repr(ex)})
                        #  REST-parity fallback when nothing shaped
                        if not shaped:
                            shaped = {"raw": payload}

                        logger.info("shaped_payload", extra={"entity": entity, "shaped": shaped})
                        #  Bind BOTH: shaped under entity, raw under alias
                        _latest[entity] = shaped
                        _latest[alias] = payload

                        with contextlib.suppress(Exception):
                            tick.put_nowait(True)
                    except Exception as ex:
                        logger.debug("frame_parse_error", extra={"feed": entity, "err": repr(ex)})
        except Exception as ex:
            logger.warning("upstream_reconnect", extra={"feed": entity, "err": repr(ex)})
            await asyncio.sleep(1.0)


def _compute_row() -> Dict[str, Any] | None:
    if not _latest:
        return None

    # Build ctx : ctx[EntityName] = shaped_parent_dict
    ctx: Dict[str, Any] = dict(_latest)

    try:
        # Walk the chain in order (ancestors first, then terminal)
        for ent in _COMPILED_CHAIN:
            shaped: Dict[str, Any] = {}
            eval_ctx = {"ctx": ctx}
            for a in (ent.get("attrs") or []):
                try:
                    compiled = compile_safe(a["expr"])
                    shaped[a["name"]] = eval(compiled, safe_globals, eval_ctx)
                except Exception as ex:
                    logger.error("attr_eval_error", extra={
                        "entity": ent["name"],
                        "attr": a["name"],
                        "expr": a["expr"],
                        "err": repr(ex),
                        "ctx_keys": list(ctx.keys())
                    })
                    shaped[a["name"]] = None
            ctx[ent["name"]] = shaped

        # final payload = last entity in chain
        return ctx[_COMPILED_CHAIN[-1]["name"]]
    except Exception as ex:
        sample = {k: (list(v.keys())[:6] if isinstance(v, dict) else type(v).__name__) for k, v in ctx.items()}
        logger.error("compute_error", extra={"err": repr(ex), "ctx_keys": sample})
        return None


async def _broadcast(msg: Any):
    dead = []
    async with _clients_lock:
        for ws in list(_clients):
            try:
                await ws.send_json(msg)
            except Exception:
                dead.append(ws)
        for ws in dead:
            _clients.discard(ws)
    logger.debug("broadcast", extra={"clients": len(_clients)})


async def _loop():
    global _started
    tick: asyncio.Queue = asyncio.Queue(maxsize=1)
    if not _started:
        for it in _WS_INPUTS:
            asyncio.create_task(_ws_consumer(
                it["entity"], it["alias"], it["url"], it["headers"], it["subprotocols"], it["protocol"], tick
            ))
        _started = True

    while True:
        await tick.get()
        row = _compute_row()
        if row is not None:
            await _broadcast(row)


@router.websocket("/stream")
async def stream(ws: WebSocket):
    rid = uuid.uuid4().hex
    set_request_id(rid)
    await ws.accept()
    logger.info("client_connected", extra={"rid": rid, "path": str(ws.url)})

    global _bg_task
    async with _clients_lock:
        _clients.add(ws)
    try:
        if _bg_task is None or _bg_task.done():
            _bg_task = asyncio.create_task(_loop())

        # send first snapshot if we already have one
        row = _compute_row()
        if row is not None:
            await ws.send_json(row)

        while True:
            await ws.receive_text()
    except WebSocketDisconnect:
        logger.info("client_disconnected", extra={"rid": rid})
    finally:
        async with _clients_lock:
            _clients.discard(ws)
