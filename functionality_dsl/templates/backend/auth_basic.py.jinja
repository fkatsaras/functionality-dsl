"""
HTTP Basic Authentication Module
Auto-generated from FDSL Auth<http> configuration with scheme: basic

Configuration:
  Type: HTTP Basic
  Roles: {{ roles }}

Users are stored in the database and validated on each request.
"""

import secrets
from typing import List, Optional
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from sqlmodel import Session, select

from app.db.database import get_db, User, USER_ID_COLUMN, USER_PASSWORD_COLUMN, USER_ROLE_COLUMN
from app.db.password import verify_password


# ============================================================================
# Configuration
# ============================================================================

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Security scheme
# ============================================================================

security = HTTPBasic()


# ============================================================================
# Database validation
# ============================================================================

def validate_credentials(db: Session, username: str, password: str) -> Optional[str]:
    """
    Validate username and password against database, return role if valid.

    Args:
        db: Database session
        username: The username
        password: The password (plaintext, will be verified against hash)

    Returns:
        Role string if credentials are valid, None if invalid
    """
    # Query the users table for this username
{% if uses_default_db %}
    statement = select(User).where(User.email == username)
{% else %}
    statement = select(User).where(User.login_identifier == username)
{% endif %}
    user = db.exec(statement).first()

    if user is None:
        return None

    # Both default and BYODB use property accessors (password_hash, role)
    stored_hash = user.password_hash
    role = user.role

    # Verify password
    if not verify_password(password, stored_hash):
        return None

    return role


def validate_basic_credentials(db: Session, username: str, password: str) -> Optional[tuple]:
    """
    Validate Basic auth credentials and return (user_id, role) if valid.
    This is for use in WebSocket handlers where the full user info is needed.

    Args:
        db: Database session
        username: The username
        password: The password (plaintext)

    Returns:
        Tuple of (user_id, role) if valid, None if invalid
    """
    # Query the users table for this username
{% if uses_default_db %}
    statement = select(User).where(User.email == username)
{% else %}
    statement = select(User).where(User.login_identifier == username)
{% endif %}
    user = db.exec(statement).first()

    if user is None:
        return None

    # Verify password
    if not verify_password(password, user.password_hash):
        return None

    return (user.id, user.role)


# ============================================================================
# Token Payload (compatible interface with JWT auth)
# ============================================================================

class TokenPayload:
    """Basic auth payload - compatible interface with JWT TokenPayload"""

    def __init__(self, user_id: str, roles: List[str]):
        self.user_id = user_id  # The username
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """Check if user has a specific role"""
        return role in self.roles

    def has_any_role(self, roles: List[str]) -> bool:
        """Check if user has any of the specified roles"""
        return any(self.has_role(role) for role in roles)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    credentials: HTTPBasicCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from HTTP Basic auth.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    role = validate_credentials(db, credentials.username, credentials.password)

    if role is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password",
            headers={"WWW-Authenticate": "Basic"},
        )

    return TokenPayload(user_id=credentials.username, roles=[role])


async def get_optional_user(
    request: Request,
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no credentials).

    Usage:
        @app.get("/public-or-protected")
        async def route(user: Optional[TokenPayload] = Depends(get_optional_user)):
            if user:
                return {"message": f"Hello {user.user_id}"}
            return {"message": "Hello anonymous"}
    """
    import base64

    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Basic "):
        return None

    try:
        # Decode Base64 credentials
        encoded = auth_header[6:]  # Remove "Basic " prefix
        decoded = base64.b64decode(encoded).decode("utf-8")
        username, password = decoded.split(":", 1)

        role = validate_credentials(db, username, password)
        if role is None:
            return None

        return TokenPayload(user_id=username, roles=[role])
    except Exception:
        return None


def require_roles(required_roles: List[str]):
    """
    Dependency factory to require specific roles.

    Args:
        required_roles: List of roles, user must have at least one
                       Special values: "public" (no auth), "authenticated" (any valid auth)

    Returns:
        FastAPI dependency function

    Usage:
        @app.post("/admin-only", dependencies=[Depends(require_roles(["admin"]))])
        async def admin_route():
            return {"message": "Admin access granted"}
    """
    # Special case: public access (no auth required)
    if "public" in required_roles:
        async def _check_roles_or_public(
            user: Optional[TokenPayload] = Depends(get_optional_user)
        ):
            """Check if user has required roles OR allow public access"""
            if user is None:
                return None

            if not user.has_any_role(required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
                )
            return user

        return _check_roles_or_public

    # Special case: authenticated (any valid auth, no role check)
    if "authenticated" in required_roles:
        async def _check_authenticated(user: TokenPayload = Depends(get_current_user)):
            """Require valid authentication, no role check"""
            return user

        return _check_authenticated

    async def _check_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has required roles"""
        if not user.has_any_role(required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_roles


def require_all_roles(required_roles: List[str]):
    """
    Dependency factory to require ALL specified roles.

    Args:
        required_roles: List of roles, user must have ALL of them

    Returns:
        FastAPI dependency function
    """
    async def _check_all_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has all required roles"""
        missing_roles = [role for role in required_roles if not user.has_role(role)]
        if missing_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required roles: {missing_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_all_roles
