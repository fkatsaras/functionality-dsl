"""
HTTP Basic Authentication Module
Auto-generated from FDSL Auth<http> configuration with scheme: basic

Configuration:
  Type: HTTP Basic
  Roles: {{ roles }}

Users are stored in the database and validated on each request.
"""

import secrets
import base64
from typing import List, Optional

from fastapi import Depends, HTTPException, status, Request
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from sqlmodel import Session, select

from app.db.database import get_db, User, USER_ID_COLUMN, USER_PASSWORD_COLUMN, USER_ROLE_COLUMN
from app.db.password import verify_password
from app.core.auth_base import TokenPayload, create_require_roles, create_require_all_roles


# ============================================================================
# Configuration
# ============================================================================

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Security scheme
# ============================================================================

security = HTTPBasic()


# ============================================================================
# Database validation
# ============================================================================

def validate_credentials(db: Session, username: str, password: str) -> Optional[str]:
    """
    Validate username and password against database, return role if valid.

    Args:
        db: Database session
        username: The username
        password: The password (plaintext, will be verified against hash)

    Returns:
        Role string if credentials are valid, None if invalid
    """
    # Query the users table for this username
{% if uses_default_db %}
    statement = select(User).where(User.email == username)
{% else %}
    statement = select(User).where(User.login_identifier == username)
{% endif %}
    user = db.exec(statement).first()

    if user is None:
        return None

    # Both default and BYODB use property accessors (password_hash, role)
    stored_hash = user.password_hash
    role = user.role

    # Verify password
    if not verify_password(password, stored_hash):
        return None

    return role


def validate_basic_credentials(db: Session, username: str, password: str) -> Optional[tuple]:
    """
    Validate Basic auth credentials and return (user_id, role) if valid.
    This is for use in WebSocket handlers where the full user info is needed.

    Args:
        db: Database session
        username: The username
        password: The password (plaintext)

    Returns:
        Tuple of (user_id, role) if valid, None if invalid
    """
    # Query the users table for this username
{% if uses_default_db %}
    statement = select(User).where(User.email == username)
{% else %}
    statement = select(User).where(User.login_identifier == username)
{% endif %}
    user = db.exec(statement).first()

    if user is None:
        return None

    # Verify password
    if not verify_password(password, user.password_hash):
        return None

    return (user.id, user.role)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    credentials: HTTPBasicCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from HTTP Basic auth.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    role = validate_credentials(db, credentials.username, credentials.password)

    if role is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password",
            headers={"WWW-Authenticate": "Basic"},
        )

    return TokenPayload(user_id=credentials.username, roles=[role])


async def get_optional_user(
    request: Request,
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no credentials).

    Usage:
        @app.get("/public-or-protected")
        async def route(user: Optional[TokenPayload] = Depends(get_optional_user)):
            if user:
                return {"message": f"Hello {user.user_id}"}
            return {"message": "Hello anonymous"}
    """
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Basic "):
        return None

    try:
        # Decode Base64 credentials
        encoded = auth_header[6:]  # Remove "Basic " prefix
        decoded = base64.b64decode(encoded).decode("utf-8")
        username, password = decoded.split(":", 1)

        role = validate_credentials(db, username, password)
        if role is None:
            return None

        return TokenPayload(user_id=username, roles=[role])
    except Exception:
        return None


# Create role checking functions using the base factory
require_roles = create_require_roles(get_current_user, get_optional_user)
require_all_roles = create_require_all_roles(get_current_user)
