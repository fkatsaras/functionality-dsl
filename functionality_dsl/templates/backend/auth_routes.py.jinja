"""
Authentication Routes
Auto-generated from FDSL Auth configuration

Provides:
- POST /auth/register - Create new user account
- POST /auth/login - Authenticate and get JWT token
- GET /auth/me - Get current user info
"""

from typing import Optional
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from sqlmodel import Session, select

from app.db import get_db, User, hash_password, verify_password, USER_ID_COLUMN, USER_PASSWORD_COLUMN, USER_ROLE_COLUMN
from app.core.auth import create_access_token, get_current_user, TokenPayload


# ============================================================================
# Router
# ============================================================================

router = APIRouter(prefix="/auth", tags=["Authentication"])


# ============================================================================
# Request/Response Models
# ============================================================================

class RegisterRequest(BaseModel):
    """User registration request."""
    login_id: str = Field(..., description="Login identifier (email, username, etc.)")
    password: str = Field(..., min_length=8, description="Password (min 8 characters)")
    role: Optional[str] = Field(default="{{ default_role }}", description="User role")


class LoginRequest(BaseModel):
    """User login request."""
    login_id: str = Field(..., description="Login identifier (email, username, etc.)")
    password: str = Field(..., description="User password")


class TokenResponse(BaseModel):
    """JWT token response."""
    access_token: str = Field(..., description="JWT access token")
    token_type: str = Field(default="bearer", description="Token type")


class UserResponse(BaseModel):
    """User information response."""
    id: int = Field(..., description="User ID")
    login_id: str = Field(..., description="Login identifier")
    role: str = Field(..., description="User role")
    created_at: Optional[datetime] = Field(None, description="Account creation time")


class MessageResponse(BaseModel):
    """Simple message response."""
    message: str


# ============================================================================
# Routes
# ============================================================================

{% if allow_registration %}
@router.post(
    "/register",
    response_model=UserResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register new user",
    description="Create a new user account with login identifier and password.",
)
async def register(
    request: RegisterRequest,
    db: Session = Depends(get_db),
):
    """
    Register a new user account.

    - **login_id**: Unique login identifier (must be unique)
    - **password**: Password (minimum 8 characters)
    - **role**: User role (default: {{ default_role }})
    """
    # Check if user already exists
    existing = db.exec(
        select(User).where(getattr(User, USER_ID_COLUMN) == request.login_id)
    ).first()

    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="User with this login identifier already exists",
        )

    # Validate role is allowed
    allowed_roles = {{ roles }}
    if request.role and request.role not in allowed_roles:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid role. Allowed roles: {allowed_roles}",
        )

    # Create user with hashed password
{% if uses_default_db %}
    user = User(
        email=request.login_id,
        password_hash=hash_password(request.password),
        role=request.role or "{{ default_role }}",
    )
{% else %}
    user = User(**{
        USER_ID_COLUMN: request.login_id,
        USER_PASSWORD_COLUMN: hash_password(request.password),
        USER_ROLE_COLUMN: request.role or "{{ default_role }}",
    })
{% endif %}

    db.add(user)
    db.commit()
    db.refresh(user)

    return UserResponse(
        id=user.id,
        login_id=user.login_id,
        role=user.role,
        created_at=getattr(user, "created_at", None),
    )
{% endif %}


@router.post(
    "/login",
    response_model=TokenResponse,
    summary="User login",
    description="Authenticate with login identifier and password to get JWT token.",
)
async def login(
    request: LoginRequest,
    db: Session = Depends(get_db),
):
    """
    Authenticate user and return JWT token.

    - **login_id**: Login identifier
    - **password**: User password

    Returns JWT token on successful authentication.
    """
    # Find user by login identifier
    user = db.exec(
        select(User).where(getattr(User, USER_ID_COLUMN) == request.login_id)
    ).first()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Verify password
    if not verify_password(request.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Create JWT token
    access_token = create_access_token(
        user_id=str(user.id),
        roles=[user.role],
    )

    return TokenResponse(access_token=access_token)


@router.get(
    "/me",
    response_model=UserResponse,
    summary="Get current user",
    description="Get information about the currently authenticated user.",
)
async def get_me(
    current_user: TokenPayload = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    Get current authenticated user's information.

    Requires valid JWT token in Authorization header.
    """
    user = db.exec(
        select(User).where(User.id == int(current_user.user_id))
    ).first()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )

    return UserResponse(
        id=user.id,
        login_id=user.login_id,
        role=user.role,
        created_at=getattr(user, "created_at", None),
    )
