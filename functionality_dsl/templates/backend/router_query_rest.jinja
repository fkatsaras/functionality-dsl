# ========================================================================
# AUTO-GENERATED QUERY ROUTER (SIMPLIFIED)
# ========================================================================

import json
import logging
from typing import Any, Dict

from fastapi import APIRouter, HTTPException
{% if endpoint.auth and endpoint.auth.type == 'bearer' %}
from fastapi import Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
security = HTTPBearer()
{% endif %}

from app.core.http import get_http_client
from app.core.runtime.safe_eval import compile_safe, compile_safe_exec, safe_globals
from app.core.utils import resolve_headers, interpolate_url, normalize_path_value, seed_context_with_path_params


logger = logging.getLogger("fdsl.router.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ endpoint.summary or endpoint.name }}"]
)

# ============================================================================
#                          CONFIGURATION
# ============================================================================

_EXTERNAL_REST_SOURCES = [
{%- for source in rest_inputs %}
    {
        "entity": "{{ source.entity }}",
        "alias": "{{ source.alias }}",
        "url": "{{ source.url }}",
        "headers": {{ source.headers }},
        "method": "{{ source.method }}",
        "attrs": [
        {%- for attr in source.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ]
    },
{%- endfor %}
]

_INTERNAL_DEPENDENCIES = [
{%- for dep in computed_parents | default([], true) %}
    {"name": "{{ dep.name }}", "endpoint": "{{ dep.endpoint }}/"},
{%- endfor %}
]

_COMPUTATION_CHAIN = [
{%- for step in compiled_chain %}
    {
        "name": "{{ step.name }}",
        "attrs": [
        {%- for attr in step.attrs %}
            {"name": "{{ attr.name }}", "expr": {{ attr.pyexpr | tojson }}},
        {%- endfor %}
        ],
        {%- if step.validations %}
        "validations": [
        {%- for validation in step.validations %}
            {"attribute": "{{ validation.attribute }}", "pyexpr": {{ validation.pyexpr | tojson }}},
        {%- endfor %}
        ],
        {%- endif %}
    },

{%- endfor %}
]

{% set pparams = endpoint.path_params or [] %}
@router.get("", response_model=Dict[str, Any])
async def query_{{ endpoint.name | lower }}(
    {% for p in pparams %}{{ p }}: str{% if not loop.last %}, {% endif %}{% endfor %}
    {% if endpoint.auth and endpoint.auth.kind == 'bearer' %}credentials: HTTPAuthorizationCredentials = Depends(security){% endif %}
    ):
    """
    Query endpoint for {{ entity.name }}.
    Aggregates data from external sources and internal dependencies,
    then computes the final entity attributes.
    """
    http_client = get_http_client()
    context: Dict[str, Any] = {}

    # ----------------------------------------------------------------
    # STEP 0: Enforce Auth / Seed context with path parameters
    # ----------------------------------------------------------------
    {% if endpoint.auth %}
    {% if endpoint.auth.kind == 'bearer' %}
    if not credentials or not credentials.credentials:
        raise HTTPException(status_code=401, detail="Missing bearer token")
    {% elif endpoint.auth.kind == 'basic' %}
    # Example: Expect Basic auth from request headers
    # (FastAPI automatically handles this if using HTTPBasic)
    pass
    {% elif endpoint.auth.kind == 'api_key' and endpoint.auth.location == 'header' %}
    # Will be validated automatically through request headers
    pass
    {% elif endpoint.auth.kind == 'api_key' and endpoint.auth.location == 'query' %}
    # Optionally extract from query params if needed
    pass
    {% endif %}
    {% endif %}

    {% if pparams|length %}
    context = seed_context_with_path_params(
        context=context,
        endpoint_name="{{ endpoint.name }}",
        endpoint_params={
          {% for p in pparams %}
          "{{ p }}": {{ p }}{% if not loop.last %}, {% endif %}
          {% endfor %}
        },
        external_sources=_EXTERNAL_REST_SOURCES,
        logger=logger,
    )

    logger.debug(
        f"[CONTEXT] - Seeded path parameters globally: {list(context['{{ endpoint.name }}'].keys())}"
    )
    {% endif %}

    try:
        # ----------------------------------------------------------------
        # STEP 1: Fetch external REST sources
        # ----------------------------------------------------------------
        for source_config in _EXTERNAL_REST_SOURCES:
            entity_name = source_config["entity"]
            source_alias = source_config["alias"]
            url = source_config["url"]
            url = interpolate_url(url, context)
            method = source_config["method"]
            
            logger.info(f"[FETCH] - Fetching {entity_name} from {url} ({method})")
            
            try:
                # Prepare headers
                headers = resolve_headers(source_config.get("headers", []))

                # Inject API key query params if necessary
                for key, value in source_config.get("headers", []):
                    if key == "__queryparam__":
                        separator = "&" if "?" in url else "?"
                        url = f"{url}{separator}{value}"
                
                # Make request
                response = await http_client.request(method, url, headers=headers)
                
                if response.status_code >= 400:
                    logger.error(f"[FETCH] - Failed to fetch {entity_name}: HTTP {response.status_code}")
                    raise HTTPException(
                        status_code=502,
                        detail=f"External source {entity_name} returned {response.status_code}"
                    )
                
                raw_payload = response.json()
                logger.debug(f"[FETCH] - {entity_name} payload type: {type(raw_payload)}")

                # Store raw payload by alias (merge with path params if they exist)
                # Check if source context already exists (from path params seeding)
                has_path_params = source_alias in context and isinstance(context[source_alias], dict) and context[source_alias]

                if has_path_params:
                    # Merge response data into source context (preserving path params)
                    if isinstance(raw_payload, dict):
                        context[source_alias].update(raw_payload)
                    else:
                        # Non-dict response (list, etc.), store as special key
                        context[source_alias]["_response"] = raw_payload
                else:
                    # No path params, just store raw payload directly
                    context[source_alias] = raw_payload
                
                # Log raw payload preview
                logger.debug(f"[FETCH] - {source_alias} raw payload preview:")
                try:
                    preview = json.dumps(raw_payload, indent=2)[:800]
                    logger.debug(preview + ("..." if len(preview) == 800 else ""))
                except Exception as e:
                    logger.debug(f"[FETCH] - Could not serialize raw payload: {e}")
                
                # Shape the data by evaluating attribute expressions
                shaped_data: Dict[str, Any] = {}
                
                for attr_config in source_config.get("attrs", []):
                    attr_name = attr_config["name"]
                    attr_expr = attr_config["expr"]
                    
                    try:
                        compiled_expr = compile_safe(attr_expr)
                        # CRITICAL: Merge context into globals so lambdas can access entity references
                        eval_globals = {**safe_globals, **context}
                        shaped_data[attr_name] = eval(compiled_expr, eval_globals, {})
                        logger.debug(f"[SHAPE] - {entity_name}.{attr_name} computed successfully")
                    except HTTPException:
                        raise 
                    except Exception as eval_error:
                        logger.error(f"[SHAPE] - Error computing {entity_name}.{attr_name}: {eval_error}", exc_info=True)
                        raise HTTPException(
                            status_code=500,
                            detail=f"Failed to compute {entity_name}.{attr_name}"
                        )
                
                # Default to raw payload if no attributes specified
                if not shaped_data:
                    shaped_data = {"raw": raw_payload}
                
                # Store shaped entity in context
                context[entity_name] = shaped_data
                logger.info(f"[CONTEXT] - Stored {entity_name} with keys: {list(shaped_data.keys())}")
                
            except HTTPException:
                raise
            except Exception as fetch_error:
                logger.error(f"[FETCH] - Unexpected error fetching {entity_name}: {fetch_error}", exc_info=True)
                raise HTTPException(
                    status_code=502,
                    detail=f"Failed to fetch external source: {entity_name}"
                )

        # ----------------------------------------------------------------
        # STEP 2: Fetch internal computed dependencies
        # ----------------------------------------------------------------
        for dependency in _INTERNAL_DEPENDENCIES:
            entity_name = dependency["name"]
            endpoint_path = dependency["endpoint"]

            logger.info(f"[DEPENDENCY] - Fetching computed parent {entity_name} from {endpoint_path}")

            try:
                response = await http_client.get(f"http://{{ server.host }}:{{ server.port }}{endpoint_path}")

                if response.status_code >= 400:
                    logger.error(f"[DEPENDENCY] - Failed to fetch {entity_name}: HTTP {response.status_code}")
                    raise HTTPException(
                        status_code=502,
                        detail=f"Internal dependency {entity_name} returned {response.status_code}"
                    )

                payload = response.json()

                # Unwrap single-key envelope { "<EntityName>": <data> } if present
                if isinstance(payload, dict) and entity_name in payload and len(payload) == 1:
                    context[entity_name] = payload[entity_name]
                    logger.debug(
                        f"[DEPENDENCY] - Unwrapped envelope for {entity_name}; "
                        f"type={type(payload[entity_name]).__name__}"
                    )
                else:
                    # Store as-is (dict, list, scalar).
                    context[entity_name] = payload
                    logger.debug(
                        f"[DEPENDENCY] - Stored {entity_name} as-is; "
                        f"type={type(payload).__name__}"
                    )

                logger.info(f"[CONTEXT] - Stored computed parent {entity_name}")

            except HTTPException:
                raise
            except Exception as dep_error:
                logger.error(f"[DEPENDENCY] - Unexpected error fetching {entity_name}: {dep_error}", exc_info=True)
                raise HTTPException(
                    status_code=502,
                    detail=f"Failed to fetch internal dependency: {entity_name}"
                )

        # ----------------------------------------------------------------
        # STEP 3: Execute computation chain
        # ----------------------------------------------------------------
        logger.debug("[CONTEXT] - Current context before computation chain:")
        try:
            preview = json.dumps({k: type(v).__name__ for k, v in context.items()}, indent=2)
            logger.debug(preview)
        except Exception as e:
            logger.debug(f"[CONTEXT] - Could not serialize context: {e}")

        logger.info(f"[COMPUTE] - Executing chain with {len(_COMPUTATION_CHAIN)} step(s)")
        
        for step_index, compute_step in enumerate(_COMPUTATION_CHAIN, 1):
            entity_name = compute_step["name"]
            logger.debug(f"[COMPUTE] - Step {step_index}/{len(_COMPUTATION_CHAIN)}: {entity_name}")
            
            shaped_data = {}
            
            for attr_config in compute_step.get("attrs", []):
                attr_name = attr_config["name"]
                attr_expr = attr_config["expr"]
                
                try:
                    compiled_expr = compile_safe(attr_expr)
                    # CRITICAL: Merge context into globals so lambdas can access entity references
                    eval_globals = {**safe_globals, **context}
                    shaped_data[attr_name] = eval(compiled_expr, eval_globals, {})
                    logger.debug(f"[COMPUTE] - {entity_name}.{attr_name} computed")
                except HTTPException:
                    raise 
                except Exception as compute_error:
                    logger.error(f"[COMPUTE] - Error computing {entity_name}.{attr_name}: {compute_error}", exc_info=True)
                    raise HTTPException(
                        status_code=500,
                        detail=f"Failed to compute {entity_name}.{attr_name}"
                    )
            
            context[entity_name] = shaped_data
            logger.debug(f"[CONTEXT] - Stored computation result: {entity_name}")

            # Execute @validate() clauses for this entity (runtime validation)
            if compute_step.get("validations"):
                for validation in compute_step["validations"]:
                    try:
                        eval_globals = {**safe_globals, **context}
                        exec(compile_safe_exec(validation["pyexpr"]), eval_globals, {})
                        logger.debug(f"[VALIDATION] - {entity_name}.{validation['attribute']} passed")
                    except HTTPException:
                        raise  # Preserve status code and message from @validate()
                    except Exception as validation_error:
                        logger.error(f"[VALIDATION] - {entity_name} validation failed: {validation_error}", exc_info=True)
                        raise HTTPException(status_code=400, detail={"error": str(validation_error)})

        # ----------------------------------------------------------------
        # STEP 4: Return final entity
        # ----------------------------------------------------------------
        final_entity_name = "{{ entity.name }}"
        final_attributes = context.get(final_entity_name, {})
        
        logger.info(f"[SUCCESS] - Query {final_entity_name} completed successfully")
        logger.debug(f"[RESULT] - Attributes: {list(final_attributes.keys())}")
        
        return final_attributes

    except HTTPException:
        raise
    except Exception as unexpected_error:
        logger.exception(f"[ERROR] - Unexpected error in query {{ entity.name }}: {unexpected_error}")
        raise HTTPException(status_code=500, detail="Internal server error")