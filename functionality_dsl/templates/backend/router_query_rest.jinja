from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any
import logging

from app.core.http import get_http_client
from app.core.computed import compile_safe, safe_globals
from app.core.utils import resolve_headers

logger = logging.getLogger("fdsl.router.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ endpoint.summary or endpoint.name }}"]
)

# REST input sources (external APIs) for PARENT ENTITIES
# Each entry includes the parent's attributes as expressions to evaluate
_REST_INPUTS = [
{%- for it in rest_inputs %}
    {
        "entity": "{{ it.entity }}",   # e.g. RealObjectsRaw
        "alias":  "{{ it.alias }}",    # e.g. RealObjects (or parent entity name)
        "url": "{{ it.url }}",
        "headers": {{ it.headers }},
        "method": "{{ (it.method or 'GET')|upper }}",
        "attrs": [
        {%- for a in it.attrs %}
            {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
        {%- endfor %}
        ]
    },
{%- endfor %}
]

# Computed parent dependencies (internal endpoints)
_COMPUTED_PARENTS = [
{%- for parent in computed_parents | default([], true) %}
    {"name": "{{ parent.name }}", "endpoint": "{{ parent.endpoint }}/"},
{%- endfor %}
]

# Compiled attribute expressions for THIS entity

_COMPILED_ATTRS = {
{%- for attr in computed_attrs %}
    "{{ attr.name }}": compile_safe({{ attr.pyexpr | tojson }}),
{%- endfor %}
}

# Inline-computed ancestors (no ExternalREST / no InternalREST)
_INLINE_CHAIN = [
{%- for ent in inline_chain or [] %}
  {
    "name": "{{ ent.name }}",
    "attrs": [
    {%- for a in ent.attrs %}
      {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
    {%- endfor %}
    ]
  },
{%- endfor %}
]


@router.get("/", response_model=List[Dict[str, Any]])
async def {{ endpoint.name|lower }}():
    """Compute {{ entity.name }} from parent entities + external REST inputs."""
    client = get_http_client()

    try:
        # ------------------------------
        # 1) Build parent context
        # ------------------------------
        ctx: Dict[str, Any] = {}

        # ---- a) Parents with ExternalREST (treat as 'raw-like' entities)
        for ri in _REST_INPUTS:
            try:
                headers = resolve_headers(ri.get("headers") or [])

                # Apply query param injection
                url = ri["url"]
                for key, val in (ri.get("headers") or []):
                    if key == "__queryparam__":
                        sep = "&" if "?" in url else "?"
                        url = f"{url}{sep}{val}"

                response = await client.request(ri.get("method", "GET"), ri["url"], headers=headers)
                if response.status_code >= 400:
                    raise HTTPException(status_code=502, detail=f"Failed to fetch {ri['entity']}: {response.status_code}")

                payload = response.json()
                print(f"[REST-FETCH] {ri['entity']} payload type={type(payload)} keys={list(payload) if isinstance(payload, dict) else 'n/a'}")

                parent_attrs: Dict[str, Any] = {}
                for a in (ri.get("attrs") or []):
                    try:
                        compiled = compile_safe(a["expr"])
                        evaluation_context = {ri["alias"]: payload}  #  eval against alias
                        print(f"[REST-EVAL] Entity={ri['entity']} Attr={a['name']} Expr={a['expr']}")
                        value = eval(compiled, safe_globals, evaluation_context)
                        print(f"[REST-EVAL] Result type={type(value)} sample={str(value)[:200]}")
                        parent_attrs[a["name"]] = value
                    except Exception:
                        logger.error(f"Error computing parent attr {ri['entity']}.{a.get('name')}", exc_info=True)
                        raise HTTPException(status_code=500, detail=f"Computation error in parent {ri['entity']}.{a.get('name')}")

                if not parent_attrs:
                    parent_attrs = {"raw": payload}

                #  Bind under ENTITY name so downstream can do RealObjectsRaw.raw
                ctx[ri["entity"]] = parent_attrs #  bind into ctx under entity name
                logger.info(f"Fetched REST {ri['entity']}: shaped as {type(parent_attrs)}")

            except HTTPException:
                raise
            except Exception:
                logger.error(f"Error fetching {ri['name']}", exc_info=True)
                raise HTTPException(status_code=502, detail=f"Failed to fetch REST dependency: {ri['name']}")

        # ---- b) Parents that are computed (internal endpoints)
        for cp in _COMPUTED_PARENTS:
            try:
                response = await client.get(f"http://localhost:8080{cp['endpoint']}")
                if response.status_code >= 400:
                    raise HTTPException(status_code=502, detail=f"Failed to fetch computed parent {cp['name']}: {response.status_code}")

                parent_json = response.json()

                # Contract: internal routers return list[dict]; merge into a single dict
                if isinstance(parent_json, list):
                    merged: Dict[str, Any] = {}
                    for item in parent_json:
                        if isinstance(item, dict):
                            merged.update(item)
                        else:
                            merged.setdefault("value", item)
                    ctx[cp["name"]] = merged
                elif isinstance(parent_json, dict):
                    ctx[cp["name"]] = parent_json
                else:
                    ctx[cp["name"]] = {"value": parent_json}

                logger.info(f"Fetched computed parent {cp['name']}: shaped as {type(ctx[cp['name']])}")

            except HTTPException:
                raise
            except Exception:
                logger.error(f"Error fetching computed parent {cp['name']}", exc_info=True)
                raise HTTPException(status_code=502, detail=f"Failed to fetch computed dependency: {cp['name']}")

        # ---- c) Inline-compute computed-only ancestors into ctx
        for ent in _INLINE_CHAIN:
            shaped = {}
            eval_ctx = {"ctx": ctx}
            for a in (ent.get("attrs") or []):
                compiled = compile_safe(a["expr"])
                shaped[a["name"]] = eval(compiled, safe_globals, eval_ctx)
            ctx[ent["name"]] = shaped
            
        # ------------------------------
        # 2) Evaluate THIS entity's attributes
        # ------------------------------
        computed_attrs: Dict[str, Any] = {}
        # NOTE: We do NOT set a top-level 'response' here (ambiguity).
        # Current entity expressions should refer to parents via 'ctx', e.g., ctx['RealObjectsRaw']['raw']
        evaluation_context = {"ctx": ctx}
        for ri in _REST_INPUTS:
            alias = ri["alias"]
            # expose alias directly in eval context (ExternalREST semantics)
            evaluation_context[alias] = ctx.get(ri["entity"], {})

        for attr_name, compiled_expr in _COMPILED_ATTRS.items():
            try:
                result = eval(compiled_expr, safe_globals, evaluation_context)
                computed_attrs[attr_name] = result
                logger.debug(f"Computed {attr_name}: {type(result)}")
            except Exception:
                logger.error(f"Error computing attribute {attr_name}", exc_info=True)
                raise HTTPException(status_code=500, detail=f"Computation error: {attr_name}")

        # Pretty debug
        print("\n" * 8)
        print(f"Computed Entity {{ entity.name }} returns this data:")
        print([computed_attrs])
        print("\n" * 8)

        # Contract: list[dict]
        return [computed_attrs]

    except HTTPException:
        raise
    except Exception:
        logger.exception(f"Error computing {{ entity.name }}")
        raise HTTPException(status_code=500, detail="Internal server error")