# Auto-generated WebSocket listener for {{ (entity.name if entity is defined else ws.name) }}
import asyncio
import json
import websockets
import logging
import contextlib

from contextlib import asynccontextmanager
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from typing import Any, Dict, Optional, Set

from app.core.utils import resolve_headers

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ws.{{ (entity.name if entity is defined else ws.name) | lower }}")
logger.setLevel(logging.INFO)

{% if entity is defined %}
  {% set hdrs = entity.source.headers | default([], true) %}
{% else %}
  {% set hdrs = ws.headers | default([], true) %}
{% endif %}

_subprotocols = {{ (ws.subprotocols | default([], true)) | tojson }}

_latest: Dict[str, Any] = {"value": None}
_task: Optional[asyncio.Task] = None

# ---- Downstream browser clients
_clients: Set[WebSocket] = set()
_clients_lock = asyncio.Lock()

# ---- In-process subscribers (other routers/services in this backend)
_subscribers: Set[asyncio.Queue] = set()
_subs_lock = asyncio.Lock()

def subscribe(maxsize: int = 1) -> asyncio.Queue:
    """
    Register an in-process subscriber. Returns an asyncio.Queue that receives
    new payloads as they arrive. Caller must call unsubscribe(q) on teardown.
    """
    q: asyncio.Queue = asyncio.Queue(maxsize=maxsize)
    async def _add():
        async with _subs_lock:
            _subscribers.add(q)
    asyncio.get_event_loop().create_task(_add())
    return q

async def unsubscribe(q: asyncio.Queue):
    async with _subs_lock:
        _subscribers.discard(q)

async def _notify_subscribers(msg: Any):
    dead = []
    async with _subs_lock:
        for q in list(_subscribers):
            try:
                q.put_nowait(msg)
            except asyncio.QueueFull:
                # drop oldest to make room for latest
                try:
                    _ = q.get_nowait()
                except Exception:
                    pass
                with contextlib.suppress(Exception):
                    q.put_nowait(msg)

async def _broadcast(msg: Any):
    """Send msg to browser WebSocket clients; drop broken ones."""
    dead: list[WebSocket] = []
    async with _clients_lock:
        for ws in list(_clients):
            try:
                {% if ws.protocol == "json" %}
                await ws.send_json(msg)
                {% else %}
                await ws.send_text(msg if isinstance(msg, str) else json.dumps(msg))
                {% endif %}
            except Exception:
                dead.append(ws)
        for ws in dead:
            _clients.discard(ws)

async def _ws_loop():
    """Maintain upstream WS; update _latest; push to in-proc subscribers and browser clients."""
    while True:
        try:
            headers_list = [
                {% for h in hdrs %}
                ("{{ h.key }}", "{{ h.value }}"),
                {% endfor %}
            ]
            logger.info("Connecting to {{ ws.url }} ...")
            try:
                connect_cm = websockets.connect(
                    "{{ ws.url }}",
                    extra_headers=headers_list,
                    subprotocols=_subprotocols if _subprotocols else None,
                )
            except TypeError:
                connect_cm = websockets.connect(
                    "{{ ws.url }}",
                    additional_headers=headers_list,
                    subprotocols=_subprotocols if _subprotocols else None,
                )

            async with connect_cm as ws_conn:
                logger.info("Connected to {{ ws.url }}")
                {% if ws.subscribe is defined and ws.subscribe %}
                await ws_conn.send("""{{ ws.subscribe | trim }}""")
                logger.info("Subscribe message sent")
                {% endif %}

                async for raw in ws_conn:
                    try:
                        {% if ws.protocol == "json" %}
                        msg = json.loads(raw) if isinstance(raw, (str, bytes, bytearray)) else raw
                        {% else %}
                        msg = raw
                        {% endif %}
                        # Some providers send {"stream": "...", "data": {...}}
                        payload = msg.get("data") if isinstance(msg, dict) and "data" in msg else msg
                        _latest["value"] = payload
                        # push to in-proc and browser listeners
                        await _notify_subscribers(_latest["value"])
                        await _broadcast(_latest["value"])
                    except Exception as parse_ex:
                        logger.warning("Parse/broadcast error: %s", parse_ex)
                        _latest["value"] = raw
                        with contextlib.suppress(Exception):
                            await _notify_subscribers(_latest["value"])
                            await _broadcast(_latest["value"])
        except Exception as ex:
            logger.warning("WS error: %s", ex)
            await asyncio.sleep(1)  # backoff

@asynccontextmanager
async def _lifespan(app):
    global _task
    _task = asyncio.create_task(_ws_loop())
    try:
        yield
    finally:
        if _task:
            _task.cancel()
            with contextlib.suppress(Exception):
                await _task

router = APIRouter(
    prefix="/api/external/{{ (entity.name if entity is defined else ws.name) | lower }}",
    tags=["{{ (entity.name if entity is defined else ws.name) }}"],
    lifespan=_lifespan,
)

def _ensure_started():
    global _task
    if _task is None or _task.done():
        logger.info("Starting WS loop lazily from request handler")
        _task = asyncio.create_task(_ws_loop())

@router.get("/latest")
async def latest():
    _ensure_started()
    return _latest["value"]

@router.websocket("/stream")
async def stream(ws: WebSocket):
    await ws.accept()
    async with _clients_lock:
        _clients.add(ws)
    try:
        _ensure_started()
        cur = _latest.get("value")
        if cur is not None:
            {% if ws.protocol == "json" %}
            await ws.send_json(cur)
            {% else %}
            await ws.send_text(cur if isinstance(cur, str) else json.dumps(cur))
            {% endif %}
        # keep open; we don't expect client messages
        while True:
            await ws.receive_text()
    except WebSocketDisconnect:
        pass
    finally:
        async with _clients_lock:
            _clients.discard(ws)
