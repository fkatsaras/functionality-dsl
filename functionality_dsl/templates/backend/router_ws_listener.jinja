# Auto-generated WebSocket listener for {{ (entity.name if entity is defined else ws.name) }}
import asyncio
import json
import websockets
import logging
import contextlib

from contextlib import asynccontextmanager
from fastapi import APIRouter
from typing import Any, Dict, Optional

from app.core.utils import resolve_headers

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ws.{{ (entity.name if entity is defined else ws.name) | lower }}")
logger.setLevel(logging.INFO)

{% if entity is defined %}
  {% set hdrs = entity.source.headers | default([], true) %}
{% else %}
  {% set hdrs = ws.headers | default([], true) %}
{% endif %}

# Subprotocols come from FDSL (e.g., ["token","API_KEY"])
_subprotocols = {{ (ws.subprotocols | default([], true)) | tojson }}

_latest: Dict[str, Any] = {"value": None}
_task: Optional[asyncio.Task] = None

async def _ws_loop():
    while True:
        try:
            headers_list = [
                {% for h in hdrs %}
                ("{{ h.key }}", "{{ h.value }}"),
                {% endfor %}
            ]
            logger.info("Connecting to {{ ws.url }} ...")

            # websockets>=10 accepts extra_headers=; some older builds accept additional_headers=
            try:
                connect_cm = websockets.connect(
                    "{{ ws.url }}",
                    extra_headers=headers_list,
                    subprotocols=_subprotocols if _subprotocols else None,
                )
            except TypeError:
                connect_cm = websockets.connect(
                    "{{ ws.url }}",
                    additional_headers=headers_list,
                    subprotocols=_subprotocols if _subprotocols else None,
                )

            async with connect_cm as ws_conn:
                logger.info("Connected to {{ ws.url }}")
                {% if ws.subscribe is defined and ws.subscribe %}
                await ws_conn.send("""{{ ws.subscribe | trim }}""")
                logger.info("Subscribe message sent")
                {% endif %}
                async for raw in ws_conn:
                    try:
                        {% if ws.protocol == "json" %}
                        _latest["value"] = json.loads(raw)
                        {% else %}
                        _latest["value"] = raw
                        {% endif %}
                    except Exception as parse_ex:
                        logger.warning("Parse error: %s", parse_ex)
                        _latest["value"] = raw
        except Exception as ex:
            logger.warning("WS error: %s", ex)
            await asyncio.sleep(1)

@asynccontextmanager
async def _lifespan(app):
    global _task
    _task = asyncio.create_task(_ws_loop())
    try:
        yield
    finally:
        if _task:
            _task.cancel()
            with contextlib.suppress(Exception):
                await _task

router = APIRouter(
    prefix="/api/external/{{ (entity.name if entity is defined else ws.name) | lower }}",
    tags=["{{ (entity.name if entity is defined else ws.name) }}"],
    lifespan=_lifespan,
)

def _ensure_started():
    global _task
    if _task is None or _task.done():
        logger.info("Starting WS loop lazily from request handler")
        _task = asyncio.create_task(_ws_loop())

@router.get("/latest")
async def latest():
    _ensure_started()
    return _latest["value"]