# router_ws_duplex.jinja
import uuid
import json
import logging
import asyncio
import websockets
from typing import Any, Dict, Optional, List
from fastapi import APIRouter, WebSocket, WebSocketDisconnect

from app.core.computed import compile_safe, safe_globals
from app.core.logging import set_request_id
from app.core import wsbus

logger = logging.getLogger("fdsl.router.ws.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ (endpoint.summary or endpoint.name) ~ ' (duplex)' }}"]
)

# === External WS targets (optional persistence/integration layer) ===
_EXTERNAL_TARGETS = [
{%- for tgt in external_targets %}
    {
        "url": "{{ tgt.url }}",
        "headers": {{ tgt.headers }},
        "subprotocols": {{ (tgt.subprotocols or []) | tojson }},
        "protocol": "{{ tgt.protocol or 'json' }}"
    },
{%- endfor %}
]

# === External WS sources for inbound (listen) ===
# NOTE: `endpoint` is the *endpoint name* to seed in eval context.
_WS_INPUTS = [
{%- for w in ws_inputs %}
    {
        "entity": "{{ w.entity }}",
        "endpoint": "{{ w.endpoint }}",
        "url": "{{ w.url }}",
        "headers": {{ w.headers }},
        "subprotocols": {{ (w.subprotocols or []) | tojson }},
        "protocol": "{{ w.protocol or 'json' }}",
        "attrs": {{ w.attrs | tojson }}
    },
{%- endfor %}
]

# === Compiled inbound entity chain (External → Internal) ===
_COMPILED_CHAIN_INBOUND = [
{%- for ent in compiled_chain_inbound %}
  {
    "name": "{{ ent.name }}",
    "attrs": [
    {%- for a in ent.attrs %}
      {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
    {%- endfor %}
    ]
  },
{%- endfor %}
]

# === Compiled outbound entity chain (Internal → External) ===
_COMPILED_CHAIN_OUTBOUND = [
{%- for ent in compiled_chain_outbound %}
  {
    "name": "{{ ent.name }}",
    "attrs": [
    {%- for a in ent.attrs %}
      {"name": "{{ a.name }}", "expr": {{ a.pyexpr | tojson }}},
    {%- endfor %}
    ]
  },
{%- endfor %}
]

# Persistent external connections (for publish forwarding)
_target_connections: List[Optional[Any]] = [None] * len(_EXTERNAL_TARGETS)
_target_lock = asyncio.Lock()


async def _ensure_target_connection(idx: int):
    if idx >= len(_EXTERNAL_TARGETS):
        return
    tgt = _EXTERNAL_TARGETS[idx]
    async with _target_lock:
        if _target_connections[idx] is not None:
            try:
                await _target_connections[idx].ping()
                return
            except Exception:
                _target_connections[idx] = None
        try:
            _target_connections[idx] = await websockets.connect(
                tgt["url"],
                extra_headers=tgt["headers"] or [],
                subprotocols=tgt["subprotocols"] or None
            )
            logger.info("target_connected", extra={"url": tgt["url"]})
        except Exception as ex:
            logger.error("target_connect_failed", extra={"url": tgt["url"], "err": repr(ex)})


def _compute_row(payload, sender_id, chain, source_name):
    ctx = {"ctx": {}, "__sender": sender_id}
    eval_ctx = {"ctx": ctx, source_name: payload}

    for ent in chain:
        shaped = {}
        ctx[ent["name"]] = shaped
        eval_ctx[ent["name"]] = shaped

        for a in ent.get("attrs") or []:
            compiled = compile_safe(a["expr"])
            try:
                shaped[a["name"]] = eval(compiled, safe_globals, eval_ctx)
            except Exception as ex:
                # Instead of swallowing:
                logger.exception(
                    "attr_eval_error",
                    extra={
                        "entity": ent["name"],
                        "attr": a["name"],
                        "expr": a["expr"],
                        "payload": payload,
                        "ctx": ctx,
                    },
                )
                raise   # <---- propagate error so you see it in console

        # shaped is now populated, already in eval_ctx
        print("\n" * 5)
        print("compute_start", str({"payload": payload, "source": source_name}))
        print("compute_entity", str({"entity": ent["name"], "shaped": shaped}))
        print("compute_done", str({"ctx": ctx}))
        print("\n" * 5)

    return ctx[chain[-1]["name"]] if chain else {source_name: payload}

            

async def _forward_to_targets(row: Dict[str, Any]):
    for idx, tgt in enumerate(_EXTERNAL_TARGETS):
        logger.debug("forward_row", extra={"target": tgt["url"], "row": row})
        await _ensure_target_connection(idx)
        conn = _target_connections[idx]
        if conn:
            try:
                if tgt["protocol"] == "json":
                    await conn.send(json.dumps(row))
                elif tgt["protocol"] == "text":
                    await conn.send(str(row))
                else:
                    await conn.send(json.dumps(row))
            except Exception as ex:
                logger.error("target_forward_failed", extra={"url": tgt["url"], "err": repr(ex)})
                _target_connections[idx] = None


@router.websocket("/duplex")
async def duplex(ws: WebSocket):
    print(">>> duplex handler entered")
    rid = uuid.uuid4().hex
    set_request_id(rid)
    await ws.accept()
    print(">>> ws accepted")
    logger.info("client_connected", extra={"rid": rid, "path": str(ws.url)})

    inbound_entity  = "{{ entity_in.name if entity_in else (compiled_chain_inbound[0].name if compiled_chain_inbound else '') }}"
    outbound_entity = "{{ entity_out.name if entity_out else (compiled_chain_outbound[-1].name if compiled_chain_outbound else '') }}"


    # internal buses
    bus_in  = wsbus.get_bus(inbound_entity)
    bus_out = wsbus.get_bus(outbound_entity)

    # The internal endpoint name is the outbound *source* name
    outbound_source_name = "{{ endpoint.name }}"

    async def inbound_loop():
        # CLIENT → SERVER: use OUTBOUND chain (what client sends OUT)
        while True:
            raw = await ws.receive_text()
            print(">>> got message:", raw)
            try:
                payload = json.loads(raw)
            except Exception:
                payload = raw

            # FIX: seed with the internal endpoint name, use OUTBOUND chain
            row = _compute_row(payload, rid, _COMPILED_CHAIN_OUTBOUND, "{{ endpoint.name }}")

            print("\n\n" * 4)
            print("inbound_raw", str({"raw": raw, "parsed": payload}))
            print("inbound_row", str({"row": row}))
            print("\n\n" * 4)
            if row is not None:
                await bus_out.publish(row)
                if _EXTERNAL_TARGETS:
                    await _forward_to_targets(row)

    async def outbound_loop():
        # SERVER → CLIENT: subscribe to INBOUND bus
        logger.debug("outbound_subscribed", extra={"entity": inbound_entity})
        await bus_in.add_ws(ws)
        try:
            while True:
                await asyncio.sleep(1)
        finally:
            await bus_in.remove_ws(ws)

    async def upstream_loop():
        # EXTERNAL → SERVER → CLIENT: listen to external, use INBOUND chain
        
        for inp in _WS_INPUTS:
            try:
                async with websockets.connect(
                    inp["url"],
                    extra_headers=inp["headers"],
                    subprotocols=inp["subprotocols"] or None
                ) as ext_ws:
                    async for raw in ext_ws:
                        try:
                            payload = json.loads(raw)
                        except Exception:
                            payload = raw
                        # FIX: seed with the external endpoint name
                        
                        row = _compute_row(payload, rid, _COMPILED_CHAIN_INBOUND, inp["endpoint"])

                        print("upstream_raw", str({"raw": raw, "parsed": payload}))
                        print("upstream_row", str({"row": row}))
                        if row is not None:
                            await bus_in.publish(row)
            except Exception as ex:
                logger.error("upstream_failed", extra={"url": inp["url"], "err": repr(ex)})
                await asyncio.sleep(5)

    try:
        await asyncio.gather(
            inbound_loop(),
            outbound_loop(),
            upstream_loop(),
        )
    except WebSocketDisconnect:
        logger.info("client_disconnected", extra={"rid": rid})
