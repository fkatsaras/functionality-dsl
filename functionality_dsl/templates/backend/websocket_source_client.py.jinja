# ========================================================================
# AUTO-GENERATED WEBSOCKET SOURCE CLIENT: {{ source_name }}
# External WebSocket connection
# ========================================================================

import logging
import websockets
import json
from typing import AsyncIterator, Optional, Dict, Any

logger = logging.getLogger("fdsl.source.{{ source_name }}")


class {{ source_name }}Source:
    """WebSocket source client for {{ source_name }}"""

    def __init__(self):
        self.url = "{{ channel }}"
        self.connection = None
        self._connection_lock = None

    async def _ensure_connection(self):
        """Ensure WebSocket connection is established."""
        if self.connection is None:
            logger.info(f"Establishing connection to {self.url}")
            self.connection = await websockets.connect(self.url)
            logger.info(f"Connected to {self.url}")
        return self.connection

    async def subscribe(self) -> AsyncIterator[Dict[str, Any]]:
        """
        Subscribe to WebSocket feed and yield messages as dicts.
        Handles both JSON text messages and binary data.
        {% if binary_attr %}
        Binary messages are automatically wrapped as {"{{ binary_attr }}": <bytes>}.
        {% endif %}
        """
        logger.info(f"Connecting to {self.url}")

        try:
            async with websockets.connect(self.url) as websocket:
                self.connection = websocket
                logger.info(f"Connected to {self.url}")

                async for message in websocket:
                    try:
                        # Check if message is binary (bytes)
                        if isinstance(message, bytes):
                            {% if binary_attr %}
                            # Binary message - wrap in dict with entity attribute name
                            logger.debug(f"Received binary message: {len(message)} bytes")
                            yield {"{{ binary_attr }}": message}
                            {% else %}
                            # Binary message - yield raw bytes (no schema info available)
                            logger.debug(f"Received binary message: {len(message)} bytes")
                            yield message
                            {% endif %}
                        else:
                            # Text message - parse as JSON
                            data = json.loads(message)
                            logger.debug(f"Received message: {type(data)}")
                            yield data
                    except json.JSONDecodeError as e:
                        logger.error(f"Failed to parse message: {e}")
                        continue
                    except Exception as e:
                        logger.error(f"Error processing message: {e}")
                        continue

        except Exception as e:
            logger.error(f"WebSocket connection error: {e}")
            raise

    async def publish(self, message: Dict[str, Any]) -> None:
        """
        Publish message to WebSocket.
        Creates a one-shot connection if not already connected.
        """
        try:
            # For publish-only operations, use a one-shot connection
            if self.connection is None:
                async with websockets.connect(self.url) as websocket:
                    await websocket.send(json.dumps(message))
                    logger.debug(f"Published message to {self.url} (one-shot)")
            else:
                # Use existing connection (for duplex operations)
                await self.connection.send(json.dumps(message))
                logger.debug(f"Published message to {self.url}")
        except Exception as e:
            logger.error(f"Failed to publish message: {e}")
            raise

    async def close(self):
        """Close the WebSocket connection."""
        if self.connection:
            await self.connection.close()
            self.connection = None
            logger.info(f"Connection to {self.url} closed")
