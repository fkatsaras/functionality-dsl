# ========================================================================
# AUTO-GENERATED WEBSOCKET SOURCE CLIENT: {{ source_name }}
# External WebSocket connection
# ========================================================================

import logging
import websockets
import json
from typing import AsyncIterator, Optional, Dict, Any
{% if has_params %}
from urllib.parse import urlencode, urlparse, urlunparse
{% endif %}

logger = logging.getLogger("fdsl.source.{{ source_name }}")


class {{ source_name }}Source:
    """WebSocket source client for {{ source_name }}"""

    def __init__(self):
        self.base_url = "{{ channel }}"
        self.connection = None
        self._connection_lock = None
{% if has_params %}
        # Source params configuration
        self.query_params = {{ query_params }}  # Params forwarded as query string

    def _build_url(self, params: Dict[str, Any]) -> str:
        """
        Build final WebSocket URL by appending query params.

        Args:
            params: Dict of param_name -> value from client query string

        Returns:
            str: Final WebSocket URL with query params
        """
        # Collect query params to forward
        query = {}
        for param in self.query_params:
            if param in params:
                query[param] = params[param]

        if not query:
            return self.base_url

        # Parse the base URL and append query params
        parsed = urlparse(self.base_url)
        # Combine existing query string with new params
        existing_query = parsed.query
        if existing_query:
            new_query = f"{existing_query}&{urlencode(query)}"
        else:
            new_query = urlencode(query)

        # Rebuild URL with new query string
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))
{% endif %}

{% if has_params %}
    async def _ensure_connection(self, params: Dict[str, Any] = None):
        """Ensure WebSocket connection is established with params."""
        if self.connection is None:
            url = self._build_url(params or {})
            logger.info(f"Establishing connection to {url}")
            self.connection = await websockets.connect(url)
            logger.info(f"Connected to {url}")
        return self.connection

    async def subscribe(self, params: Dict[str, Any] = None) -> AsyncIterator[Dict[str, Any]]:
        """
        Subscribe to WebSocket feed and yield messages as dicts.
        Handles both JSON text messages and binary data.
        {% if binary_attr %}
        Binary messages are automatically wrapped as {"{{ binary_attr }}": <bytes>}.
        {% endif %}

        Args:
            params: Query parameters to append to WebSocket URL
        """
        url = self._build_url(params or {})
        logger.info(f"Connecting to {url}")
{% else %}
    async def _ensure_connection(self):
        """Ensure WebSocket connection is established."""
        if self.connection is None:
            logger.info(f"Establishing connection to {self.base_url}")
            self.connection = await websockets.connect(self.base_url)
            logger.info(f"Connected to {self.base_url}")
        return self.connection

    async def subscribe(self) -> AsyncIterator[Dict[str, Any]]:
        """
        Subscribe to WebSocket feed and yield messages as dicts.
        Handles both JSON text messages and binary data.
        {% if binary_attr %}
        Binary messages are automatically wrapped as {"{{ binary_attr }}": <bytes>}.
        {% endif %}
        """
        url = self.base_url
        logger.info(f"Connecting to {url}")
{% endif %}

        try:
            async with websockets.connect(url) as websocket:
                self.connection = websocket
                logger.info(f"Connected to {url}")

                async for message in websocket:
                    try:
                        # Check if message is binary (bytes)
                        if isinstance(message, bytes):
                            {% if binary_attr %}
                            # Binary message - wrap in dict with entity attribute name
                            logger.debug(f"Received binary message: {len(message)} bytes")
                            yield {"{{ binary_attr }}": message}
                            {% else %}
                            # Binary message - yield raw bytes (no schema info available)
                            logger.debug(f"Received binary message: {len(message)} bytes")
                            yield message
                            {% endif %}
                        else:
                            # Text message - parse as JSON
                            data = json.loads(message)
                            logger.debug(f"Received message: {type(data)}")
                            yield data
                    except json.JSONDecodeError as e:
                        logger.error(f"Failed to parse message: {e}")
                        continue
                    except Exception as e:
                        logger.error(f"Error processing message: {e}")
                        continue

        except Exception as e:
            logger.error(f"WebSocket connection error: {e}")
            raise

{% if has_params %}
    async def publish(self, message: Dict[str, Any], params: Dict[str, Any] = None) -> None:
        """
        Publish message to WebSocket.
        Creates a one-shot connection if not already connected.

        Args:
            message: Message to publish
            params: Query parameters to append to WebSocket URL
        """
        url = self._build_url(params or {})
        try:
            # For publish-only operations, use a one-shot connection
            if self.connection is None:
                async with websockets.connect(url) as websocket:
                    await websocket.send(json.dumps(message))
                    logger.debug(f"Published message to {url} (one-shot)")
            else:
                # Use existing connection (for duplex operations)
                await self.connection.send(json.dumps(message))
                logger.debug(f"Published message to {url}")
        except Exception as e:
            logger.error(f"Failed to publish message: {e}")
            raise
{% else %}
    async def publish(self, message: Dict[str, Any]) -> None:
        """
        Publish message to WebSocket.
        Creates a one-shot connection if not already connected.
        """
        try:
            # For publish-only operations, use a one-shot connection
            if self.connection is None:
                async with websockets.connect(self.base_url) as websocket:
                    await websocket.send(json.dumps(message))
                    logger.debug(f"Published message to {self.base_url} (one-shot)")
            else:
                # Use existing connection (for duplex operations)
                await self.connection.send(json.dumps(message))
                logger.debug(f"Published message to {self.base_url}")
        except Exception as e:
            logger.error(f"Failed to publish message: {e}")
            raise
{% endif %}

    async def close(self):
        """Close the WebSocket connection."""
        if self.connection:
            await self.connection.close()
            self.connection = None
            logger.info(f"Connection to {self.base_url} closed")
