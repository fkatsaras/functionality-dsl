"""
API Key Authentication Module
Auto-generated from FDSL Server auth configuration

Configuration:
  Type: API Key
  Location: {{ location }}
  Name: {{ name }}
  Secret Env Var: {{ secret }}
  Roles: {{ roles }}

API Key Format in environment variable:
  Simple keys: key1,key2,key3
  Keys with roles: key1:admin,key2:user;editor,key3:viewer
  (colon separates key from roles, semicolon separates multiple roles)
"""

import os
from typing import List, Optional, Dict
from fastapi import Depends, HTTPException, status, Request, Query, Cookie
from fastapi.security import APIKeyHeader, APIKeyQuery


# ============================================================================
# Configuration
# ============================================================================

API_KEY_LOCATION = "{{ location }}"
API_KEY_NAME = "{{ name }}"
API_KEYS_ENV_VAR = "{{ secret }}"

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# API Key Storage
# ============================================================================

# Parse API keys from environment variable
# Format: key1,key2,key3 OR key1:role1;role2,key2:role3
_api_keys: Dict[str, List[str]] = {}

def _parse_api_keys():
    """Parse API keys from environment variable"""
    global _api_keys
    raw_keys = os.getenv(API_KEYS_ENV_VAR, "")
    if not raw_keys:
        return

    for entry in raw_keys.split(","):
        entry = entry.strip()
        if not entry:
            continue

        if ":" in entry:
            # Key with roles: key:role1;role2
            key, roles_str = entry.split(":", 1)
            roles = [r.strip() for r in roles_str.split(";") if r.strip()]
        else:
            # Key without roles - default to empty roles (authenticated only)
            key = entry
            roles = []

        _api_keys[key.strip()] = roles

# Parse on module load
_parse_api_keys()


def get_api_key_roles(api_key: str) -> Optional[List[str]]:
    """
    Validate API key and return associated roles.

    Args:
        api_key: The API key to validate

    Returns:
        List of roles if key is valid, None if invalid
    """
    return _api_keys.get(api_key)


# ============================================================================
# Security schemes
# ============================================================================

{% if location == "header" %}
# Header-based API key
api_key_header = APIKeyHeader(name=API_KEY_NAME, auto_error=False)
{% elif location == "query" %}
# Query parameter-based API key
api_key_query = APIKeyQuery(name=API_KEY_NAME, auto_error=False)
{% endif %}


# ============================================================================
# Token Payload (compatible interface with JWT auth)
# ============================================================================

class TokenPayload:
    """API Key payload - compatible interface with JWT TokenPayload"""

    def __init__(self, user_id: str, roles: List[str]):
        self.user_id = user_id  # For API keys, this is the key itself (or a hash)
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """Check if API key has a specific role"""
        return role in self.roles

    def has_any_role(self, roles: List[str]) -> bool:
        """Check if API key has any of the specified roles"""
        return any(self.has_role(role) for role in roles)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

{% if location == "header" %}
async def get_current_user(
    api_key: Optional[str] = Depends(api_key_header)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in header.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"api_key_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    roles = get_api_key_roles(api_key)
    if roles is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    # Use first 8 chars of key as user_id (for logging, don't expose full key)
    return TokenPayload(user_id=f"apikey_{api_key[:8]}...", roles=roles)


async def get_optional_user(
    api_key: Optional[str] = Depends(api_key_header)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no API key).
    """
    if not api_key:
        return None

    roles = get_api_key_roles(api_key)
    if roles is None:
        return None

    return TokenPayload(user_id=f"apikey_{api_key[:8]}...", roles=roles)

{% elif location == "query" %}
async def get_current_user(
    api_key: Optional[str] = Depends(api_key_query)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in query param.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"api_key_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    roles = get_api_key_roles(api_key)
    if roles is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    return TokenPayload(user_id=f"apikey_{api_key[:8]}...", roles=roles)


async def get_optional_user(
    api_key: Optional[str] = Depends(api_key_query)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no API key).
    """
    if not api_key:
        return None

    roles = get_api_key_roles(api_key)
    if roles is None:
        return None

    return TokenPayload(user_id=f"apikey_{api_key[:8]}...", roles=roles)
{% endif %}


def require_roles(required_roles: List[str]):
    """
    Dependency factory to require specific roles.

    Args:
        required_roles: List of roles, user must have at least one
                       Special values: "public" (no auth), "authenticated" (any valid auth)

    Returns:
        FastAPI dependency function

    Usage:
        @app.post("/admin-only", dependencies=[Depends(require_roles(["admin"]))])
        async def admin_route():
            return {"message": "Admin access granted"}
    """
    # Special case: public access (no auth required)
    if "public" in required_roles:
        async def _check_roles_or_public(
            user: Optional[TokenPayload] = Depends(get_optional_user)
        ):
            """Check if user has required roles OR allow public access"""
            if user is None:
                return None

            if not user.has_any_role(required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
                )
            return user

        return _check_roles_or_public

    # Special case: authenticated (any valid auth, no role check)
    if "authenticated" in required_roles:
        async def _check_authenticated(user: TokenPayload = Depends(get_current_user)):
            """Require valid authentication, no role check"""
            return user

        return _check_authenticated

    async def _check_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has required roles"""
        if not user.has_any_role(required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_roles


def require_all_roles(required_roles: List[str]):
    """
    Dependency factory to require ALL specified roles.

    Args:
        required_roles: List of roles, user must have ALL of them

    Returns:
        FastAPI dependency function
    """
    async def _check_all_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has all required roles"""
        missing_roles = [role for role in required_roles if not user.has_role(role)]
        if missing_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required roles: {missing_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_all_roles
