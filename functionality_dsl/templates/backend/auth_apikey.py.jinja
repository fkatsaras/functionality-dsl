"""
API Key Authentication Module
Auto-generated from FDSL Auth<apikey> configuration

Configuration:
  Type: API Key
  Location: {{ location }}
  Name: {{ name }}
  Roles: {{ roles }}

API keys belong to users and inherit role from the user.
"""

from typing import List, Optional, Tuple
from fastapi import Depends, HTTPException, status, Cookie
from fastapi.security import APIKeyHeader, APIKeyQuery
from sqlmodel import Session, select

from app.db.database import get_db, APIKey, User


# ============================================================================
# Configuration
# ============================================================================

API_KEY_LOCATION = "{{ location }}"
API_KEY_NAME = "{{ name }}"

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Security schemes
# ============================================================================

{% if location == "header" %}
# Header-based API key
api_key_scheme = APIKeyHeader(name=API_KEY_NAME, auto_error=False)
{% elif location == "query" %}
# Query parameter-based API key
api_key_scheme = APIKeyQuery(name=API_KEY_NAME, auto_error=False)
{% elif location == "cookie" %}
# Cookie-based API key (session-like behavior)
# Note: FastAPI doesn't have APIKeyCookie, we handle it manually
{% endif %}


# ============================================================================
# Database validation
# ============================================================================

def validate_api_key(db: Session, api_key: str) -> Optional[Tuple[int, str]]:
    """
    Validate API key against database and return (user_id, role) if valid.

    Args:
        db: Database session
        api_key: The API key to validate

    Returns:
        Tuple of (user_id, role) if key is valid, None if invalid
    """
    # Query the apikeys table with user relationship
    statement = select(APIKey).where(APIKey.key == api_key)
    api_key_record = db.exec(statement).first()

    if api_key_record is None:
        return None

    # Check if key is active
    if not api_key_record.is_active:
        return None

    # Get the user to retrieve their role
    user = db.exec(select(User).where(User.id == api_key_record.user_id)).first()
    if user is None:
        return None

    return (user.id, user.role)


# ============================================================================
# Token Payload (compatible interface with JWT auth)
# ============================================================================

class TokenPayload:
    """API Key payload - compatible interface with JWT TokenPayload"""

    def __init__(self, user_id: str, roles: List[str]):
        self.user_id = user_id  # The actual user ID from the database
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """Check if user has a specific role"""
        return role in self.roles

    def has_any_role(self, roles: List[str]) -> bool:
        """Check if user has any of the specified roles"""
        return any(self.has_role(role) for role in roles)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

{% if location == "header" %}
async def get_current_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in header.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    result = validate_api_key(db, api_key)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role])


async def get_optional_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no API key).
    """
    if not api_key:
        return None

    result = validate_api_key(db, api_key)
    if result is None:
        return None

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role])

{% elif location == "query" %}
async def get_current_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in query param.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    result = validate_api_key(db, api_key)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role])


async def get_optional_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no API key).
    """
    if not api_key:
        return None

    result = validate_api_key(db, api_key)
    if result is None:
        return None

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role])

{% elif location == "cookie" %}
async def get_current_user(
    api_key: Optional[str] = Cookie(None, alias=API_KEY_NAME),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in cookie.
    This provides session-like behavior using API keys stored in cookies.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Session cookie required",
        )

    result = validate_api_key(db, api_key)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session",
        )

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role])


async def get_optional_user(
    api_key: Optional[str] = Cookie(None, alias=API_KEY_NAME),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no cookie).
    """
    if not api_key:
        return None

    result = validate_api_key(db, api_key)
    if result is None:
        return None

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role])
{% endif %}


def require_roles(required_roles: List[str]):
    """
    Dependency factory to require specific roles.

    Args:
        required_roles: List of roles, user must have at least one
                       Special values: "public" (no auth), "authenticated" (any valid auth)

    Returns:
        FastAPI dependency function

    Usage:
        @app.post("/admin-only", dependencies=[Depends(require_roles(["admin"]))])
        async def admin_route():
            return {"message": "Admin access granted"}
    """
    # Special case: public access (no auth required)
    if "public" in required_roles:
        async def _check_roles_or_public(
            user: Optional[TokenPayload] = Depends(get_optional_user)
        ):
            """Check if user has required roles OR allow public access"""
            if user is None:
                return None

            if not user.has_any_role(required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
                )
            return user

        return _check_roles_or_public

    # Special case: authenticated (any valid auth, no role check)
    if "authenticated" in required_roles:
        async def _check_authenticated(user: TokenPayload = Depends(get_current_user)):
            """Require valid authentication, no role check"""
            return user

        return _check_authenticated

    async def _check_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has required roles"""
        if not user.has_any_role(required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_roles


def require_all_roles(required_roles: List[str]):
    """
    Dependency factory to require ALL specified roles.

    Args:
        required_roles: List of roles, user must have ALL of them

    Returns:
        FastAPI dependency function
    """
    async def _check_all_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has all required roles"""
        missing_roles = [role for role in required_roles if not user.has_role(role)]
        if missing_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required roles: {missing_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_all_roles
