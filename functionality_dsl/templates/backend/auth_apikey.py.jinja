"""
API Key Authentication Module
Auto-generated from FDSL Auth<apikey> configuration

Configuration:
  Type: API Key
  Location: {{ location }}
  Name: {{ name }}
  Roles: {{ roles }}

API keys belong to users and inherit role from the user.
"""

from typing import List, Optional, Tuple

from fastapi import Depends, HTTPException, status, Cookie
from fastapi.security import APIKeyHeader, APIKeyQuery
from sqlmodel import Session, select

from app.db.database import get_db, APIKey, User
from app.core.auth_base import TokenPayload, create_require_roles, create_require_all_roles


# ============================================================================
# Configuration
# ============================================================================

API_KEY_LOCATION = "{{ location }}"
API_KEY_NAME = "{{ name }}"

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Security schemes
# ============================================================================

{% if location == "header" %}
# Header-based API key
api_key_scheme = APIKeyHeader(name=API_KEY_NAME, auto_error=False)
{% elif location == "query" %}
# Query parameter-based API key
api_key_scheme = APIKeyQuery(name=API_KEY_NAME, auto_error=False)
{% elif location == "cookie" %}
# Cookie-based API key (session-like behavior)
# Note: FastAPI doesn't have APIKeyCookie, we handle it manually
{% endif %}


# ============================================================================
# Database validation
# ============================================================================

def validate_api_key(db: Session, api_key: str) -> Optional[Tuple[int, str]]:
    """
    Validate API key against database and return (user_id, role) if valid.

    Args:
        db: Database session
        api_key: The API key to validate

    Returns:
        Tuple of (user_id, role) if key is valid, None if invalid
    """
    # Query the apikeys table with user relationship
    statement = select(APIKey).where(APIKey.key == api_key)
    api_key_record = db.exec(statement).first()

    if api_key_record is None:
        return None

    # Check if key is active
    if not api_key_record.is_active:
        return None

    # Get the user to retrieve their role
    user = db.exec(select(User).where(User.id == api_key_record.user_id)).first()
    if user is None:
        return None

    return (user.id, user.role)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

{% if location == "header" %}
async def get_current_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in header.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    result = validate_api_key(db, api_key)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role], token=api_key)


async def get_optional_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no API key).
    """
    if not api_key:
        return None

    result = validate_api_key(db, api_key)
    if result is None:
        return None

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role], token=api_key)

{% elif location == "query" %}
async def get_current_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in query param.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    result = validate_api_key(db, api_key)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "ApiKey"},
        )

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role], token=api_key)


async def get_optional_user(
    api_key: Optional[str] = Depends(api_key_scheme),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no API key).
    """
    if not api_key:
        return None

    result = validate_api_key(db, api_key)
    if result is None:
        return None

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role], token=api_key)

{% elif location == "cookie" %}
async def get_current_user(
    api_key: Optional[str] = Cookie(None, alias=API_KEY_NAME),
    db: Session = Depends(get_db)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from API key in cookie.
    This provides session-like behavior using API keys stored in cookies.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Session cookie required",
        )

    result = validate_api_key(db, api_key)
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session",
        )

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role], token=api_key)


async def get_optional_user(
    api_key: Optional[str] = Cookie(None, alias=API_KEY_NAME),
    db: Session = Depends(get_db)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no cookie).
    """
    if not api_key:
        return None

    result = validate_api_key(db, api_key)
    if result is None:
        return None

    user_id, role = result
    return TokenPayload(user_id=str(user_id), roles=[role], token=api_key)
{% endif %}


# Create role checking functions using the base factory
require_roles = create_require_roles(get_current_user, get_optional_user)
require_all_roles = create_require_all_roles(get_current_user)
