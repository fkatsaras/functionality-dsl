"""
Session Authentication Module
Auto-generated from FDSL Server auth configuration

Configuration:
  Type: Session (stateful, cookie-based)
  Cookie: {{ cookie }}
  Expiry: {{ expiry }} seconds
  Roles: {{ roles }}

This module provides:
- In-memory session store (suitable for single-server deployments)
- Login/logout endpoints for session management
- Role-based access control (RBAC) via session data
"""

import secrets
import time
from typing import List, Optional, Dict, Any
from fastapi import Depends, HTTPException, status, Response, Request, Cookie
from pydantic import BaseModel


# ============================================================================
# Configuration
# ============================================================================

SESSION_COOKIE_NAME = "{{ cookie }}"
SESSION_EXPIRY_SECONDS = {{ expiry }}

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Session Store (In-Memory)
# ============================================================================

class SessionData(BaseModel):
    """Data stored in a session"""
    user_id: str
    roles: List[str]
    created_at: float
    expires_at: float


# In-memory session store
# Note: For production with multiple servers, use Redis or database
_sessions: Dict[str, SessionData] = {}


def _generate_session_id() -> str:
    """Generate a cryptographically secure session ID"""
    return secrets.token_urlsafe(32)


def _is_session_expired(session: SessionData) -> bool:
    """Check if a session has expired"""
    return time.time() > session.expires_at


def _cleanup_expired_sessions():
    """Remove expired sessions from the store"""
    current_time = time.time()
    expired_ids = [
        sid for sid, session in _sessions.items()
        if current_time > session.expires_at
    ]
    for sid in expired_ids:
        del _sessions[sid]


# ============================================================================
# Session Management
# ============================================================================

def create_session(user_id: str, roles: List[str]) -> str:
    """
    Create a new session for a user.

    Args:
        user_id: User identifier
        roles: List of user roles

    Returns:
        Session ID (to be set as cookie)
    """
    # Cleanup old sessions periodically
    _cleanup_expired_sessions()

    session_id = _generate_session_id()
    now = time.time()

    _sessions[session_id] = SessionData(
        user_id=user_id,
        roles=roles,
        created_at=now,
        expires_at=now + SESSION_EXPIRY_SECONDS
    )

    return session_id


def get_session(session_id: str) -> Optional[SessionData]:
    """
    Get session data by session ID.

    Args:
        session_id: Session ID from cookie

    Returns:
        SessionData if valid session exists, None otherwise
    """
    session = _sessions.get(session_id)

    if session is None:
        return None

    if _is_session_expired(session):
        # Clean up expired session
        del _sessions[session_id]
        return None

    return session


def delete_session(session_id: str) -> bool:
    """
    Delete a session (logout).

    Args:
        session_id: Session ID to delete

    Returns:
        True if session was deleted, False if not found
    """
    if session_id in _sessions:
        del _sessions[session_id]
        return True
    return False


def refresh_session(session_id: str) -> bool:
    """
    Refresh session expiry time.

    Args:
        session_id: Session ID to refresh

    Returns:
        True if session was refreshed, False if not found
    """
    session = _sessions.get(session_id)
    if session and not _is_session_expired(session):
        session.expires_at = time.time() + SESSION_EXPIRY_SECONDS
        return True
    return False


# ============================================================================
# Token Payload (compatible interface with JWT auth)
# ============================================================================

class TokenPayload:
    """Session payload - compatible interface with JWT TokenPayload"""

    def __init__(self, user_id: str, roles: List[str]):
        self.user_id = user_id
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """Check if user has a specific role"""
        return role in self.roles

    def has_any_role(self, roles: List[str]) -> bool:
        """Check if user has any of the specified roles"""
        return any(self.has_role(role) for role in roles)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    request: Request,
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from session cookie.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    if not session_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated - no session cookie"
        )

    session = get_session(session_id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session"
        )

    # Refresh session on each request
    refresh_session(session_id)

    return TokenPayload(user_id=session.user_id, roles=session.roles)


async def get_optional_user(
    request: Request,
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no session).

    Usage:
        @app.get("/public-or-protected")
        async def route(user: Optional[TokenPayload] = Depends(get_optional_user)):
            if user:
                return {"message": f"Hello {user.user_id}"}
            return {"message": "Hello anonymous"}
    """
    if not session_id:
        return None

    session = get_session(session_id)
    if not session:
        return None

    refresh_session(session_id)
    return TokenPayload(user_id=session.user_id, roles=session.roles)


def require_roles(required_roles: List[str]):
    """
    Dependency factory to require specific roles.

    Args:
        required_roles: List of roles, user must have at least one

    Returns:
        FastAPI dependency function

    Usage:
        @app.post("/admin-only", dependencies=[Depends(require_roles(["admin"]))])
        async def admin_route():
            return {"message": "Admin access granted"}
    """
    # Special case: public access (no auth required)
    if "public" in required_roles:
        async def _check_roles_or_public(
            request: Request,
            session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
        ):
            """Check if user has required roles OR allow public access"""
            if not session_id:
                return None

            session = get_session(session_id)
            if not session:
                return None

            user = TokenPayload(user_id=session.user_id, roles=session.roles)
            if not user.has_any_role(required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
                )
            return user

        return _check_roles_or_public

    async def _check_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has required roles"""
        if not user.has_any_role(required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_roles


def require_all_roles(required_roles: List[str]):
    """
    Dependency factory to require ALL specified roles.

    Args:
        required_roles: List of roles, user must have ALL of them

    Returns:
        FastAPI dependency function
    """
    async def _check_all_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has all required roles"""
        missing_roles = [role for role in required_roles if not user.has_role(role)]
        if missing_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required roles: {missing_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_all_roles


# ============================================================================
# Login/Logout Request/Response Models
# ============================================================================

class LoginRequest(BaseModel):
    """Login request body"""
    user_id: str
    roles: List[str]


class LoginResponse(BaseModel):
    """Login response body"""
    user_id: str
    roles: List[str]
    message: str = "Login successful"


class LogoutResponse(BaseModel):
    """Logout response body"""
    message: str = "Logout successful"


# ============================================================================
# Login/Logout Endpoint Handlers
# ============================================================================

async def login_handler(request: LoginRequest, response: Response) -> LoginResponse:
    """
    Handle login - create session and set cookie.

    This should be mounted as:
        @app.post("/auth/login")
        async def login(request: LoginRequest, response: Response):
            return await login_handler(request, response)
    """
    # Validate roles
    invalid_roles = [r for r in request.roles if r not in DECLARED_ROLES and r != "public"]
    if invalid_roles:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid roles: {invalid_roles}. Valid roles: {DECLARED_ROLES}"
        )

    # Create session
    session_id = create_session(request.user_id, request.roles)

    # Set session cookie
    response.set_cookie(
        key=SESSION_COOKIE_NAME,
        value=session_id,
        max_age=SESSION_EXPIRY_SECONDS,
        httponly=True,  # Prevent JavaScript access
        samesite="lax",  # CSRF protection
        secure=False,  # Set to True in production with HTTPS
    )

    return LoginResponse(
        user_id=request.user_id,
        roles=request.roles
    )


async def logout_handler(
    response: Response,
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> LogoutResponse:
    """
    Handle logout - delete session and clear cookie.

    This should be mounted as:
        @app.post("/auth/logout")
        async def logout(response: Response, session_id: str = Cookie(None)):
            return await logout_handler(response, session_id)
    """
    if session_id:
        delete_session(session_id)

    # Clear the session cookie
    response.delete_cookie(key=SESSION_COOKIE_NAME)

    return LogoutResponse()


async def me_handler(user: TokenPayload = Depends(get_current_user)) -> Dict[str, Any]:
    """
    Get current user info.

    This should be mounted as:
        @app.get("/auth/me")
        async def me(user: TokenPayload = Depends(get_current_user)):
            return await me_handler(user)
    """
    return {
        "user_id": user.user_id,
        "roles": user.roles
    }
