"""
Session Authentication Module
Auto-generated from FDSL Server auth configuration

Configuration:
  Type: Session (stateful, cookie-based)
  Cookie: {{ cookie }}
  Expiry: {{ expiry }} seconds
  Roles: {{ roles }}
{% if uses_default_db %}
  Storage: PostgreSQL database (persistent, default schema)
{% elif authdb and authdb.sessions %}
  Storage: External database (persistent, mapped schema)
  Table: {{ authdb.sessions.table }}
{% else %}
  Storage: In-memory (sessions lost on restart)
  Note: For persistent sessions with external DB, add sessions config to AuthDB.
{% endif %}

This module provides:
- Session store for stateful authentication
- Login/logout endpoints for session management
- Role-based access control (RBAC) via session data
"""

{# Database-backed sessions: either default DB or BYODB with sessions config #}
{% if uses_default_db or (authdb and authdb.sessions) %}
import json
import secrets
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from fastapi import Depends, HTTPException, status, Response, Request, Cookie
from pydantic import BaseModel
from sqlmodel import Session as DBSession, select, delete

from app.db.database import get_db, SessionRecord
{% if authdb and authdb.sessions %}
from app.db.database import (
    SESSION_ID_COLUMN,
    SESSION_USER_ID_COLUMN,
    SESSION_ROLES_COLUMN,
    SESSION_EXPIRES_AT_COLUMN,
)
{% endif %}


# ============================================================================
# Configuration
# ============================================================================

SESSION_COOKIE_NAME = "{{ cookie }}"
SESSION_EXPIRY_SECONDS = {{ expiry }}

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed

{% if uses_default_db %}
# Default schema column names
_SESSION_ID_COL = "session_id"
_SESSION_USER_ID_COL = "user_id"
_SESSION_ROLES_COL = "roles"
_SESSION_EXPIRES_AT_COL = "expires_at"
{% else %}
# BYODB mapped column names
_SESSION_ID_COL = SESSION_ID_COLUMN
_SESSION_USER_ID_COL = SESSION_USER_ID_COLUMN
_SESSION_ROLES_COL = SESSION_ROLES_COLUMN
_SESSION_EXPIRES_AT_COL = SESSION_EXPIRES_AT_COLUMN
{% endif %}


# ============================================================================
# Session Data Model (for API)
# ============================================================================

class SessionData(BaseModel):
    """Data stored in a session"""
    user_id: str
    roles: List[str]
    created_at: float
    expires_at: float


def _generate_session_id() -> str:
    """Generate a cryptographically secure session ID"""
    return secrets.token_urlsafe(32)


def _cleanup_expired_sessions(db: DBSession):
    """Remove expired sessions from the database"""
    now = datetime.utcnow()
    expires_col = getattr(SessionRecord, _SESSION_EXPIRES_AT_COL)
    stmt = delete(SessionRecord).where(expires_col < now)
    db.exec(stmt)
    db.commit()


# ============================================================================
# Session Management (Database-backed)
# ============================================================================

def create_session(db: DBSession, user_id: str, roles: List[str]) -> str:
    """
    Create a new session for a user.

    Args:
        db: Database session
        user_id: User identifier
        roles: List of user roles

    Returns:
        Session ID (to be set as cookie)
    """
    # Cleanup old sessions periodically (1 in 10 chance to avoid every request)
    if secrets.randbelow(10) == 0:
        _cleanup_expired_sessions(db)

    session_id = _generate_session_id()
    now = datetime.utcnow()
    expires_at = now + timedelta(seconds=SESSION_EXPIRY_SECONDS)

{% if uses_default_db %}
    session_record = SessionRecord(
        session_id=session_id,
        user_id=user_id,
        roles=json.dumps(roles),
        created_at=now,
        expires_at=expires_at
    )
{% else %}
    # BYODB: use mapped column names
    session_record = SessionRecord(**{
        _SESSION_ID_COL: session_id,
        _SESSION_USER_ID_COL: user_id,
        _SESSION_ROLES_COL: json.dumps(roles),
        _SESSION_EXPIRES_AT_COL: expires_at,
    })
{% endif %}
    db.add(session_record)
    db.commit()

    return session_id


def get_session(db: DBSession, session_id: str) -> Optional[SessionData]:
    """
    Get session data by session ID.

    Args:
        db: Database session
        session_id: Session ID from cookie

    Returns:
        SessionData if valid session exists, None otherwise
    """
    session_id_col = getattr(SessionRecord, _SESSION_ID_COL)
    stmt = select(SessionRecord).where(session_id_col == session_id)
    record = db.exec(stmt).first()

    if record is None:
        return None

    # Check if expired (use property accessor for consistent interface)
    if datetime.utcnow() > record.expires_at:
        # Clean up expired session
        db.delete(record)
        db.commit()
        return None

{% if uses_default_db %}
    return SessionData(
        user_id=record.user_id,
        roles=json.loads(record.roles),
        created_at=record.created_at.timestamp(),
        expires_at=record.expires_at.timestamp()
    )
{% else %}
    # BYODB: use property accessors
    return SessionData(
        user_id=record.user_id,
        roles=json.loads(record.roles),
        created_at=0.0,  # Not tracked in BYODB sessions
        expires_at=record.expires_at.timestamp()
    )
{% endif %}


def delete_session(db: DBSession, session_id: str) -> bool:
    """
    Delete a session (logout).

    Args:
        db: Database session
        session_id: Session ID to delete

    Returns:
        True if session was deleted, False if not found
    """
    session_id_col = getattr(SessionRecord, _SESSION_ID_COL)
    stmt = select(SessionRecord).where(session_id_col == session_id)
    record = db.exec(stmt).first()

    if record:
        db.delete(record)
        db.commit()
        return True
    return False


def refresh_session(db: DBSession, session_id: str) -> bool:
    """
    Refresh session expiry time.

    Args:
        db: Database session
        session_id: Session ID to refresh

    Returns:
        True if session was refreshed, False if not found
    """
    session_id_col = getattr(SessionRecord, _SESSION_ID_COL)
    stmt = select(SessionRecord).where(session_id_col == session_id)
    record = db.exec(stmt).first()

    if record and datetime.utcnow() < record.expires_at:
        # Update expires_at using the actual column name
        setattr(record, _SESSION_EXPIRES_AT_COL, datetime.utcnow() + timedelta(seconds=SESSION_EXPIRY_SECONDS))
        db.add(record)
        db.commit()
        return True
    return False


# ============================================================================
# Token Payload (compatible interface with JWT auth)
# ============================================================================

class TokenPayload:
    """Session payload - compatible interface with JWT TokenPayload"""

    def __init__(self, user_id: str, roles: List[str]):
        self.user_id = user_id
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """Check if user has a specific role"""
        return role in self.roles

    def has_any_role(self, roles: List[str]) -> bool:
        """Check if user has any of the specified roles"""
        return any(self.has_role(role) for role in roles)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    request: Request,
    db: DBSession = Depends(get_db),
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from session cookie.
    """
    if not session_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated - no session cookie"
        )

    session = get_session(db, session_id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session"
        )

    # Refresh session on each request
    refresh_session(db, session_id)

    return TokenPayload(user_id=session.user_id, roles=session.roles)


async def get_optional_user(
    request: Request,
    db: DBSession = Depends(get_db),
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no session).
    """
    if not session_id:
        return None

    session = get_session(db, session_id)
    if not session:
        return None

    refresh_session(db, session_id)
    return TokenPayload(user_id=session.user_id, roles=session.roles)


def require_roles(required_roles: List[str]):
    """
    Dependency factory to require specific roles.
    """
    # Special case: public access (no auth required)
    if "public" in required_roles:
        async def _check_roles_or_public(
            request: Request,
            db: DBSession = Depends(get_db),
            session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
        ):
            """Check if user has required roles OR allow public access"""
            if not session_id:
                return None

            session = get_session(db, session_id)
            if not session:
                return None

            user = TokenPayload(user_id=session.user_id, roles=session.roles)
            if not user.has_any_role(required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
                )
            return user

        return _check_roles_or_public

    async def _check_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has required roles"""
        if not user.has_any_role(required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_roles


def require_all_roles(required_roles: List[str]):
    """
    Dependency factory to require ALL specified roles.
    """
    async def _check_all_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has all required roles"""
        missing_roles = [role for role in required_roles if not user.has_role(role)]
        if missing_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required roles: {missing_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_all_roles


# ============================================================================
# Login/Logout Request/Response Models
# ============================================================================

class LoginRequest(BaseModel):
    """Login request body"""
    user_id: str
    roles: List[str]


class LoginResponse(BaseModel):
    """Login response body"""
    user_id: str
    roles: List[str]
    message: str = "Login successful"


class LogoutResponse(BaseModel):
    """Logout response body"""
    message: str = "Logout successful"


# ============================================================================
# Login/Logout Endpoint Handlers
# ============================================================================

async def login_handler(request: LoginRequest, response: Response, db: DBSession) -> LoginResponse:
    """
    Handle login - create session and set cookie.
    """
    # Validate roles
    invalid_roles = [r for r in request.roles if r not in DECLARED_ROLES and r != "public"]
    if invalid_roles:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid roles: {invalid_roles}. Valid roles: {DECLARED_ROLES}"
        )

    # Create session in database
    session_id = create_session(db, request.user_id, request.roles)

    # Set session cookie
    response.set_cookie(
        key=SESSION_COOKIE_NAME,
        value=session_id,
        max_age=SESSION_EXPIRY_SECONDS,
        httponly=True,  # Prevent JavaScript access
        samesite="lax",  # CSRF protection
        secure=False,  # Set to True in production with HTTPS
    )

    return LoginResponse(
        user_id=request.user_id,
        roles=request.roles
    )


async def logout_handler(
    response: Response,
    db: DBSession = Depends(get_db),
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> LogoutResponse:
    """
    Handle logout - delete session and clear cookie.
    """
    if session_id:
        delete_session(db, session_id)

    # Clear the session cookie
    response.delete_cookie(key=SESSION_COOKIE_NAME)

    return LogoutResponse()


async def me_handler(user: TokenPayload = Depends(get_current_user)) -> Dict[str, Any]:
    """
    Get current user info.
    """
    return {
        "user_id": user.user_id,
        "roles": user.roles
    }

{% else %}
# ==========================================================================
# IN-MEMORY SESSION STORAGE (for BYODB mode without sessions table)
# ==========================================================================
# Note: Sessions are stored in-memory and will be lost on server restart.
# For persistent sessions, add a 'sessions:' config to your AuthDB block.

import secrets
import time
from typing import List, Optional, Dict, Any
from fastapi import Depends, HTTPException, status, Response, Request, Cookie
from pydantic import BaseModel


# ============================================================================
# Configuration
# ============================================================================

SESSION_COOKIE_NAME = "{{ cookie }}"
SESSION_EXPIRY_SECONDS = {{ expiry }}

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Session Store (In-Memory)
# ============================================================================

class SessionData(BaseModel):
    """Data stored in a session"""
    user_id: str
    roles: List[str]
    created_at: float
    expires_at: float


# In-memory session store
# WARNING: Sessions will be lost on server restart
_sessions: Dict[str, SessionData] = {}


def _generate_session_id() -> str:
    """Generate a cryptographically secure session ID"""
    return secrets.token_urlsafe(32)


def _is_session_expired(session: SessionData) -> bool:
    """Check if a session has expired"""
    return time.time() > session.expires_at


def _cleanup_expired_sessions():
    """Remove expired sessions from the store"""
    current_time = time.time()
    expired_ids = [
        sid for sid, session in _sessions.items()
        if current_time > session.expires_at
    ]
    for sid in expired_ids:
        del _sessions[sid]


# ============================================================================
# Session Management
# ============================================================================

def create_session(user_id: str, roles: List[str]) -> str:
    """
    Create a new session for a user.
    """
    # Cleanup old sessions periodically
    _cleanup_expired_sessions()

    session_id = _generate_session_id()
    now = time.time()

    _sessions[session_id] = SessionData(
        user_id=user_id,
        roles=roles,
        created_at=now,
        expires_at=now + SESSION_EXPIRY_SECONDS
    )

    return session_id


def get_session(session_id: str) -> Optional[SessionData]:
    """
    Get session data by session ID.
    """
    session = _sessions.get(session_id)

    if session is None:
        return None

    if _is_session_expired(session):
        # Clean up expired session
        del _sessions[session_id]
        return None

    return session


def delete_session(session_id: str) -> bool:
    """
    Delete a session (logout).
    """
    if session_id in _sessions:
        del _sessions[session_id]
        return True
    return False


def refresh_session(session_id: str) -> bool:
    """
    Refresh session expiry time.
    """
    session = _sessions.get(session_id)
    if session and not _is_session_expired(session):
        session.expires_at = time.time() + SESSION_EXPIRY_SECONDS
        return True
    return False


# ============================================================================
# Token Payload (compatible interface with JWT auth)
# ============================================================================

class TokenPayload:
    """Session payload - compatible interface with JWT TokenPayload"""

    def __init__(self, user_id: str, roles: List[str]):
        self.user_id = user_id
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """Check if user has a specific role"""
        return role in self.roles

    def has_any_role(self, roles: List[str]) -> bool:
        """Check if user has any of the specified roles"""
        return any(self.has_role(role) for role in roles)


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    request: Request,
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from session cookie.
    """
    if not session_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated - no session cookie"
        )

    session = get_session(session_id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session"
        )

    # Refresh session on each request
    refresh_session(session_id)

    return TokenPayload(user_id=session.user_id, roles=session.roles)


async def get_optional_user(
    request: Request,
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no session).
    """
    if not session_id:
        return None

    session = get_session(session_id)
    if not session:
        return None

    refresh_session(session_id)
    return TokenPayload(user_id=session.user_id, roles=session.roles)


def require_roles(required_roles: List[str]):
    """
    Dependency factory to require specific roles.

    Args:
        required_roles: List of roles, user must have at least one
                       Special values: "public" (no auth), "authenticated" (any valid auth)

    Returns:
        FastAPI dependency function

    Usage:
        @app.post("/admin-only", dependencies=[Depends(require_roles(["admin"]))])
        async def admin_route():
            return {"message": "Admin access granted"}
    """
    # Special case: public access (no auth required)
    if "public" in required_roles:
        async def _check_roles_or_public(
            request: Request,
            session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
        ):
            """Check if user has required roles OR allow public access"""
            if not session_id:
                return None

            session = get_session(session_id)
            if not session:
                return None

            user = TokenPayload(user_id=session.user_id, roles=session.roles)
            if not user.has_any_role(required_roles):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
                )
            return user

        return _check_roles_or_public

    # Special case: authenticated (any valid auth, no role check)
    if "authenticated" in required_roles:
        async def _check_authenticated(user: TokenPayload = Depends(get_current_user)):
            """Require valid authentication, no role check"""
            return user

        return _check_authenticated

    async def _check_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has required roles"""
        if not user.has_any_role(required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Requires one of: {required_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_roles


def require_all_roles(required_roles: List[str]):
    """
    Dependency factory to require ALL specified roles.
    """
    async def _check_all_roles(user: TokenPayload = Depends(get_current_user)):
        """Check if user has all required roles"""
        missing_roles = [role for role in required_roles if not user.has_role(role)]
        if missing_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required roles: {missing_roles}. Your roles: {user.roles}"
            )
        return user

    return _check_all_roles


# ============================================================================
# Login/Logout Request/Response Models
# ============================================================================

class LoginRequest(BaseModel):
    """Login request body"""
    user_id: str
    roles: List[str]


class LoginResponse(BaseModel):
    """Login response body"""
    user_id: str
    roles: List[str]
    message: str = "Login successful"


class LogoutResponse(BaseModel):
    """Logout response body"""
    message: str = "Logout successful"


# ============================================================================
# Login/Logout Endpoint Handlers
# ============================================================================

async def login_handler(request: LoginRequest, response: Response) -> LoginResponse:
    """
    Handle login - create session and set cookie.
    """
    # Validate roles
    invalid_roles = [r for r in request.roles if r not in DECLARED_ROLES and r != "public"]
    if invalid_roles:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid roles: {invalid_roles}. Valid roles: {DECLARED_ROLES}"
        )

    # Create session
    session_id = create_session(request.user_id, request.roles)

    # Set session cookie
    response.set_cookie(
        key=SESSION_COOKIE_NAME,
        value=session_id,
        max_age=SESSION_EXPIRY_SECONDS,
        httponly=True,  # Prevent JavaScript access
        samesite="lax",  # CSRF protection
        secure=False,  # Set to True in production with HTTPS
    )

    return LoginResponse(
        user_id=request.user_id,
        roles=request.roles
    )


async def logout_handler(
    response: Response,
    session_id: Optional[str] = Cookie(None, alias=SESSION_COOKIE_NAME)
) -> LogoutResponse:
    """
    Handle logout - delete session and clear cookie.
    """
    if session_id:
        delete_session(session_id)

    # Clear the session cookie
    response.delete_cookie(key=SESSION_COOKIE_NAME)

    return LogoutResponse()


async def me_handler(user: TokenPayload = Depends(get_current_user)) -> Dict[str, Any]:
    """
    Get current user info.
    """
    return {
        "user_id": user.user_id,
        "roles": user.roles
    }
{% endif %}
