from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any
import logging

from app.core.http import get_http_client
from app.core.utils import resolve_headers

logger = logging.getLogger("fdsl.router.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ endpoint.summary or endpoint.name }}"]
)

_UPSTREAM_URL = "{{ entity.source.url }}"
_HEADERS = resolve_headers([
{% for h in entity.source.headers | default([], true) -%}
    ("{{ h.key }}", "{{ h.value }}"),
{% endfor -%}
])
_METHOD = "{{ (entity.source.verb or 'GET')|upper }}"

@router.get("/", response_model=List[Dict[str, Any]])
async def get_{{ endpoint.name | lower }}():
    """Fetch {{ entity.name }} from external API."""
    client = get_http_client()
    
    try:
        response = await client.request(_METHOD, _UPSTREAM_URL, headers=_HEADERS)
        
        if response.status_code >= 400:
            raise HTTPException(
                status_code=502, 
                detail=f"Upstream error: {response.status_code}"
            )
        
        data = response.json()
        logger.info(f"{{ entity.name }} fetched data: {type(data)}")

        print("\n" * 14)
        print(f"Entity {{ entity.name }} gets this data:")
        print(data)
        print("\n" * 14)
        
        # Always return as list of dicts, one dict for all declared attributes
        attrs: Dict[str, Any] = {}
        
        {% for attr in entity.attributes %}
        attrs["{{ attr.name }}"] = data
        {% endfor %}
        
        return [attrs]
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error fetching {{ entity.name }}")
        raise HTTPException(status_code=500, detail="Internal server error")