# ========================================================================
# AUTO-GENERATED REST ROUTER (Flow: {{ flow.type.upper() }})
# ========================================================================

import logging
from typing import Any, Dict, Optional, List

from fastapi import APIRouter, HTTPException, Request, Query, Header, Path
{% if response_type == 'binary' %}
from fastapi.responses import Response
{% endif %}
{% if endpoint.auth and endpoint.auth.kind == 'bearer' %}
from fastapi import Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
security = HTTPBearer()
{% endif %}

from app.services.{{ endpoint.name | lower }}_service import service
from app.core.content_handler import ContentTypeHandler

{# Import response entity Pydantic model for strict typing #}
{% if response_entity %}
from app.domain.models import {{ response_entity.name }}
{% endif %}


logger = logging.getLogger("fdsl.router.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ endpoint.summary or endpoint.name }}"]
)


{% set pparams = endpoint.path_params or [] %}
{% set pparams_typed = endpoint.path_params_typed or [] %}
{% set http_method = flow.http_method %}

{# Determine strict response model based on actual entity and type #}
{% if response_entity %}
  {% if response_type == 'binary' %}
    {# Binary type - return Response object, not Pydantic model #}
    {% set response_model = 'None' %}
    {% set response_class = 'Response' %}
  {% elif response_type == 'array' %}
    {# Array type - service unwraps single-attribute wrappers, so use List[Any] #}
    {% set response_model = 'List[Any]' %}
  {% elif response_type == 'string' %}
    {# Primitive string - service unwraps, validate as str #}
    {% set response_model = 'str' %}
  {% elif response_type == 'integer' %}
    {# Primitive integer - service unwraps, validate as int #}
    {% set response_model = 'int' %}
  {% elif response_type == 'number' %}
    {# Primitive number - service unwraps, validate as float #}
    {% set response_model = 'float' %}
  {% elif response_type == 'boolean' %}
    {# Primitive boolean - service unwraps, validate as bool #}
    {% set response_model = 'bool' %}
  {% else %}
    {# Object type - use actual Pydantic model #}
    {% set response_model = response_entity.name %}
  {% endif %}
{% else %}
  {# Fallback for endpoints without explicit response entity (legacy) #}
  {% if response_type == 'array' %}
  {% set response_model = 'List[Any]' %}
  {% elif response_type in ('string', 'integer', 'number', 'boolean') %}
  {% set response_model = 'Any' %}
  {% else %}
  {% set response_model = 'Dict[str, Any]' %}
  {% endif %}
{% endif %}

{# Helper macro to convert FDSL types to Python types #}
{% macro python_type(fdsl_type) -%}
{%- if fdsl_type.baseType == 'string' -%}str
{%- elif fdsl_type.baseType == 'integer' -%}int
{%- elif fdsl_type.baseType == 'number' -%}float
{%- elif fdsl_type.baseType == 'boolean' -%}bool
{%- else -%}str
{%- endif -%}
{%- endmacro %}

@router.{{ http_method }}(
    "",{% if response_type == 'binary' %}
    response_class={{ response_class }},
    responses={
        200: {
            "description": "Successful response",
            "content": {
                "{{ response_metadata.content_type if response_metadata else 'application/octet-stream' }}": {
                    "schema": {"type": "string", "format": "binary"}
                }
            }
        }{% if errors %},{% endif %}
        {% for error in errors %}
        {{ error.status_code }}: {
            "description": "{{ error.message }}",
            "content": {
                "application/json": {
                    "example": {"detail": "{{ error.message }}"}
                }
            }
        }{% if not loop.last %},{% endif %}
        {% endfor %}
    }{% else %}
    response_model={{ response_model }}{% if errors %},
    responses={
        {% for error in errors %}
        {{ error.status_code }}: {
            "description": "{{ error.message }}",
            "content": {
                "application/json": {
                    "example": {"detail": "{{ error.message }}"}
                }
            }
        }{% if not loop.last %},{% endif %}
        {% endfor %}
    }{% endif %}{% endif %}
)
async def {{ flow.type }}_{{ endpoint.name | lower }}(
    request: Request{% for p in pparams_typed %},
    {{ p.name }}: {{ python_type(p.type) }}{% endfor %}{% if endpoint.auth and endpoint.auth.kind == 'bearer' %},
    credentials: HTTPAuthorizationCredentials = Depends(security){% elif endpoint.auth and endpoint.auth.kind == 'api_key' %}{% if endpoint.auth.location == 'header' %},
    {{ endpoint.auth.key | replace('-', '_') | lower }}: Optional[str] = Header(None, alias="{{ endpoint.auth.key }}"){% elif endpoint.auth.location == 'query' %},
    {{ endpoint.auth.key }}: Optional[str] = Query(None){% endif %}{% endif %}
):
    """
    {{ flow.type.upper() }} endpoint for {{ entity.name }}.

    Flow Type: {{ flow.type }}
    HTTP Method: {{ http_method.upper() }}
    {% if flow.has_reads %}
    - Fetches data from {{ rest_inputs | length }} external source(s)
    {% endif %}
    {% if flow.has_writes %}
    - Writes to {{ write_targets | length }} external target(s)
    {% endif %}
    {% if compiled_chain %}
    - Computes {{ compiled_chain | length }} entity transformation(s)
    {% endif %}
    """

    # ========================================================================
    # AUTHENTICATION
    # ========================================================================
    {% if endpoint.auth %}
    {% if endpoint.auth.kind == 'bearer' %}
    if not credentials or not credentials.credentials:
        raise HTTPException(status_code=401, detail="Missing bearer token")
    {% elif endpoint.auth.kind == 'basic' %}
    # Basic auth validated automatically by FastAPI
    pass
    {% elif endpoint.auth.kind == 'api_key' %}
    # Validate API key
    {% set api_key_param = endpoint.auth.key | replace('-', '_') | lower %}
    if not {{ api_key_param }}:
        raise HTTPException(status_code=401, detail="Missing API key")
    if {{ api_key_param }} != "{{ endpoint.auth.value }}":
        raise HTTPException(status_code=403, detail="Invalid API key")
    {% endif %}
    {% endif %}

    # ========================================================================
    # FORWARD TO SERVICE LAYER
    # ========================================================================
    try:
        # Build path parameters dict
        path_params = {
            {% for p in pparams_typed %}
            "{{ p.name }}": {{ p.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }

        # Extract query params and headers for decorated attributes
        query_params = dict(request.query_params)
        headers = dict(request.headers)

        {% if http_method in ('post', 'put', 'patch') %}
        # Parse request body based on Content-Type
        content_type = request.headers.get("content-type", "application/json")
        try:
            raw_body = await request.body()
            request_body = await ContentTypeHandler.parse_request(raw_body, content_type)

            if isinstance(request_body, dict):
                logger.info(f"[REQUEST] - Received {content_type} payload with keys: {list(request_body.keys())}")
            elif isinstance(request_body, bytes):
                logger.info(f"[REQUEST] - Received binary {content_type} payload ({len(request_body)} bytes)")
            else:
                logger.info(f"[REQUEST] - Received {content_type} payload")
        except Exception as parse_error:
            logger.error(f"[REQUEST] - Failed to parse {content_type} body: {parse_error}")
            raise HTTPException(
                status_code=400,
                detail=f"Malformed request body: unable to parse {content_type}"
            )

        # Execute flow (with request body)
        {% if response_type == 'binary' %}
        result = await service.execute_flow(
            request_body=request_body,
            path_params=path_params,
            query_params=query_params,
            headers=headers
        )
        # Wrap binary response in Response object with proper media type
        return Response(content=result, media_type="{{ response_metadata.content_type if response_metadata else 'application/octet-stream' }}")
        {% else %}
        return await service.execute_flow(
            request_body=request_body,
            path_params=path_params,
            query_params=query_params,
            headers=headers
        )
        {% endif %}
        {% else %}
        # Execute flow (no request body)
        {% if response_type == 'binary' %}
        result = await service.execute_flow(
            path_params=path_params,
            query_params=query_params,
            headers=headers
        )
        # Wrap binary response in Response object with proper media type
        return Response(content=result, media_type="{{ response_metadata.content_type if response_metadata else 'application/octet-stream' }}")
        {% else %}
        return await service.execute_flow(
            path_params=path_params,
            query_params=query_params,
            headers=headers
        )
        {% endif %}
        {% endif %}

    except HTTPException:
        raise
    except Exception as unexpected_error:
        logger.exception(f"[ERROR] - Unexpected error in {{ flow.type }} endpoint {{ entity.name }}: {unexpected_error}")
        raise HTTPException(status_code=500, detail="Internal server error")
