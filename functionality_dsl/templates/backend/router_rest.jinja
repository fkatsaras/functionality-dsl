from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any
import logging

from app.core.http import get_http_client
from app.core.utils import resolve_headers

logger = logging.getLogger("fdsl.router.{{ endpoint.name }}")

router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ endpoint.summary or endpoint.name }}"]
)

_UPSTREAM_URL = "{{ entity.source.url }}"
_HEADERS = resolve_headers([
{% for h in entity.source.headers | default([], true) -%}
    ("{{ h.key }}", "{{ h.value }}"),
{% endfor -%}
])
_METHOD = "{{ (entity.source.verb or 'GET')|upper }}"

@router.get("/", response_model=List[Dict[str, Any]])
async def get_{{ endpoint.name | lower }}():
    """Fetch {{ entity.name }} from external API and normalize to list[dict]."""
    client = get_http_client()

    try:
        resp = await client.request(_METHOD, _UPSTREAM_URL, headers=_HEADERS)
        if resp.status_code >= 400:
            raise HTTPException(status_code=502, detail=f"Upstream error: {resp.status_code}")

        data = resp.json()
        logger.info(f"{{ entity.name }} fetched data: {type(data)}")

        # Single attribute entity → wrap whole payload under that key
        {%- if wrapper_attr %}
        return [ {"{{ wrapper_attr }}": data} ]
        {%- else %}

        # Multi-attribute entity → one row per attribute
        rows: List[Dict[str, Any]] = []
        if isinstance(data, dict):
            {% for attr in schema_attrs %}
            rows.append({"{{ attr }}": data.get("{{ attr }}")})
            {% endfor %}
        else:
            # If upstream isn't a dict (e.g., it's a list), put the same payload under each attribute
            {% for attr in schema_attrs %}
            rows.append({"{{ attr }}": data})
            {% endfor %}

        print("\n" * 14)
        print(f"Entity {{ entity.name }} gets this data:")
        print(data)
        print("\n" * 14)

        return rows
        {%- endif %}

    except HTTPException:
        raise
    except Exception:
        logger.exception(f"Error fetching {{ entity.name }}")
        raise HTTPException(status_code=500, detail="Internal server error")