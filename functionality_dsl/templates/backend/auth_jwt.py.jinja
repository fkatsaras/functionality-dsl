"""
HTTP Bearer Authentication Module (JWT)
Auto-generated from FDSL Auth<http> configuration with scheme: bearer

Configuration:
  Type: HTTP Bearer (JWT)
  Roles: {{ roles }}
  Header: Authorization
  Scheme: Bearer
  Algorithm: {{ algorithm }}
"""

import os
import jwt
from typing import List, Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

from app.core.auth_base import TokenPayload, create_require_roles, create_require_all_roles


# ============================================================================
# Configuration
# ============================================================================

# JWT secret: Read from environment variable
# The secret is auto-generated during code generation and stored in .env
JWT_SECRET = os.getenv("{{ secret }}")
if not JWT_SECRET:
    raise RuntimeError("JWT_SECRET environment variable '{{ secret }}' is not set. Check your .env file.")

JWT_ALGORITHM = "{{ algorithm }}"
USER_ID_CLAIM = "{{ user_id_claim }}"
ROLES_CLAIM = "{{ roles_claim }}"

# Declared roles from FDSL
DECLARED_ROLES = {{ roles }}
DECLARED_ROLES.append("public")  # Public is always allowed


# ============================================================================
# Security scheme
# ============================================================================

security = HTTPBearer(
    scheme_name="{{ scheme }}",
    description="JWT token in {{ header }} header"
)


# ============================================================================
# Token verification
# ============================================================================

def decode_token(token: str) -> TokenPayload:
    """
    Decode and verify JWT token.

    Args:
        token: JWT token string

    Returns:
        TokenPayload with user_id and roles

    Raises:
        HTTPException: If token is invalid or expired
    """
    try:
        payload = jwt.decode(
            token,
            JWT_SECRET,
            algorithms=[JWT_ALGORITHM]
        )

        user_id = payload.get(USER_ID_CLAIM)
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Token missing '{USER_ID_CLAIM}' claim",
                headers={"WWW-Authenticate": "Bearer"},
            )

        roles = payload.get(ROLES_CLAIM, [])
        if not isinstance(roles, list):
            roles = [roles]  # Handle single role as string

        return TokenPayload(user_id=user_id, roles=roles, token=token)

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidTokenError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid token: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )


# ============================================================================
# FastAPI Dependencies
# ============================================================================

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> TokenPayload:
    """
    Dependency to get current authenticated user from JWT token.

    Usage:
        @app.get("/protected")
        async def protected_route(user: TokenPayload = Depends(get_current_user)):
            return {"user_id": user.user_id, "roles": user.roles}
    """
    return decode_token(credentials.credentials)


async def get_optional_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(HTTPBearer(auto_error=False))
) -> Optional[TokenPayload]:
    """
    Dependency to optionally get current user (doesn't fail if no token).

    Usage:
        @app.get("/public-or-protected")
        async def route(user: Optional[TokenPayload] = Depends(get_optional_user)):
            if user:
                return {"message": f"Hello {user.user_id}"}
            return {"message": "Hello anonymous"}
    """
    if credentials is None:
        return None
    return decode_token(credentials.credentials)


# Create role checking functions using the base factory
require_roles = create_require_roles(get_current_user, get_optional_user)
require_all_roles = create_require_all_roles(get_current_user)


# ============================================================================
# Helper functions
# ============================================================================

def create_access_token(user_id: str, roles: List[str], expires_delta: Optional[int] = None) -> str:
    """
    Create a JWT access token.

    Args:
        user_id: User identifier
        roles: List of user roles
        expires_delta: Token expiration in seconds (default: 3600 = 1 hour)

    Returns:
        Encoded JWT token string

    Note: This is a helper for testing. In production, token creation
          should be handled by your authentication service.
    """
    import datetime

    if expires_delta is None:
        expires_delta = 3600  # 1 hour

    payload = {
        USER_ID_CLAIM: user_id,
        ROLES_CLAIM: roles,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(seconds=expires_delta),
        "iat": datetime.datetime.utcnow(),
    }

    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
