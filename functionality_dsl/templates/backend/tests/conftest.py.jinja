"""
Test configuration and fixtures.

This module provides pytest fixtures for testing the FastAPI application.
Generated by FDSL from {{ fdsl_file }}.
"""
from collections.abc import Generator
from typing import Any

import pytest
from fastapi.testclient import TestClient
{% if has_auth %}
from sqlmodel import Session, delete

from app.core.db import engine, init_db
from app.domain.models import User
{% if has_bearer_auth %}
from app.core.auth_bearer import create_access_token
{% endif %}
{% endif %}
from app.main import app


{% if has_auth %}
@pytest.fixture(scope="session", autouse=True)
def db() -> Generator[Session, None, None]:
    """Create a test database session."""
    with Session(engine) as session:
        init_db(session)
        yield session
        # Cleanup after all tests
        statement = delete(User)
        session.execute(statement)
        session.commit()


{% endif %}
@pytest.fixture(scope="module")
def client() -> Generator[TestClient, None, None]:
    """Create a test client for the FastAPI application."""
    with TestClient(app) as c:
        yield c


{% if has_auth %}
@pytest.fixture(scope="module")
def test_user_token(client: TestClient, db: Session) -> str:
    """Create a test user and return an access token."""
    from app.db.password import get_password_hash

    # Create test user
    test_email = "test@example.com"
    test_password = "testpassword123"

    # Check if user exists
    from sqlmodel import select
    statement = select(User).where(User.email == test_email)
    existing_user = db.exec(statement).first()

    if not existing_user:
        hashed_password = get_password_hash(test_password)
        user = User(
            email=test_email,
            password=hashed_password,
            role="{{ default_role }}"
        )
        db.add(user)
        db.commit()
        db.refresh(user)
    else:
        user = existing_user

    {% if has_bearer_auth %}
    # Create access token
    token = create_access_token(user_id=str(user.id), role=user.role)
    return token
    {% else %}
    # For Basic/API Key auth, return credentials
    return test_password
    {% endif %}


@pytest.fixture(scope="module")
def test_user_headers(test_user_token: str, db: Session) -> dict[str, str]:
    """Return headers with authentication token."""
    {% if has_bearer_auth %}
    return {"Authorization": f"Bearer {test_user_token}"}
    {% elif has_basic_auth %}
    import base64
    credentials = base64.b64encode(b"test@example.com:" + test_user_token.encode()).decode()
    return {"Authorization": f"Basic {credentials}"}
    {% elif has_apikey_auth %}
    # For cookie-based API key, create a session
    from app.domain.models import User, APIKey
    from sqlmodel import select
    import secrets

    # Get test user
    statement = select(User).where(User.email == "test@example.com")
    user = db.exec(statement).first()

    if not user:
        return {}

    # Create or get API key for user
    statement = select(APIKey).where(APIKey.user_id == user.id)
    existing_key = db.exec(statement).first()

    if existing_key:
        key_value = existing_key.key
    else:
        key_value = secrets.token_urlsafe(32)
        api_key = APIKey(user_id=user.id, key=key_value)
        db.add(api_key)
        db.commit()

    # Return as header or cookie depending on location
    {% if apikey_location == 'cookie' %}
    # For cookies, use TestClient.cookies instead of headers
    return {"Cookie": f"{{ apikey_header }}={key_value}"}
    {% elif apikey_location == 'query' %}
    # For query params, append to URL instead
    return {}  # Query params handled in URL
    {% else %}
    # Header-based API key
    return {"{{ apikey_header }}": key_value}
    {% endif %}
    {% endif %}


{% if admin_role %}
@pytest.fixture(scope="module")
def admin_user_token(client: TestClient, db: Session) -> str:
    """Create an admin user and return an access token."""
    from app.db.password import get_password_hash

    # Create admin user
    admin_email = "admin@example.com"
    admin_password = "adminpassword123"

    # Check if user exists
    from sqlmodel import select
    statement = select(User).where(User.email == admin_email)
    existing_user = db.exec(statement).first()

    if not existing_user:
        hashed_password = get_password_hash(admin_password)
        user = User(
            email=admin_email,
            password=hashed_password,
            role="{{ admin_role }}"
        )
        db.add(user)
        db.commit()
        db.refresh(user)
    else:
        user = existing_user

    {% if has_bearer_auth %}
    # Create access token
    token = create_access_token(user_id=str(user.id), role=user.role)
    return token
    {% else %}
    return admin_password
    {% endif %}


@pytest.fixture(scope="module")
def admin_user_headers(admin_user_token: str, db: Session) -> dict[str, str]:
    """Return headers with admin authentication token."""
    {% if has_bearer_auth %}
    return {"Authorization": f"Bearer {admin_user_token}"}
    {% elif has_basic_auth %}
    import base64
    credentials = base64.b64encode(b"admin@example.com:" + admin_user_token.encode()).decode()
    return {"Authorization": f"Basic {credentials}"}
    {% elif has_apikey_auth %}
    # For cookie-based API key, create a session
    from app.domain.models import User, APIKey
    from sqlmodel import select
    import secrets

    # Get admin user
    statement = select(User).where(User.email == "admin@example.com")
    user = db.exec(statement).first()

    if not user:
        return {}

    # Create or get API key for admin
    statement = select(APIKey).where(APIKey.user_id == user.id)
    existing_key = db.exec(statement).first()

    if existing_key:
        key_value = existing_key.key
    else:
        key_value = secrets.token_urlsafe(32)
        api_key = APIKey(user_id=user.id, key=key_value)
        db.add(api_key)
        db.commit()

    {% if apikey_location == 'cookie' %}
    return {"Cookie": f"{{ apikey_header }}={key_value}"}
    {% elif apikey_location == 'query' %}
    return {}  # Query params handled in URL
    {% else %}
    return {"{{ apikey_header }}": key_value}
    {% endif %}
    {% endif %}
{% endif %}
{% endif %}
