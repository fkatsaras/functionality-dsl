# ========================================================================
# AUTO-GENERATED COMBINED WEBSOCKET ROUTER: {{ ws_channel }}
# Handles bidirectional WebSocket communication
# ========================================================================

import logging
import json
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from typing import Set, Optional, Union, Tuple
from pydantic import ValidationError
import asyncio

{% if has_subscribe %}
from app.services.{{ subscribe_entity_name | lower }}_service import {{ subscribe_entity_name }}Service
{% endif %}
{% if has_publish %}
from app.services.{{ publish_entity_name | lower }}_service import {{ publish_entity_name }}Service
{% endif %}

from app.core.error_handlers import (
    WebSocketErrorHandler,
    ErrorCategory,
    classify_error
)
{% if has_auth %}
# Import auth utilities - supports both JWT and session auth
try:
    from app.core.auth import decode_token, TokenPayload
    AUTH_TYPE = "jwt"
except ImportError:
    # Session auth module has different interface
    from app.core.auth import get_session, TokenPayload, SESSION_COOKIE_NAME
    AUTH_TYPE = "session"
{% endif %}

logger = logging.getLogger("fdsl.ws.{{ ws_channel }}")

router = APIRouter()

# Track active WebSocket connections
active_connections: Set[WebSocket] = set()


def extract_binary_payload(message: Union[dict, bytes]) -> Tuple[bool, Union[bytes, dict]]:
    """
    Extract binary payload from message if present.
    Returns (is_binary, payload) where payload is either raw bytes or the original dict.

    Handles:
    - Raw bytes: returns (True, bytes)
    - Dict with single binary value: returns (True, bytes)
    - Dict with all non-binary values: returns (False, dict)
    """
    if isinstance(message, bytes):
        return True, message

    if isinstance(message, dict):
        # Check if dict contains a single binary value
        binary_values = [(k, v) for k, v in message.items() if isinstance(v, bytes)]
        if len(binary_values) == 1 and len(message) == 1:
            # Single binary attribute - extract the bytes
            return True, binary_values[0][1]

    return False, message


@router.websocket("{{ ws_channel }}")
async def websocket_combined_endpoint(websocket: WebSocket):
    """
    Combined WebSocket endpoint for {{ ws_channel }}.
    Supports: {% if has_subscribe %}subscribe{% endif %}{% if has_subscribe and has_publish %}, {% endif %}{% if has_publish %}publish{% endif %}
    {% if has_subscribe and subscribe_filters %}
    Filters: {{ subscribe_filters | join(', ') }}
    {% endif %}
    """
    {% if has_auth %}
    # Authenticate before accepting connection
    user: Optional[TokenPayload] = None

    # Extract credentials based on auth type
    if AUTH_TYPE == "jwt":
        # JWT auth: Extract token from Authorization header: "Bearer <token>"
        auth_header = websocket.headers.get("authorization") or websocket.headers.get("Authorization")
        token = None
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header[7:]  # Remove "Bearer " prefix
    else:
        # Session auth: Extract session cookie
        # WebSocket cookies come from the Cookie header
        cookie_header = websocket.headers.get("cookie", "")
        session_id = None
        if cookie_header:
            for cookie in cookie_header.split(";"):
                cookie = cookie.strip()
                if cookie.startswith(f"{SESSION_COOKIE_NAME}="):
                    session_id = cookie[len(SESSION_COOKIE_NAME) + 1:]
                    break

    {% if subscribe_required_roles != ["public"] or publish_required_roles != ["public"] %}
    # Check if authentication is required
    {% if subscribe_required_roles != ["public"] %}
    subscribe_requires_auth = True
    subscribe_roles = {{ subscribe_required_roles }}
    {% else %}
    subscribe_requires_auth = False
    subscribe_roles = []
    {% endif %}
    {% if publish_required_roles != ["public"] %}
    publish_requires_auth = True
    publish_roles = {{ publish_required_roles }}
    {% else %}
    publish_requires_auth = False
    publish_roles = []
    {% endif %}

    # Verify credentials if required
    if subscribe_requires_auth or publish_requires_auth:
        has_credentials = (AUTH_TYPE == "jwt" and token) or (AUTH_TYPE == "session" and session_id)

        # Case 1: Both operations require auth - reject if no credentials
        if subscribe_requires_auth and publish_requires_auth:
            if not has_credentials:
                logger.warning("WebSocket connection rejected: No credentials provided (both subscribe and publish require auth)")
                await websocket.close(code=1008, reason="Authentication required")
                return

        # Case 2: Only subscribe requires auth - reject if no credentials
        elif subscribe_requires_auth:
            if not has_credentials:
                logger.warning("WebSocket connection rejected: No credentials provided (subscribe requires auth)")
                await websocket.close(code=1008, reason="Authentication required for subscribe")
                return

        # Case 3: Only publish requires auth - accept connection, but validate credentials if provided
        # (user can subscribe without auth, but needs auth to publish)

        # Validate credentials if present
        if has_credentials:
            try:
                if AUTH_TYPE == "jwt":
                    user = decode_token(token)
                else:
                    # Session auth - get session data
                    session = get_session(session_id)
                    if not session:
                        raise Exception("Invalid or expired session")
                    user = TokenPayload(user_id=session.user_id, roles=session.roles)

                logger.info(f"WebSocket authenticated: user={user.user_id}, roles={user.roles}")

                # Check subscribe permissions
                {% if subscribe_required_roles != ["public"] %}
                if subscribe_requires_auth and not user.has_any_role(subscribe_roles):
                    logger.warning(f"WebSocket connection rejected: User {user.user_id} lacks required roles for subscribe: {subscribe_roles}")
                    await websocket.close(code=1008, reason="Insufficient permissions for subscribe")
                    return
                {% endif %}

                # Check publish permissions
                {% if publish_required_roles != ["public"] %}
                if publish_requires_auth and not user.has_any_role(publish_roles):
                    logger.warning(f"WebSocket connection rejected: User {user.user_id} lacks required roles for publish: {publish_roles}")
                    await websocket.close(code=1008, reason="Insufficient permissions for publish")
                    return
                {% endif %}

            except Exception as e:
                logger.warning(f"WebSocket authentication failed: {str(e)}")
                await websocket.close(code=1008, reason=f"Authentication failed: {str(e)}")
                return
    {% endif %}
    {% endif %}

    await websocket.accept()
    active_connections.add(websocket)
    logger.info(f"Client connected to {{ ws_channel }}. Total connections: {len(active_connections)}")

    {% if has_subscribe %}
    subscribe_service = {{ subscribe_entity_name }}Service()

    # Extract filter values from query parameters
    {% if subscribe_filters %}
    filter_values = {}
    {% for filter_field in subscribe_filters %}
    filter_values["{{ filter_field }}"] = websocket.query_params.get("{{ filter_field }}")
    {% endfor %}
    logger.info(f"Applied filters: {filter_values}")

    def message_matches_filters(message: dict) -> bool:
        """Check if message matches all specified filters."""
        for field, expected_value in filter_values.items():
            if expected_value is None:
                continue  # No filter for this field
            # Get actual value from message (handle nested dicts)
            actual_value = message.get(field)
            if actual_value is None:
                return False  # Field not in message
            # Convert to string for comparison
            if str(actual_value) != str(expected_value):
                return False
        return True
    {% endif %}
    {% endif %}
    {% if has_publish %}
    publish_service = {{ publish_entity_name }}Service()
    {% endif %}

    try:
        {% if has_subscribe and has_publish %}
        # Bidirectional mode: Run subscribe and publish concurrently
        {% if has_subscribe %}
        from app.sources.{{ subscribe_ws_source.name | lower }}_source import {{ subscribe_ws_source.name }}Source

        subscribe_source = {{ subscribe_ws_source.name }}Source()
        {% endif %}
        {% if has_publish and publish_ws_target %}
        from app.sources.{{ publish_ws_target.name | lower }}_source import {{ publish_ws_target.name }}Source

        # Check if subscribe and publish use the same source - if so, share the connection
        {% if has_subscribe and subscribe_ws_source.name == publish_ws_target.name %}
        publish_target = subscribe_source  # Share the same connection
        {% else %}
        publish_target = {{ publish_ws_target.name }}Source()
        {% endif %}
        {% endif %}

        async def handle_subscribe():
            """Subscribe task: Stream data from external source to client."""
            async for raw_message in subscribe_source.subscribe():
                if raw_message is None:
                    continue

                # Transform raw message through entity service
                # Note: Binary messages are pre-wrapped by the source client
                transformed_message = subscribe_service._transform_entity(raw_message)

                # Apply filters if specified
                {% if subscribe_filters %}
                if not message_matches_filters(transformed_message):
                    continue  # Skip this message, doesn't match filters
                {% endif %}

                # Send to client - extract binary payload if present
                is_binary, payload = extract_binary_payload(transformed_message)
                if is_binary:
                    await websocket.send_bytes(payload)
                    logger.debug(f"Sent binary to client: {{ subscribe_entity_name }} ({len(payload)} bytes)")
                else:
                    await websocket.send_json(payload)
                    logger.debug(f"Sent message to client: {{ subscribe_entity_name }}")

        async def handle_publish():
            """Publish task: Receive data from client and send to external target."""
            while True:
                try:
                    {% if has_auth and publish_required_roles != ["public"] %}
                    # Runtime check: Verify user has publish permissions
                    if not user or not user.has_any_role(publish_roles):
                        # User tried to publish without proper auth/permissions
                        error_msg = "Publish operation requires authentication" if not user else f"User lacks required roles for publish: {publish_roles}"
                        logger.warning(f"Publish rejected: {error_msg}")
                        await WebSocketErrorHandler.send_error(
                            websocket,
                            Exception(error_msg),
                            ErrorCategory.FORBIDDEN,
                            logger,
                            close_connection=True
                        )
                        return
                    {% endif %}

                    # Receive message based on content type
                    {% if publish_is_text %}
                    # Content type is text/plain - receive as text
                    raw_data = await websocket.receive_text()
                    logger.debug(f"Received text message from client: {raw_data}")
                    {% else %}
                    # Content type is application/json - receive as JSON
                    raw_data = await websocket.receive_json()
                    logger.debug(f"Received JSON message from client: {raw_data}")
                    {% endif %}
                except json.JSONDecodeError as e:
                    await WebSocketErrorHandler.handle_json_decode_error(websocket, e, logger)
                    continue
                except ValueError as e:
                    await WebSocketErrorHandler.send_error(
                        websocket, e, ErrorCategory.BAD_REQUEST, logger
                    )
                    continue

                try:
                    # Wrap primitive values for wrapper entities
                    {% if publish_entity_type in ["string", "number", "integer", "boolean", "array", "binary"] and publish_wrapper_key %}
                    # Parent entity is a primitive type - wrap in object with attribute name
                    data = {"{{ publish_wrapper_key }}": raw_data}
                    logger.debug(f"Wrapped primitive value: {data}")
                    {% else %}
                    # Parent entity is a full object, use as-is
                    data = raw_data
                    {% endif %}

                    # Transform through entity service
                    transformed_data = publish_service._transform_entity(data)
                    logger.debug(f"Transformed message: {transformed_data}")

                    {% if publish_ws_target %}
                    # Publish to external WebSocket target
                    await publish_target.publish(transformed_data)
                    logger.debug(f"Published to external target: {{ publish_ws_target.name }}")
                    {% else %}
                    # No target specified - message processed but not forwarded
                    logger.warning("Message processed but no target specified for {{ publish_entity_name }}")
                    {% endif %}

                except ValidationError as e:
                    await WebSocketErrorHandler.handle_validation_error(websocket, e, logger)
                except Exception as e:
                    await WebSocketErrorHandler.handle_processing_error(websocket, e, logger, fatal=False)

        # Run both tasks concurrently
        await asyncio.gather(
            handle_subscribe(),
            handle_publish(),
            return_exceptions=True
        )

        {% elif has_subscribe %}
        # Subscribe-only mode: Stream data from external source(s) to client
        {% if is_chained_composite %}
        # Chained composite: This entity inherits from composite parent(s)
        # Chain: {{ subscribe_entity_name }} {% for svc in intermediate_services %}-> {{ svc }} {% endfor %}-> Base entities

        # Import all intermediate services in the transformation chain
        {% for service_name in intermediate_services %}
        from app.services.{{ service_name | lower }}_service import {{ service_name }}Service
        {% endfor %}

        # Create service instances for transformation chain
        {% for service_name in intermediate_services %}
        {{ service_name | lower }}_service = {{ service_name }}Service()
        {% endfor %}

        # Subscribe to the base WebSocket sources (discovered recursively)
        {% if subscribe_ws_sources | length > 1 %}
        # Multiple WebSocket sources - merge streams (with chained transformation)
        import asyncio
        from typing import Dict
        {% for source, parent_entity in subscribe_ws_sources %}
        from app.sources.{{ source.name | lower }}_source import {{ source.name }}Source
        {% endfor %}

        # Create source instances
        {% for source, parent_entity in subscribe_ws_sources %}
        {{ parent_entity.name | lower }}_source = {{ source.name }}Source()
        {% endfor %}

        # Shared state for latest messages from each source
        latest_messages: Dict[str, dict] = {}
        message_lock = asyncio.Lock()

        async def subscribe_to_source(source_name: str, source, parent_entity_name: str):
            """Subscribe to a single WebSocket source and update shared state."""
            try:
                async for raw_message in source.subscribe():
                    if raw_message is None:
                        continue

                    # Note: Binary messages are pre-wrapped by the source client
                    async with message_lock:
                        latest_messages[parent_entity_name] = raw_message

                        # Only transform and send if we have messages from all sources
                        if len(latest_messages) == {{ subscribe_ws_sources | length }}:
                            # Chain transformations through all intermediate services
                            transformed = latest_messages.copy()

                            # Apply transformations in reverse order (from deepest parent to current entity)
                            {% for service_name in intermediate_services | reverse %}
                            transformed = {{ service_name | lower }}_service._transform_entity(transformed)
                            transformed = {"{{ service_name }}": transformed}  # Wrap for next level
                            {% endfor %}

                            # Final transformation through this entity's service
                            final_message = subscribe_service._transform_entity(transformed)

                            # Apply filters if specified
                            {% if subscribe_filters %}
                            if not message_matches_filters(final_message):
                                continue  # Skip this message, doesn't match filters
                            {% endif %}

                            # Send to client - extract binary payload if present
                            is_binary, payload = extract_binary_payload(final_message)
                            if is_binary:
                                await websocket.send_bytes(payload)
                                logger.debug(f"Sent binary to client: {{ subscribe_entity_name }} ({len(payload)} bytes)")
                            else:
                                await websocket.send_json(payload)
                                logger.debug(f"Sent chained composite message to client: {{ subscribe_entity_name }}")
            except Exception as e:
                error_category = classify_error(e)
                logger.error(f"Error in {source_name} subscription: {e} (category: {error_category.value})")
                await WebSocketErrorHandler.send_error(
                    websocket, e, error_category, logger, close_connection=False
                )

        # Run all subscriptions concurrently
        await asyncio.gather(
            {% for source, parent_entity in subscribe_ws_sources %}
            subscribe_to_source("{{ source.name }}", {{ parent_entity.name | lower }}_source, "{{ parent_entity.name }}"){{ "," if not loop.last else "" }}
            {% endfor %}
        )
        {% else %}
        # Single WebSocket source with chained transformations
        from app.sources.{{ subscribe_ws_source.name | lower }}_source import {{ subscribe_ws_source.name }}Source

        source = {{ subscribe_ws_source.name }}Source()

        async for raw_message in source.subscribe():
            if raw_message is None:
                continue

            # Chain transformations through all intermediate services
            # Note: Binary messages are pre-wrapped by the source client
            transformed = raw_message
            {% for service_name in intermediate_services | reverse %}
            transformed = {{ service_name | lower }}_service._transform_entity(transformed)
            transformed = {"{{ service_name }}": transformed}  # Wrap for next level
            {% endfor %}

            # Final transformation through this entity's service
            final_message = subscribe_service._transform_entity(transformed)

            # Send to client - extract binary payload if present
            is_binary, payload = extract_binary_payload(final_message)
            if is_binary:
                await websocket.send_bytes(payload)
                logger.debug(f"Sent binary to client: {{ subscribe_entity_name }} ({len(payload)} bytes)")
            else:
                await websocket.send_json(payload)
                logger.debug(f"Sent chained composite message to client: {{ subscribe_entity_name }}")
        {% endif %}
        {% elif subscribe_ws_sources | length > 1 %}
        # Multiple WebSocket sources - merge streams
        import asyncio
        from typing import Dict
        {% for source, parent_entity in subscribe_ws_sources %}
        from app.sources.{{ source.name | lower }}_source import {{ source.name }}Source
        {% endfor %}

        # Create sources
        {% for source, parent_entity in subscribe_ws_sources %}
        {{ parent_entity.name | lower }}_source = {{ source.name }}Source()
        {% endfor %}

        # Shared state for latest messages from each source
        latest_messages: Dict[str, dict] = {}
        message_lock = asyncio.Lock()

        async def subscribe_to_source(source_name: str, source, parent_entity_name: str):
            """Subscribe to a single WebSocket source and update shared state."""
            try:
                async for raw_message in source.subscribe():
                    if raw_message is None:
                        continue

                    # Note: Binary messages are pre-wrapped by the source client
                    async with message_lock:
                        latest_messages[parent_entity_name] = raw_message

                        # Only transform and send if we have messages from all sources
                        if len(latest_messages) == {{ subscribe_ws_sources | length }}:
                            # Transform combined messages through entity service
                            # Pass dict mapping parent names to their raw messages
                            transformed_message = subscribe_service._transform_entity(latest_messages)

                            # Apply filters if specified
                            {% if subscribe_filters %}
                            if not message_matches_filters(transformed_message):
                                continue  # Skip this message, doesn't match filters
                            {% endif %}

                            # Send to client - extract binary payload if present
                            is_binary, payload = extract_binary_payload(transformed_message)
                            if is_binary:
                                await websocket.send_bytes(payload)
                                logger.debug(f"Sent binary to client: {{ subscribe_entity_name }} ({len(payload)} bytes)")
                            else:
                                await websocket.send_json(payload)
                                logger.debug(f"Sent combined message to client: {{ subscribe_entity_name }}")
            except Exception as e:
                error_category = classify_error(e)
                logger.error(f"Error in {source_name} subscription: {e} (category: {error_category.value})")
                # Don't raise - let other sources continue working
                # Send error to client but keep connection open
                await WebSocketErrorHandler.send_error(
                    websocket, e, error_category, logger, close_connection=False
                )

        # Run all subscriptions concurrently
        await asyncio.gather(
            {% for source, parent_entity in subscribe_ws_sources %}
            subscribe_to_source("{{ source.name }}", {{ parent_entity.name | lower }}_source, "{{ parent_entity.name }}"){{ "," if not loop.last else "" }}
            {% endfor %}
        )
        {% else %}
        # Single WebSocket source
        from app.sources.{{ subscribe_ws_source.name | lower }}_source import {{ subscribe_ws_source.name }}Source

        source = {{ subscribe_ws_source.name }}Source()

        async for raw_message in source.subscribe():
            if raw_message is None:
                continue

            # Transform raw message through entity service
            # Note: Binary messages are pre-wrapped by the source client
            transformed_message = subscribe_service._transform_entity(raw_message)

            # Apply filters if specified
            {% if subscribe_filters %}
            if not message_matches_filters(transformed_message):
                continue  # Skip this message, doesn't match filters
            {% endif %}

            # Send to client - extract binary payload if present
            is_binary, payload = extract_binary_payload(transformed_message)
            if is_binary:
                await websocket.send_bytes(payload)
                logger.debug(f"Sent binary to client: {{ subscribe_entity_name }} ({len(payload)} bytes)")
            else:
                await websocket.send_json(payload)
                logger.debug(f"Sent message to client: {{ subscribe_entity_name }}")
        {% endif %}

        {% elif has_publish %}
        # Publish-only mode: Receive data from client and send to external target
        {% if publish_ws_target %}
        from app.sources.{{ publish_ws_target.name | lower }}_source import {{ publish_ws_target.name }}Source

        target_source = {{ publish_ws_target.name }}Source()
        {% endif %}

        while True:
            {% if has_auth and publish_required_roles != ["public"] %}
            # Runtime check: Verify user has publish permissions
            if not user or not user.has_any_role(publish_roles):
                # User tried to publish without proper auth/permissions
                error_msg = "Publish operation requires authentication" if not user else f"User lacks required roles for publish: {publish_roles}"
                logger.warning(f"Publish rejected: {error_msg}")
                await WebSocketErrorHandler.send_error(
                    websocket,
                    Exception(error_msg),
                    ErrorCategory.FORBIDDEN,
                    logger,
                    close_connection=True
                )
                break
            {% endif %}

            # Receive message based on content type
            {% if publish_is_text %}
            # Content type is text/plain - receive as text
            raw_data = await websocket.receive_text()
            logger.debug(f"Received text message from client: {raw_data}")
            {% else %}
            # Content type is application/json - receive as JSON
            raw_data = await websocket.receive_json()
            logger.debug(f"Received JSON message from client: {raw_data}")
            {% endif %}

            # Wrap primitive values for wrapper entities
            {% if publish_entity_type in ["string", "number", "integer", "boolean", "array", "binary"] and publish_wrapper_key %}
            # Parent entity is a primitive type - wrap in object with attribute name
            data = {"{{ publish_wrapper_key }}": raw_data}
            logger.debug(f"Wrapped primitive value: {data}")
            {% else %}
            # Parent entity is a full object, use as-is
            data = raw_data
            {% endif %}

            # Transform through entity service
            transformed_data = publish_service._transform_entity(data)
            logger.debug(f"Transformed message: {transformed_data}")

            {% if publish_ws_target %}
            # Publish to external WebSocket target
            await target_source.publish(transformed_data)
            logger.debug(f"Published to external target: {{ publish_ws_target.name }}")
            {% else %}
            # No target specified - message processed but not forwarded
            logger.warning("Message processed but no target specified for {{ publish_entity_name }}")
            {% endif %}

        {% endif %}

    except WebSocketDisconnect:
        logger.info("Client disconnected from {{ ws_channel }}")
    except ConnectionRefusedError as e:
        await WebSocketErrorHandler.handle_connection_error(
            websocket, e, logger, "{{ ws_channel }}"
        )
    except OSError as e:
        # Handle network errors (DNS resolution, connection issues, etc.)
        if "Name or service not known" in str(e) or "gaierror" in str(type(e).__name__):
            await WebSocketErrorHandler.handle_connection_error(
                websocket, e, logger, "external WebSocket source"
            )
        else:
            await WebSocketErrorHandler.handle_processing_error(
                websocket, e, logger, fatal=True
            )
    except Exception as e:
        # Classify error and handle appropriately
        error_category = classify_error(e)
        await WebSocketErrorHandler.send_error(
            websocket, e, error_category, logger, close_connection=True
        )
    finally:
        if websocket in active_connections:
            active_connections.remove(websocket)
        logger.info(f"Connection closed. Remaining connections: {len(active_connections)}")
