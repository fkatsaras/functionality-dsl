// ========================================================================
// ENTITY CHAINING STRESS TEST SUITE
// ========================================================================

Server ChainServer
  host: "localhost"
  port: 8082
  cors: "http://localhost:5173"
  loglevel: debug
end

// ========================================================================
// SOURCES
// ========================================================================

Source<REST> Source1
  url: "https://httpbin.org/anything/source1"
  verb: GET
end

Source<REST> Source2
  url: "https://httpbin.org/anything/source2"
  verb: GET
end

Source<REST> Source3
  url: "https://httpbin.org/anything/source3"
  verb: GET
end

Source<REST> Source4
  url: "https://httpbin.org/anything/source4"
  verb: GET
end

// Source<WS> StreamA
//   url: "wss://echo.websocket.events"
// end

// Source<WS> StreamB
//   url: "wss://echo.websocket.events"
// end

// ========================================================================
// TEST 1 : Deep Multi-Branch Merge Chain
// ========================================================================
// Graph:  Source1 → E1 → E2(E1,E4,E8) → E3(E2) → Endpoint(GET)
//         Source2 → E4
//         Source3 → E5 → E6(E5,E7) → E8
//         Source4 → E7
// ========================================================================

APIEndpoint<REST> DeepChain
  path: "/api/deep"
  verb: GET
  entity: E3
end

Entity E1
  source: Source1
  attributes:
    - msg: string = "E1_from_" + "Source1";
end

Entity E4
  source: Source2
  attributes:
    - data4: string = "E4_from_" + "Source2";
end

Entity E5
  source: Source3
  attributes:
    - data5: string = "E5_from_" + "Source3";
end

Entity E7
  source: Source4
  attributes:
    - data7: string = "E7_from_" + "Source4";
end

Entity E6(E5,E7)
  attributes:
    - merged: string = E5.data5 + "_" + E7.data7;
end

Entity E8(E6)
  attributes:
    - echo: string = "E8_" + E6.merged;
end

Entity E2(E1,E4,E8)
  attributes:
    - combined: string = E1.msg + "_" + E4.data4 + "_" + E8.echo;
  validations:
    - require(len(E2.combined) > 0, "E2.combined empty", 400);
end

Entity E3(E2)
  attributes:
    - final: string = E2.combined + "_E3";
end

// ========================================================================
// TEST 2 : Circular-like Chain Detection
// ========================================================================
// E9 → E10(E9) → E11(E10,E9)
// Ensures linear ordering E9,E10,E11.
// ========================================================================

APIEndpoint<REST> CircularLike
  path: "/api/circular"
  verb: GET
  entity: E11
end

Entity E9
  source: Source1
  attributes:
    - base: string = "E9";
end

Entity E10(E9)
  attributes:
    - next: string = E9.base + "_E10";
end

Entity E11(E10,E9)
  attributes:
    - final: string = E10.next + "_" + E9.base + "_E11";
end

// ========================================================================
// TEST 3 : Mutation Chain with Shared External Dependencies
// ========================================================================
// Shared Source2 used in multiple entities.
// ========================================================================

APIEndpoint<REST> SharedMutation
  path: "/api/mutate"
  verb: POST
  entity: M3
end

Entity Shared
  source: Source2
  attributes:
    - tag: string = "shared_" + "external";
end

Entity M1
  source: SharedMutation
  attributes:
    - value: int = SharedMutation.value;
end

Entity M2(M1,Shared)
  attributes:
    - joined: string = str(M1.value) + "_" + Shared.tag;
end

Entity M3(M2)
  attributes:
    - payload: dict = {"result": M2.joined};
  validations:
    - require(len(M3.payload.result) > 0, "Empty payload", 400);
end

Source<REST> SharedExternal
  url: "https://httpbin.org/anything/shared"
  verb: POST
  entity: M3
end

//// ========================================================================
//// TEST 4 : WebSocket Duplex Flow (entity_in / entity_out)
//// ========================================================================
//// Inbound WS message → processed → outbound uppercase message
//// ========================================================================
//
//APIEndpoint<WS> DuplexTest
//  path: "/ws/duplex"
//  entity_in: WSIn
//  entity_out: WSOut
//end
//
//Entity WSIn
//  attributes:
//    - msg: string = ctx["entity_in"].get("msg");
//end
//
//Entity WSOut(WSIn)
//  attributes:
//    - response: string = upper(WSIn.msg);
//end
//
//// ========================================================================
//// TEST 5 : Cross-Protocol Bridge (WS → REST)
//// ========================================================================
//// Client sends JSON on WebSocket → processed → forwarded to REST
//// ========================================================================
//
//APIEndpoint<WS> BridgeTest
//  path: "/ws/bridge"
//  entity_out: BridgeAck
//end
//
//Entity BridgeIn
//  source: BridgeTest
//  attributes:
//    - raw: string = BridgeTest.msg;
//end
//
//Entity BridgePayload(BridgeIn)
//  attributes:
//    - json: dict = {
//        "echo": BridgeIn.raw,
//        "timestamp": "2025-01-01T00:00Z"
//      };
//end
//
//Entity BridgeAck(BridgePayload)
//  attributes:
//    - status: string = "forwarded";
//    - echo: string = BridgePayload.json["echo"];
//end
//
//Source<REST> BridgeSink
//  url: "https://httpbin.org/anything/bridge"
//  verb: POST
//  entity: BridgePayload
//end
