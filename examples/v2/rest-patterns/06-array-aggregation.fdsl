// =============================================================================
// PATTERN 6: Array Aggregation (Collection Computations)
// =============================================================================
// RULE: Composite entity with array parent for aggregations
//
// Requirements:
// 1. Use EntityName[] syntax for array parent
// 2. Array parent must be base entity with @id
// 3. Array parent must expose 'list' with filters
// 4. Use relationships block to specify filter field
// 5. Aggregate functions: len(), sum(), map(), filter(), any(), all()
// =============================================================================

Server ArrayAggregation
  host: "localhost"
  port: 8000
  cors: "*"
  loglevel: debug
end

Source<REST> OrderAPI
  base_url: "http://dummy-rest-patterns:9001/array-orders"
end

Source<REST> OrderItemAPI
  base_url: "http://dummy-rest-patterns:9001/order-items"
end

// Base entities
Entity Order
  attributes:
    - orderId: string @id;
    - userId: string;
    - status: string;
    - createdAt: string;
  source: OrderAPI
  expose:
    operations: [list, read, create, update, delete]
    filters: ["userId", "status"]
end

Entity OrderItem
  attributes:
    - itemId: string @id;
    - orderId: string;
    - productId: string;
    - quantity: integer;
    - price: number;
  source: OrderItemAPI
  expose:
    operations: [list, read, create, update, delete]
    filters: ["orderId", "productId"]
    // Filter by orderId enables array aggregation
end

// Aggregate order items for an order
Entity OrderWithItems(Order, OrderItem[])
  relationships:
    - OrderItem: Order.orderId
    // Fetches: OrderItem filtered by orderId = Order.orderId
  attributes:
    - orderId: string = Order.orderId;
    - userId: string = Order.userId;
    - status: string = Order.status;
    - itemCount: integer = len(OrderItem);
    - items: array = OrderItem;
    - subtotal: number = sum(map(OrderItem, i => i["quantity"] * i["price"]));
    - avgItemPrice: number = round(subtotal / itemCount, 2) if itemCount > 0 else 0;
    - hasExpensiveItems: boolean = any(map(OrderItem, i => i["price"] > 100));
  expose:
    operations: [read]
    // GET /api/orders/{orderId}/orderwithitems
end

// Stats aggregation
Entity OrderStats(Order, OrderItem[])
  relationships:
    - OrderItem: Order.orderId
  attributes:
    - orderId: string = Order.orderId;
    - totalItems: integer = len(OrderItem);
    - totalQuantity: integer = sum(map(OrderItem, i => i["quantity"]));
    - orderValue: number = sum(map(OrderItem, i => i["quantity"] * i["price"]));
    - averageItemValue: number = round(orderValue / totalItems, 2) if totalItems > 0 else 0;
    - maxPrice: number = max(map(OrderItem, i => i["price"])) if len(OrderItem) > 0 else 0;
    - minPrice: number = min(map(OrderItem, i => i["price"])) if len(OrderItem) > 0 else 0;
  expose:
    operations: [read]
    // GET /api/orders/{orderId}/orderstats
end
