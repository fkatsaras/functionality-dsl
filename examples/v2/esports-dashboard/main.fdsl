// =============================================================================
// Live Esports Dashboard - Real-time Match Tracking & Predictions
// =============================================================================
// Demonstrates:
// - REST CRUD: Teams, players, match history
// - Type formats: uuid_str, uri, date, time
// - WebSocket inbound: Live match events (kills, objectives, score updates)
// - WebSocket outbound: User predictions/bets
// - Composite entities: Live stats, leaderboards, match summaries
//
// Thesis Focus: Real-time event streaming + aggregation + user interactions
// =============================================================================

Role viewer
Role analyst
Role bettor

Auth EsportsAuth
  type: jwt
  secret: "ESPORTS_JWT_SECRET"
end

Server EsportsDashboard
  host: "localhost"
  port: 8080
  cors: "*"
  loglevel: debug
  auth: EsportsAuth
end

// =============================================================================
// REST SOURCES - Team & Match Data
// =============================================================================

Source<REST> TeamAPI
  url: "http://dummy-esports:9001/teams"
  operations: [read]
end

Source<REST> PlayerAPI
  url: "http://dummy-esports:9001/players"
  operations: [read]
end

Source<REST> MatchHistoryAPI
  url: "http://dummy-esports:9001/matches"
  operations: [read]
end

Source<REST> LeaderboardAPI
  url: "http://dummy-esports:9001/leaderboard"
  operations: [read]
end

Source<REST> UserPredictionsAPI
  url: "http://dummy-esports:9001/predictions"
  operations: [read, create]
end

// =============================================================================
// WEBSOCKET SOURCES - Live Match Data
// =============================================================================

Source<WS> MatchEventStream
  channel: "ws://dummy-esports:9001/ws/match-events"
  operations: [subscribe]
end

Source<WS> ScoreStream
  channel: "ws://dummy-esports:9001/ws/scores"
  operations: [subscribe]
end

Source<WS> PredictionChannel
  channel: "ws://dummy-esports:9001/ws/predictions"
  operations: [publish]
end

// =============================================================================
// REST ENTITIES - Static Data
// =============================================================================

// Team profiles
Entity Team
  source: TeamAPI
  attributes:
    - team_id: string<uuid_str> @readonly;
    - name: string @readonly;
    - tag: string @readonly;
    - logo_url: string<uri> @readonly;
    - region: string @readonly;
    - founded_date: string<date> @readonly;
    - wins: integer @readonly;
    - losses: integer @readonly;
    - winrate: number @readonly;
  access: public
end

// Player profiles
Entity Player
  source: PlayerAPI
  attributes:
    - player_id: string<uuid_str> @readonly;
    - username: string @readonly;
    - real_name: string @readonly;
    - team_id: string<uuid_str> @readonly;
    - role: string @readonly;
    - country: string @readonly;
    - avatar_url: string<uri> @readonly;
    - career_kills: integer @readonly;
    - career_deaths: integer @readonly;
    - career_assists: integer @readonly;
  access: public
end

// Match history
Entity MatchHistory
  source: MatchHistoryAPI
  attributes:
    - match_id: string<uuid_str> @readonly;
    - tournament: string @readonly;
    - team1_id: string<uuid_str> @readonly;
    - team2_id: string<uuid_str> @readonly;
    - team1_score: integer @readonly;
    - team2_score: integer @readonly;
    - winner_id: string<uuid_str> @readonly;
    - match_date: string<date> @readonly;
    - duration_minutes: integer @readonly;
    - vod_url: string<uri> @readonly;
  access: public
end

// Global leaderboard (snapshot with array field for Table component)
Entity Leaderboard
  source: LeaderboardAPI
  attributes:
    - rankings: array @readonly;
  access: public
end

// User predictions (CRUD)
// Demonstrates type formats: uuid_str, date, time
Entity UserPrediction
  source: UserPredictionsAPI
  attributes:
    - prediction_id: string<uuid_str> @readonly;
    - match_id: string<uuid_str>;
    - predicted_winner: string<uuid_str>;
    - predicted_score: string;
    - confidence: integer;
    - placed_at: string @readonly;
    - result: string @readonly;
    - points_earned: integer @readonly;
  access: [bettor]
end

// =============================================================================
// WEBSOCKET ENTITIES - Live Match Data
// =============================================================================

// Inbound: Live match events (kills, objectives, etc.)
Entity MatchEvent
  type: inbound
  source: MatchEventStream
  attributes:
    - match_id: string;
    - event_type: string;
    - timestamp: integer;
    - player_id: string;
    - player_name: string;
    - team_id: string;
    - target_id: string;
    - target_name: string;
    - details: object;
end

// Inbound: Live score updates
Entity ScoreUpdate
  type: inbound
  source: ScoreStream
  attributes:
    - match_id: string;
    - team1_score: integer;
    - team2_score: integer;
    - game_time: integer;
    - status: string;
end

// Outbound: Place prediction during live match
// Demonstrates @optional on outbound WS entity
Entity LivePrediction
  type: outbound
  source: PredictionChannel
  attributes:
    - match_id: string;
    - predicted_winner: string;
    - predicted_score: string @optional;
    - confidence: integer;
  access: [bettor]
end

// =============================================================================
// COMPOSITE ENTITIES - Live Analytics
// =============================================================================

// Live match feed with event categorization
Entity LiveMatchFeed(MatchEvent)
  type: inbound
  attributes:
    - match_id: string = MatchEvent.match_id;
    - event: string = MatchEvent.event_type;
    - time: integer = MatchEvent.timestamp;
    - actor: string = MatchEvent.player_name;
    - team: string = MatchEvent.team_id;
    - target: string = MatchEvent.target_name;
    - is_kill: boolean = MatchEvent.event_type == "kill" or MatchEvent.event_type == "headshot";
    - is_objective: boolean = MatchEvent.event_type == "tower" or MatchEvent.event_type == "dragon" or MatchEvent.event_type == "baron";
    - event_value: integer = 1 if MatchEvent.event_type == "kill"
        else (2 if MatchEvent.event_type == "assist"
        else (5 if MatchEvent.event_type == "tower"
        else (10 if MatchEvent.event_type == "dragon"
        else (15 if MatchEvent.event_type == "baron" else 0))));
  access: public
end

// Live scoreboard with game state
Entity LiveScoreboard(ScoreUpdate)
  type: inbound
  attributes:
    - match_id: string = ScoreUpdate.match_id;
    - team1: integer = ScoreUpdate.team1_score;
    - team2: integer = ScoreUpdate.team2_score;
    - game_minutes: integer = ScoreUpdate.game_time / 60;
    - game_seconds: integer = ScoreUpdate.game_time - (LiveScoreboard.game_minutes * 60);
    - time_display: string = toString(LiveScoreboard.game_minutes) + ":" + toString(LiveScoreboard.game_seconds);
    - total_kills: integer = ScoreUpdate.team1_score + ScoreUpdate.team2_score;
    - score_diff: integer = ScoreUpdate.team1_score - ScoreUpdate.team2_score;
    - leading_team: string = "team1" if ScoreUpdate.team1_score > ScoreUpdate.team2_score
        else ("team2" if ScoreUpdate.team2_score > ScoreUpdate.team1_score else "tied");
    - is_close_game: boolean = ScoreUpdate.team1_score - ScoreUpdate.team2_score >= -3 and ScoreUpdate.team1_score - ScoreUpdate.team2_score <= 3;
    - match_status: string = ScoreUpdate.status;
  access: public
end

// Combined live dashboard (both event stream and scores)
Entity LiveDashboard(MatchEvent, ScoreUpdate)
  type: inbound
  attributes:
    - match_id: string = ScoreUpdate.match_id;
    - team1_score: integer = ScoreUpdate.team1_score;
    - team2_score: integer = ScoreUpdate.team2_score;
    - game_time: integer = ScoreUpdate.game_time;
    - last_event: string = MatchEvent.event_type;
    - last_event_player: string = MatchEvent.player_name;
    - last_event_time: integer = MatchEvent.timestamp;
    - match_intensity: string = "high" if ScoreUpdate.team1_score + ScoreUpdate.team2_score > 20
        else ("medium" if ScoreUpdate.team1_score + ScoreUpdate.team2_score > 10 else "low");
  access: public
end

// Player KDA calculation (composite from REST)
Entity PlayerStats(Player)
  attributes:
    - player_id: string = Player.player_id;
    - username: string = Player.username;
    - team_id: string = Player.team_id;
    - role: string = Player.role;
    - kills: integer = Player.career_kills;
    - deaths: integer = Player.career_deaths;
    - assists: integer = Player.career_assists;
    - kda: number = round((Player.career_kills + Player.career_assists) / Player.career_deaths, 2) if Player.career_deaths > 0 else 0.0;
    - kda_rating: string = "excellent" if PlayerStats.kda > 4
        else ("good" if PlayerStats.kda > 2.5
        else ("average" if PlayerStats.kda > 1.5 else "needs_improvement"));
  access: public
end

// Team statistics (composite from REST)
Entity TeamStats(Team)
  attributes:
    - team_id: string = Team.team_id;
    - name: string = Team.name;
    - tag: string = Team.tag;
    - region: string = Team.region;
    - total_matches: integer = Team.wins + Team.losses;
    - win_percentage: number = round(Team.wins / TeamStats.total_matches * 100, 1) if TeamStats.total_matches > 0 else 0.0;
    - form: string = "hot" if Team.winrate > 0.7
        else ("good" if Team.winrate > 0.5
        else ("struggling" if Team.winrate > 0.3 else "cold"));
    - tier: string = "S" if Team.winrate > 0.8
        else ("A" if Team.winrate > 0.6
        else ("B" if Team.winrate > 0.4
        else ("C" if Team.winrate > 0.2 else "D")));
  access: public
end

// =============================================================================
// UI COMPONENTS (7 diverse components showcasing different functionality)
// =============================================================================

// 1. TABLE - Displays leaderboard data in tabular format (REST read)
// Entity returns {"rankings": [...]}, Table auto-detects array field
Component<Table> LeaderboardTable
  entity: Leaderboard
  colNames: ["rank", "team_name", "points", "matches_played", "win_streak"]
end

// 2. PROGRESS - Visual percentage bar for win rate (REST read)
Component<Progress> TeamWinProgress
  entity: TeamStats
  field: "win_percentage"
  label: "Team Win Rate"
  max: 100.0
end

// 3. ACTIONFORM - REST POST to create a new prediction
Component<ActionForm> PlacePrediction
  entity: UserPrediction
  operation: create
  fields: [match_id, predicted_winner, predicted_score, confidence]
  submitLabel: "Place Prediction"
end

// 4. PUBLISHFORM - WebSocket publish for live in-game predictions
Component<PublishForm> LiveBetForm
  entity: LivePrediction
  fields: [match_id, predicted_winner, confidence]
  submitLabel: "Quick Bet"
end

// 5. LIVEMETRICS - Real-time WebSocket score updates
Component<LiveMetrics> LiveScore
  entity: LiveScoreboard
  metrics: ["team1", "team2", "time_display", "leading_team"]
  label: "Live Score"
end

// 6. DATACARD - Display player stats with computed KDA (REST composite)
Component<DataCard> PlayerCard
  entity: PlayerStats
  fields: ["username", "role", "kda", "kda_rating"]
  title: "Player Statistics"
  highlight: "kda_rating"
end

// 7. BARCHART - Visual comparison of team wins vs losses (REST read)
Component<BarChart> TeamRecord
  entity: Team
  bars:
    - field: "wins" label: "Wins" color: "#4CAF50"
    - field: "losses" label: "Losses" color: "#f44336"
  title: "Team Record"
  xLabel: "Result"
  yLabel: "Games"
end
