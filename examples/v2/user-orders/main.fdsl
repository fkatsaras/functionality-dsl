// ============================================================================
// USER-ORDERS API - Multi-Level Nested REST Resources
// Demonstrates nested REST paths: /users/{userId}/orders/{orderId}/items/{itemId}
// ============================================================================

Server UserOrdersAPI
  host: "localhost"
  port: 8080
  cors: "*"
  loglevel: debug
end

// ============================================================================
// DATA SOURCES
// ============================================================================

Source<REST> UserDB
  base_url: "http://dummy-user-orders-service:9001/users"
end

Source<REST> OrderDB
  base_url: "http://dummy-user-orders-service:9001/orders"
end

Source<REST> OrderItemDB
  base_url: "http://dummy-user-orders-service:9001/items"
end

// ============================================================================
// BASE RESOURCE: User (with filters)
// Path: /api/users/{userId}
// Demonstrates: Filtering list operations
// ============================================================================

Entity User
  attributes:
    - userId: string @id;
    - name: string;
    - email: string;
  source: UserDB
  expose:
    operations: [list, read, create, update, delete]
    readonly_fields: ["userId"]
    filters: ["email"]
end

// ============================================================================
// BASE RESOURCE: Order (with filters and transformations)
// Path: /api/orders/{orderId}
// Demonstrates: Filtering by status, computed fields in updates
// ============================================================================

Entity Order
  attributes:
    - orderId: string @id;
    - userId: string;
    - total: number;
    - status: string;
    - createdAt: string?;
  source: OrderDB
  expose:
    operations: [list, read, create, update, delete]
    readonly_fields: ["orderId", "createdAt"]
    filters: ["status", "userId"]
end

// ============================================================================
// BASE RESOURCE: OrderItem (flat path)
// Path: /api/orderitems/{itemId}
// ============================================================================

Entity OrderItem
  attributes:
    - itemId: string @id;
    - orderId: string;
    - productName: string;
    - quantity: integer;
    - price: number;
  source: OrderItemDB
  expose:
    operations: [list, read, create, update, delete]
    readonly_fields: ["itemId"]
    filters: ["orderId"]
end

// ============================================================================
// COMPOSITE VIEWS WITH TRANSFORMATIONS (Read-only, no source)
// Demonstrates: Real business logic and meaningful data transformations
// ============================================================================

// OrderInvoice - Complete invoice with tax, customer info, and payment details
// Path: /api/orders/{orderId}/invoice
// Use Case: Generate invoice for order with calculated tax and totals
Entity OrderInvoice(Order, User)
  relationships:
    - User: Order.userId
  attributes:
    - invoiceNumber: string = "INV-" + Order.orderId;
    - orderId: string = Order.orderId;
    - orderDate: string = Order.createdAt;
    - customerName: string = User.name;
    - customerEmail: string = User.email;
    - subtotal: number = Order.total;
    - taxRate: number = 0.08;
    - taxAmount: number = round(Order.total * 0.08, 2);
    - grandTotal: number = round(Order.total * 1.08, 2);
    - status: string = Order.status;
    - isPaid: boolean = Order.status == "completed";
    - amountDue: number = round(Order.total * 1.08, 2) if Order.status != "completed" else 0;
  expose:
    operations: [read]
end

// UserOrderHistory - Aggregate statistics about user's ordering behavior
// Path: /api/users/{userId}/orderhistory
// Use Case: Customer analytics dashboard showing ordering patterns
Entity UserOrderHistory(User, Order[])
  relationships:
    - Order: User.userId
  attributes:
    - userId: string = User.userId;
    - customerName: string = User.name;
    - customerEmail: string = User.email;
    - totalOrders: integer = len(Order);
    - totalSpent: number = round(sum(map(Order, o => o["total"])), 2);
    - averageOrderValue: number = round(sum(map(Order, o => o["total"])) / len(Order), 2) if len(Order) > 0 else 0;
    - pendingOrders: integer = len(filter(Order, o => o["status"] == "pending"));
    - completedOrders: integer = len(filter(Order, o => o["status"] == "completed"));
    - cancelledOrders: integer = len(filter(Order, o => o["status"] == "cancelled"));
    - hasActiveOrders: boolean = len(filter(Order, o => o["status"] == "pending")) > 0;
    - customerTier: string = "VIP" if sum(map(Order, o => o["total"])) > 1000 else ("Gold" if sum(map(Order, o => o["total"])) > 500 else "Silver");
    - isFrequentBuyer: boolean = len(Order) >= 5;
  expose:
    operations: [read]
end

// ============================================================================
// ARRAY PARENT EXAMPLES: Order with all its items (one-to-many)
// Demonstrates: Collection aggregations with array parent syntax
// ============================================================================

// OrderFulfillment - Warehouse/logistics view with packing information
// Path: /api/orders/{orderId}/fulfillment
// Use Case: Warehouse dashboard showing what needs to be packed and shipped
Entity OrderFulfillment(Order, User, OrderItem[])
  relationships:
    - User: Order.userId
    - OrderItem: Order.orderId
  attributes:
    - orderId: string = Order.orderId;
    - orderDate: string = Order.createdAt;
    - customerName: string = User.name;
    - shippingAddress: string = User.email;
    - status: string = Order.status;
    - totalItems: integer = len(OrderItem);
    - totalUnits: integer = sum(map(OrderItem, i => i["quantity"]));
    - itemList: array = map(OrderItem, i => i["productName"] + " (x" + toString(i["quantity"]) + ")");
    - heavyItems: integer = len(filter(OrderItem, i => i["quantity"] > 5));
    - estimatedBoxes: integer = toInt((sum(map(OrderItem, i => i["quantity"])) + 9) / 10);
    - isPriority: boolean = Order.total > 200 or sum(map(OrderItem, i => i["quantity"])) > 15;
    - needsSpecialHandling: boolean = any(map(OrderItem, i => i["price"] > 100));
    - packingComplexity: string = "High" if len(OrderItem) > 10 else ("Medium" if len(OrderItem) > 5 else "Low");
    - readyToShip: boolean = Order.status == "pending";
  expose:
    operations: [read]
end

// OrderAnalytics - Business intelligence view with profit margins and insights
// Path: /api/orders/{orderId}/analytics
// Use Case: Management dashboard showing profitability and business metrics
Entity OrderAnalytics(Order, OrderItem[])
  relationships:
    - OrderItem: Order.orderId
  attributes:
    - orderId: string = Order.orderId;
    - orderDate: string = Order.createdAt;
    - orderTotal: number = Order.total;
    - itemCount: integer = len(OrderItem);
    - uniqueProducts: integer = len(OrderItem);
    - averageItemPrice: number = round(sum(map(OrderItem, i => i["price"])) / len(OrderItem), 2) if len(OrderItem) > 0 else 0;
    - totalQuantity: integer = sum(map(OrderItem, i => i["quantity"]));
    - bulkItemsCount: integer = len(filter(OrderItem, i => i["quantity"] > 5));
    - highValueItemsCount: integer = len(filter(OrderItem, i => i["price"] > 100));
    - itemsSubtotal: number = sum(map(OrderItem, i => i["quantity"] * i["price"]));
    - calculatedTotal: number = round(sum(map(OrderItem, i => i["quantity"] * i["price"])), 2);
    - discrepancy: number = round(Order.total - sum(map(OrderItem, i => i["quantity"] * i["price"])), 2);
    - hasDiscrepancy: boolean = abs(Order.total - sum(map(OrderItem, i => i["quantity"] * i["price"]))) > 0.01;
    - assumedMargin: number = 0.3;
    - estimatedProfit: number = round(sum(map(OrderItem, i => i["quantity"] * i["price"])) * 0.3, 2);
    - profitability: string = "Excellent" if sum(map(OrderItem, i => i["quantity"] * i["price"])) > 300 else ("Good" if sum(map(OrderItem, i => i["quantity"] * i["price"])) > 100 else "Low");
  expose:
    operations: [read]
end
