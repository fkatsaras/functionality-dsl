// ============================================================================
// USER-ORDERS API - Multi-Level Nested REST Resources
// Demonstrates nested REST paths: /users/{userId}/orders/{orderId}/items/{itemId}
// ============================================================================

Server UserOrdersAPI
  host: "localhost"
  port: 8080
  cors: "*"
  loglevel: debug
end

// ============================================================================
// DATA SOURCES
// ============================================================================

Source<REST> UserDB
  base_url: "http://dummy-user-orders-service:9001/users"
  operations: [read, create, update, delete]
end

Source<REST> OrderDB
  base_url: "http://dummy-user-orders-service:9001/orders"
  operations: [read, create, update, delete]
end

Source<REST> OrderItemDB
  base_url: "http://dummy-user-orders-service:9001/items"
  operations: [read, create, update, delete]
end

// ============================================================================
// BASE RESOURCE: User (with filters)
// Path: /api/users/{userId}
// Demonstrates: Filtering list operations
// ============================================================================

Entity User
  source: UserDB
  attributes:
    - userId: string @id;
    - name: string;
    - email: string;
  // filters: ["email"]
  access: public
end

// ============================================================================
// BASE RESOURCE: Order (with filters and transformations)
// Path: /api/orders/{orderId}
// Demonstrates: Filtering by status, computed fields in updates
// ============================================================================

Entity Order
  source: OrderDB
  attributes:
    - orderId: string @id;
    - userId: string;
    - total: number;
    - status: string;
    - createdAt: string? @readonly;
  // filters: ["status", "userId"]
  access: public
end

// ============================================================================
// BASE RESOURCE: OrderItem (flat path)
// Path: /api/orderitems/{itemId}
// ============================================================================

Entity OrderItem
  source: OrderItemDB
  attributes:
    - itemId: string @id;
    - orderId: string;
    - productName: string;
    - quantity: integer;
    - price: number;
  // filters: ["orderId"]
  access: public
end


// ============================================================================
// ARRAY PARENT EXAMPLES: Order with all its items (one-to-many)
// Demonstrates: Collection aggregations with array parent syntax
// ============================================================================

// OrderFulfillment - Warehouse/logistics view with packing information
// Path: /api/orders/{orderId}/orderfulfillment
// Use Case: Warehouse dashboard showing what needs to be packed and shipped
Entity OrderFulfillment(Order, User, OrderItem[])
  relationships:
    - User: Order.userId
    - OrderItem: Order.orderId
  attributes:
    - orderId: string = Order.orderId;
    - orderDate: string = Order.createdAt;
    - customerName: string = User.name;
    - shippingAddress: string = User.email;
    - status: string = Order.status;
    - totalItems: integer = len(OrderItem);
    - totalUnits: integer = sum(map(OrderItem, i => i["quantity"]));
    - itemList: array = map(OrderItem, i => i["productName"] + " (x" + toString(i["quantity"]) + ")");
    - heavyItems: integer = len(filter(OrderItem, i => i["quantity"] > 5));
    - estimatedBoxes: integer = toInt((sum(map(OrderItem, i => i["quantity"])) + 9) / 10);
    - isPriority: boolean = Order.total > 200 or sum(map(OrderItem, i => i["quantity"])) > 15;
    - needsSpecialHandling: boolean = any(map(OrderItem, i => i["price"] > 100));
    - packingComplexity: string = "High" if len(OrderItem) > 10 else ("Medium" if len(OrderItem) > 5 else "Low");
    - readyToShip: boolean = Order.status == "pending";
  access: public
end
