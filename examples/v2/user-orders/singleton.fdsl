// ============================================================================
// USER ORDERS API - Singleton Pattern (No Collections)
// ============================================================================
// This example demonstrates singleton entities for managing users, orders, and items.
// Each entity represents the entire collection as an array attribute.
// Backend handles filtering, pagination, and individual resource management.
// ============================================================================

Server OrderManagementAPI
  host: "localhost"
  port: 8080
  cors: "*"
  loglevel: debug
end

// ============================================================================
// SOURCES - Each returns full collection as array
// ============================================================================

Source<REST> UsersAPI
  base_url: "http://dummy-user-orders-service:9001/users"
  operations: [read, create, update, delete]
end

Source<REST> OrdersAPI
  base_url: "http://dummy-user-orders-service:9001/orders"
  operations: [read, create, update, delete]
end

Source<REST> ItemsAPI
  base_url: "http://dummy-user-orders-service:9001/items"
  operations: [read, create, update, delete]
end

// ============================================================================
// BASE ENTITIES - Direct mappings to sources
// ============================================================================

Entity Users
  source: UsersAPI
  attributes:
    - users: array;
  access: public
end

Entity Orders
  source: OrdersAPI
  attributes:
    - orders: array;  // [{orderId, userId, total, status, createdAt}]
  access: public
end

Entity Items
  source: ItemsAPI
  attributes:
    - items: array;  // [{itemId, orderId, productName, quantity, price}]
  access: public
end

// ============================================================================
// COMPOSITE ENTITIES - Dashboards and Aggregations
// ============================================================================

// Complete fulfillment dashboard - combines all three sources
Entity OrderFulfillment(Orders, Users, Items)
  attributes:
    - totalOrders: integer = len(Orders.orders);
    - totalUsers: integer = len(Users.users);
    - totalItems: integer = len(Items.items);
    - pendingOrders: array = filter(Orders.orders, o => o["status"] == "pending");
    - completedOrders: array = filter(Orders.orders, o => o["status"] == "completed");
    - pendingCount: integer = len(filter(Orders.orders, o => o["status"] == "pending"));
    - completedCount: integer = len(filter(Orders.orders, o => o["status"] == "completed"));
    - totalRevenue: number = sum(map(Orders.orders, o => o["total"]));
    - highValueItems: array = filter(Items.items, i => i["price"] > 100);
    - highValueItemCount: integer = len(filter(Items.items, i => i["price"] > 100));
  access: public
end

// Users dashboard - user statistics
Entity UsersDashboard(Users)
  attributes:
    - totalUsers: integer = len(Users.users);
    - userNames: array = map(Users.users, u => u["name"]);
    - userEmails: array = map(Users.users, u => u["email"]);
  access: public
end

// Orders dashboard - order statistics and analytics
Entity OrdersDashboard(Orders, Items)
  attributes:
    - totalOrders: integer = len(Orders.orders);
    - pendingOrders: array = filter(Orders.orders, o => o["status"] == "pending");
    - completedOrders: array = filter(Orders.orders, o => o["status"] == "completed");
    - cancelledOrders: array = filter(Orders.orders, o => o["status"] == "cancelled");
    - pendingCount: integer = len(filter(Orders.orders, o => o["status"] == "pending"));
    - completedCount: integer = len(filter(Orders.orders, o => o["status"] == "completed"));
    - cancelledCount: integer = len(filter(Orders.orders, o => o["status"] == "cancelled"));
    - totalRevenue: number = sum(map(Orders.orders, o => o["total"]));
    - averageOrderValue: number = round(sum(map(Orders.orders, o => o["total"])) / len(Orders.orders), 2) if len(Orders.orders) > 0 else 0;
    - totalItemsSold: integer = sum(map(Items.items, i => i["quantity"]));
    - averageItemsPerOrder: number = round(toNumber(len(Items.items)) / toNumber(len(Orders.orders)), 2) if len(Orders.orders) > 0 else 0;
  access: public
end

// Items analytics dashboard
Entity ItemsAnalytics(Items)
  attributes:
    - totalItems: integer = len(Items.items);
    - totalQuantity: integer = sum(map(Items.items, i => i["quantity"]));
    - averagePrice: number = round(sum(map(Items.items, i => i["price"])) / len(Items.items), 2) if len(Items.items) > 0 else 0;
    - highValueItems: array = filter(Items.items, i => i["price"] > 100);
    - lowStockItems: array = filter(Items.items, i => i["quantity"] < 5);
    - productNames: array = map(Items.items, i => i["productName"]);
  access: public
end
