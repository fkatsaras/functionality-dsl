// ============================================================================
// IoT SENSOR MONITORING - Multi-Source Streaming with Derived Metrics
// Demonstrates: WebSocket subscribe with transformations, filters, and alerts
// ============================================================================

Server IoTServer
  host: "localhost"
  port: 8080
  cors: "*"
  loglevel: debug
end

// ============================================================================
// EXTERNAL WEBSOCKET SOURCE
// Could be: MQTT bridge, native WS gateway, Kafka → WS proxy
// DSL does not care about transport implementation
// ============================================================================

Source<WS> SensorWS
  channel: "ws://dummy-sensor-gateway:9001/sensors"
end

// ============================================================================
// BASE ENTITY - Raw Sensor Readings (ground truth event stream)
// ============================================================================

Entity SensorReading
  attributes:
    - sensorId: string;
    - locationId: string;
    - temperature: number;
    - humidity: number;
    - battery: number;
    - timestamp: string;
  source: SensorWS
  expose:
    operations: [subscribe]
    filters: ["sensorId", "locationId"]
    // Clients can subscribe by sensor or location
    // Example: ws://iot/ws/sensorreading?locationId=room-1
end

// ============================================================================
// DERIVED STREAM 1: Heat Index Calculation
// Real-time transformation - computed per event, no storage
// ============================================================================

Entity HeatIndexReading(SensorReading)
  attributes:
    - sensorId: string = SensorReading.sensorId;
    - locationId: string = SensorReading.locationId;
    - temperature: number = SensorReading.temperature;
    - humidity: number = SensorReading.humidity;
    - heatIndex: number = round(
        0.5 * (SensorReading.temperature +
               61.0 +
               ((SensorReading.temperature - 68.0) * 1.2) +
               (SensorReading.humidity * 0.094)),
        2
    );
    - timestamp: string = SensorReading.timestamp;
  expose:
    operations: [subscribe]
    filters: ["sensorId", "locationId"]
end

// ============================================================================
// DERIVED STREAM 2: Temperature Alerts (threshold logic)
// Shows conditional transformation - DSL really shines here
// ============================================================================

Entity TemperatureAlert(SensorReading)
  attributes:
    - sensorId: string = SensorReading.sensorId;
    - locationId: string = SensorReading.locationId;
    - temperature: number = SensorReading.temperature;
    - severity: string =
        "critical" if SensorReading.temperature > 80
        else ("warning" if SensorReading.temperature > 70 else "normal");
    - message: string =
        "Temperature critical at " + str(SensorReading.temperature)
        if SensorReading.temperature > 80
        else "Temperature normal";
    - timestamp: string = SensorReading.timestamp;
  expose:
    operations: [subscribe]
    filters: ["locationId", "severity"]
end

// ============================================================================
// UI COMPONENTS
// ============================================================================

Component<LiveView> SensorFeed
  entity: SensorReading
  fields: ["sensorId", "locationId", "temperature", "humidity", "battery", "timestamp"]
  label: "Live Sensor Readings"
end

Component<Gauge> HeatIndexGauge
  entity: HeatIndexReading
  value: "heatIndex"
  min: 0
  max: 120
  label: "Heat Index"
  unit: "°F"
end

Component<LiveView> AlertsFeed
  entity: TemperatureAlert
  fields: ["locationId", "temperature", "severity", "message", "timestamp"]
  label: "Temperature Alerts"
end
